<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/myfavicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/myfavicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/myfavicon.ico">
  <link rel="mask-icon" href="/images/myfavicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jaceding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Netty作为一款高性能网络应用程序框架，实现了一套高性能内存管理机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty池化内存机制">
<meta property="og:url" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Jace Ding">
<meta property="og:description" content="Netty作为一款高性能网络应用程序框架，实现了一套高性能内存管理机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%841.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%842.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6.png">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk2.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/PoolChunkList.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/PoolChunkList%E9%A2%9D%E5%AE%9A%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E5%8C%BA%E9%97%B4.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/SubPage%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E5%86%85%E5%AD%98%E6%B1%A0%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E5%B0%8F%E7%BB%93.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/EventLoop%E5%92%8CArena.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E5%86%85%E5%AD%98%E8%A7%84%E6%A0%BC%E5%A4%A7%E5%B0%8F.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/MemoryRegionCache%E7%BB%93%E6%9E%84%E5%9B%BE.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E7%BC%93%E5%AD%98%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/ChunkList%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/ChunkList%E7%9A%84%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Chunk%E5%92%8CPage.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Page%E5%92%8CSubPage.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Chunk%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/depthMap.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc1.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc2.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc3.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc4.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/tinySubpagePools.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/SubPage.jpg">
<meta property="og:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/bitmap.jpg">
<meta property="article:published_time" content="2021-03-25T08:27:59.000Z">
<meta property="article:modified_time" content="2021-04-02T02:14:58.129Z">
<meta property="article:author" content="Jace Ding">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="池化内存">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%841.jpg">

<link rel="canonical" href="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Netty池化内存机制 | Jace Ding</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5b3b0af00f4af4a78fb52c6720825d5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jace Ding</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jaceding.github.io/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jace Ding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jace Ding">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty池化内存机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 16:27:59" itemprop="dateCreated datePublished" datetime="2021-03-25T16:27:59+08:00">2021-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Netty作为一款高性能网络应用程序框架，实现了一套高性能内存管理机制。</p>
<a id="more"></a>

<h2 id="池化内存"><a href="#池化内存" class="headerlink" title="池化内存"></a>池化内存</h2><h3 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h3><p>Netty 向系统申请一整块连续内存，称为 chunk，默认大小 chunkSize = 16MB，通过 PoolChunk 对象包装。为了更细粒度的管理，Netty 将 chunk进一步拆分为 page，默认每个 chunk 包含 2048 个 page，pageSize = 8KB。</p>
<p>在同一个chunk中，Netty 将 page 按照不同粒度进行多层分组管理</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%841.jpg" class="" title="page分组">

<ul>
<li>第1层，分组大小size = 1*pageSize，一共有2048个组</li>
<li>第2层，分组大小size = 2*pageSize，一共有1024个组</li>
<li>第3层，分组大小size = 4*pageSize，一共有512个组</li>
<li>…</li>
<li>第12层，分组大小size = 2^(12-1) * pageSize = 2048 * pageSize，一共有2048个组</li>
</ul>
<p>当请求分配内存时，将请求分配的内存数向上取值到最接近的分组大小，在该分组大小的相应层级中从左至右寻找空闲分组。例如请求分配内存对象为<code>1.5 * pageSize</code>，向上取值到分组大小 <code>2 * pageSize</code>，在该层分组中找到完全空闲的一组内存进行分配，如下图：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%842.jpg" class="" title="page分组">

<p>当分组大小 <code>2 *pageSize</code> 的内存分配出去后，为了方便下次内存分配，分组被标记为全部已使用（图中红色标记），向上更粗粒度的内存分组被标记为部分已使用（图中黄色标记）。</p>
<h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p><strong>Netty 基于平衡二叉树实现不同粒度的多层分组管理</strong></p>
<p>为了方便快速查找 chunk 中能容纳请求内存的位置，算法构建一个基于byte数组（memoryMap）存储的完全平衡树，该平衡树的多个层级深度，就是前面介绍的按照不同粒度对 chunk进行多层分组：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk.jpg" class="" title="poolChunk">

<p>树的深度depth从0开始计算，各层节点数，每个节点对应的内存大小如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">depth &#x3D; 0， 1 node，nodeSize &#x3D; chunkSize</span><br><span class="line">depth &#x3D; 1， 2 nodes，nodeSize &#x3D; chunkSize&#x2F;2</span><br><span class="line">...</span><br><span class="line">depth &#x3D; d， 2^d nodes， nodeSize &#x3D; chunkSize&#x2F;(2^d)</span><br><span class="line">...</span><br><span class="line">depth &#x3D; maxOrder， 2^maxOrder nodes， nodeSize &#x3D; chunkSize&#x2F;2^&#123;maxOrder&#125; &#x3D; pageSize</span><br></pre></td></tr></table></figure>

<p>具有n个结点的完全二叉树的深度为：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6.png" class="" title="二叉树深度">

<p>树的最大深度为 maxOrder = 11（注意 depth从0开始），通过这棵树，算法在chunk中的查找就可以转换为：</p>
<p><strong>当申请分配大小为 chunkSize/2^k 的内存，在平衡树高度为k的层级中，从左到右搜索第一个空闲节点。</strong></p>
<p>数组的使用域从index = 1开始，将平衡树按照层次顺序依次存储在数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">depth &#x3D; n 的第1个节点保存在 memoryMap[2^n] 中</span><br><span class="line">depth &#x3D; n 的第2个节点保存在 memoryMap[2^n+1] 中</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下图代表已分配 chunkSize/2：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk2.jpg" class="" title="poolChunk">

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="正常对象"><a href="#正常对象" class="headerlink" title="正常对象"></a>正常对象</h4><p>当申请分配大小在 <strong>(pageSize / 2,  chunkSize]</strong> 区间的内存时，会首先将请求分配的内存大小归一化（向上取整为page的整数倍）。例如 8000byte 归一化为8192byte（即8KB），8193byte 归一化为16384byte（16KB）。</p>
<p>当分配已归一化处理后大小为 <code>chunkSize/2^d</code> 的内存，即需要在 depth = d 的层级中找到第一块空闲内存，将其修改为已使用后，再更新其祖先节点为部分已使用。</p>
<h4 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h4><p>当申请分配内存，会首先将请求分配的内存大小归一化：</p>
<ul>
<li>当请求对象的大小为 <strong>(0,  496]</strong> ，归一化计算后方式是向上取最近的16的倍数。例如 15byte 归一化为16byte，490byte 归一化为496byte。</li>
<li>当请求对象的大小为  <strong>(496， pageSize / 2]</strong> ，归一化的计算方式是向上取整为最接近 512，1024，2048，4096的值。例如  520byte 归一化为 1024byte。</li>
</ul>
<p>给这些小对象直接分配一个page会造成浪费，在page中进行平衡树的标记又额外消耗更多空间，因此Netty的实现是：先 PoolChunk 中申请空闲page，同一个 page 分为相同大小规格的小内存进行存储。通过 long[] 类型的bitmap 来记录内存是否已使用。</p>
<h4 id="巨型对象"><a href="#巨型对象" class="headerlink" title="巨型对象"></a>巨型对象</h4><p>当申请内存大于 chunkSize 时，Netty采用的是非池化管理策略。</p>
<h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><h4 id="PoolChunk"><a href="#PoolChunk" class="headerlink" title="PoolChunk"></a>PoolChunk</h4><p>为了解决单个PoolChunk容量有限的问题，Netty将多个PoolChunk组成链表一起管理。</p>
<p>将所有PoolChunk组成一个链表的话，进行遍历查找管理效率较低，因此 Netty 设计了PoolArena实现对多个PoolChunkList管理。</p>
<p>Arena 内部持有6个PoolChunkList，各个PoolChunkList持有的PoolChunk的使用率区间不同：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/PoolChunkList.jpg" class="" title="PoolChunkList">

<p>PoolChunkList的额定使用率区间存在交叉，这样设计是因为如果基于一个临界值的话，当PoolChunk内存申请释放后的内存使用率在临界值上下徘徊的话，会导致在PoolChunkList链表前后来回移动：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/PoolChunkList%E9%A2%9D%E5%AE%9A%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E5%8C%BA%E9%97%B4.jpg" class="" title="PoolChunkList额定内存使用率区间">

<h4 id="PoolSubpage"><a href="#PoolSubpage" class="headerlink" title="PoolSubpage"></a>PoolSubpage</h4><p>PoolArena内部持有2个PoolSubpage数组，分别存储 tiny 和 small 规格类型的PoolSubpage。相同规格大小的 PoolSubpage组成链表，不同规格的PoolSubpage链表的 head 节点则分别保存在 tinySubpagePools 或者 smallSubpagePools数组中：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/SubPage%E7%BB%93%E6%9E%84.jpg" class="" title="SubPage结构">

<p>PoolSubpage链表中存储的 PoolSubpage都是只分配部分内存，当内存全部分配完或者内存全部释放完的 PoolSubpage会移出链表，减少不必要的链表节点；当PoolSubpage内存全部分配完后再释放部分内存，会重新将加入链表。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>PoolArena内存池弹性伸缩可用下图总结：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E5%86%85%E5%AD%98%E6%B1%A0%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E5%B0%8F%E7%BB%93.jpg" class="" title="内存池弹性伸缩小结">

<h3 id="并发设计"><a href="#并发设计" class="headerlink" title="并发设计"></a>并发设计</h3><p>为了减少线程间的竞争，Netty会提前创建多个 PoolArena（默认生成数量 = 2 * CPU核心数），当线程首次请求池化内存分配，会找被最少线程持有的 Arena，并保存线程局部变量 PoolThreadCache 中，实现线程与 Arena 的关联绑定。（线程局部变量使用的是 FastThreadLocal，性能高于 ThreadLocal）</p>
<p>Netty 还设计了缓存机制提升并发性能，当请求对象内存释放，PoolArena 并没有马上释放，而是先尝试将该内存关联的 PoolChunk 和 它的偏移位置等信息存入 PoolThreadLocalCache 中的固定大小缓存队列中（如果缓存队列满了则马上释放内存)；当请求内存分配，PoolArena 会优先访问 PoolThreadLocalCache 的缓存队列中是否有缓存内存可用，如果有，则直接分配，提高分配效率。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><strong>Netty 版本 4.1.52.Final</strong></p>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>Java NIO提供了 <strong>ByteBuffer</strong> 作为它的字节容器，但是这个类使用起来过于复杂和繁琐。Netty用 <strong>ByteBuf</strong> 替代了ByteBuffer，实现了<strong>自动扩容</strong>，也更易使用。</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>ByteBuf 源码中有段注释画出了结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* &lt;pre&gt;</span><br><span class="line">*      +-------------------+------------------+------------------+</span><br><span class="line">*      | discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">*      |                   |     (CONTENT)    |                  |</span><br><span class="line">*      +-------------------+------------------+------------------+</span><br><span class="line">*      |                   |                  |                  |</span><br><span class="line">*      <span class="number">0</span>      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line">* &lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>readerIndex：记录读指针的开始位置</li>
<li>writerIndex：记录读指针的开始位置</li>
<li>capacity：缓冲区的总长度</li>
</ul>
<p>除了这三个指针，ByteBuf里面其实还有一个指针 maxCapacity，它相当于ByteBuf扩容的最大阈值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the maximum allowed capacity of this buffer. This value provides an upper</span></span><br><span class="line"><span class="comment"> * bound on &#123;<span class="doctag">@link</span> #capacity()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">maxCapacity</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些指针将 ByteBuf 分为以下几个区域：</p>
<ul>
<li>discardable bytes：从 0 到 readerIndex 为 discardable bytes，表示是无效的</li>
<li>readable bytes：从 readerIndex 到 writerIndex 为 readable bytes，表示可读数据区</li>
<li>writable bytes：从 writerIndex 到 capacity 为 writable bytes，表示这段区间空闲，可以往里面写数据</li>
</ul>
<h4 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h4><p>ByteBuf 有众多子类，大致可以从以下维度来进行分类：</p>
<ul>
<li><strong>Pooled和UnPooled</strong>：<ul>
<li><strong>Pooled</strong>：每次申请内存都是从预先分配好的内存空间中提取一段连续内存</li>
<li><strong>Unpooled</strong>：每次申请内存都是新的一次申请</li>
</ul>
</li>
<li><strong>unsafe和非unsafe</strong>：<ul>
<li><strong>unsafe</strong>：调用 native 方法底层直接操作内存</li>
<li><strong>非unsafe</strong>：通过 JDK 的 API 间接操作内存</li>
</ul>
</li>
<li><strong>Heap和Direct</strong>：<ul>
<li><strong>Heap</strong>：指 JVM的堆内存</li>
<li><strong>Direct</strong>：堆外内存，直接调用 JDK 的底层 API 进行物理内存分配，不在 JVM的堆内存中，需要手动释放</li>
</ul>
</li>
</ul>
<p>ByteBuf 最基本的读写 API 操作在 <code>AbstractByteBuf</code> 中已经实现了，其众多子类采用不同的策略来分配内存空间。下面是对重要的几个子类的总结：</p>
<ul>
<li><strong>PooledHeapByteBuf</strong>：池化的堆内缓冲区</li>
<li><strong>PooledUnsafeHeapByteBuf</strong>：池化的Unsafe堆内缓冲区</li>
<li><strong>PooledDirectByteBuf</strong>：池化的堆外缓冲区</li>
<li><strong>PooledUnsafeDirectByteBuf</strong>：池化的Unsafe堆外缓冲区</li>
<li><strong>UnpooledHeapByteBuf</strong>：非池化的堆内缓冲区</li>
<li><strong>UnpooledUnsafeHeapByteBuf</strong>：非池化的Unsafe堆内缓冲区</li>
<li><strong>UnpooledDirectByteBuf</strong>：非池化的堆外缓冲区</li>
<li><strong>UnpooledUnsafeDirectByteBuf</strong>：非池化的Unsafe堆外缓冲区</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>下面是 AbstractByteBuf 的 部分 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取指定字节长度的数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查ByteBuf是否可读取length字节的数据</span></span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Unpooled.EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf buf = alloc().buffer(length, maxCapacity);</span><br><span class="line">    buf.writeBytes(<span class="keyword">this</span>, readerIndex, length);</span><br><span class="line">    <span class="comment">// 移动readerIndex</span></span><br><span class="line">    readerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Throws an &#123;<span class="doctag">@link</span> IndexOutOfBoundsException&#125; if the current</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #readableBytes() readable bytes&#125; of this buffer is less</span></span><br><span class="line"><span class="comment"> * than the specified value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkReadableBytes</span><span class="params">(<span class="keyword">int</span> minimumReadableBytes)</span> </span>&#123;</span><br><span class="line">    checkReadableBytes0(checkPositiveOrZero(minimumReadableBytes, <span class="string">"minimumReadableBytes"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReadableBytes0</span><span class="params">(<span class="keyword">int</span> minimumReadableBytes)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();<span class="comment">// 检查是否可以访问</span></span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; readerIndex &gt; writerIndex - minimumReadableBytes) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s"</span>,</span><br><span class="line">                readerIndex, minimumReadableBytes, writerIndex, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Should be called by every method that tries to access the buffers content to check</span></span><br><span class="line"><span class="comment"> * if the buffer was released before.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkAccessible &amp;&amp; !isAccessible()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used internally by &#123;<span class="doctag">@link</span> AbstractByteBuf#ensureAccessible()&#125; to try to guard</span></span><br><span class="line"><span class="comment"> * against using the buffer after it was released (best-effort).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> refCnt() != <span class="number">0</span>; <span class="comment">// 引用计数不等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src数组中从下标 srcIndex 到 srcIndex + length - 1 的数据写入ByteBuf中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保可以写入 length 个字节的数据</span></span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    ensureWritable0(checkPositiveOrZero(minWritableBytes, <span class="string">"minWritableBytes"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes;</span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        <span class="comment">// 如果写入之后的 writerIndex 小于容量 capacity</span></span><br><span class="line">        ensureAccessible();<span class="comment">// 检查是否可以访问</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        ensureAccessible(); <span class="comment">// 如果写入之后的 writerIndex 超出最大容量 maxCapacity</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明容量不够，需要扩容，新容量会是2的n次方</span></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes(); <span class="comment">// 当前可写的容量</span></span><br><span class="line">    <span class="comment">// 这里 fastWritable &gt;= minWritableBytes 不会成立</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity); <span class="comment">// 调整容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractByteBufAllocator的calculateNewCapacity()方法</span></span><br><span class="line"><span class="comment">// 总感觉这里扩容实现的不是特别好，可能是我在第0层吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    checkPositiveOrZero(minNewCapacity, <span class="string">"minNewCapacity"</span>);</span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minNewCapacity: %d (expected: not greater than maxCapacity(%d)"</span>,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h3><p>Netty 中内存分配有一个顶层的抽象就是 ByteBufAllocator，负责分配所有 ByteBuf 类型的内存。</p>
<p>ByteBufAllocator 有如下几个重要的方法：</p>
<ul>
<li>buffer()：分配一块内存，自动判断是分配堆外内存还是堆内存</li>
<li>ioBuffer()：尽可能分配一块堆外内存，如果系统不支持则分配堆内存</li>
<li>heapBuffer()：分配一块堆内存</li>
<li>directBuffer()：分配一块堆外内存</li>
<li>compositeBuffer()：组合分配，把多个ByteBuf组合到一起变成一个整体</li>
</ul>


<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p><code>AbstractByteBufAllocator</code> 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instance use heap buffers by default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>); <span class="comment">// 默认使用堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">    directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe();</span><br><span class="line">    emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个内存，并指定初始容量和最大容量（自动判断是分配堆外内存还是堆内存）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个堆外内存，并指定初始容量和最大容量</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象方法，由子类实现</span></span><br><span class="line"><span class="comment"> * Create a direct &#123;<span class="doctag">@link</span> ByteBuf&#125; with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个堆内存，并指定初始容量和最大容量</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newHeapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象方法，由子类实现</span></span><br><span class="line"><span class="comment"> * Create a heap &#123;<span class="doctag">@link</span> ByteBuf&#125; with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到这里知道了 directBuffer、heapBuffer 和 Pooled、Unpooled的分配规则，那么Unsafe和非Unsafe是如何判别的呢？其实是Netty自动判别的。如果操作系统底层支持 Unsafe 那就采用 Unsafe 读写，否则采用非 Unsafe 读写。</p>
<p>我们可以从UnpooledByteBufAllocator的源码中验证</p>
<h3 id="非池化内存分配"><a href="#非池化内存分配" class="headerlink" title="非池化内存分配"></a>非池化内存分配</h3><p><code>UnpooledByteBufAllocator</code> 实现了非池化内存分配策略</p>
<h4 id="堆内存的分配"><a href="#堆内存的分配" class="headerlink" title="堆内存的分配"></a>堆内存的分配</h4><p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.hasUnsafe() ?</span><br><span class="line">        <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">    <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlatformDependent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE_UNAVAILABILITY_CAUSE == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Throwable <span class="title">unsafeUnavailabilityCause0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAndroid()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: unavailable (Android)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"sun.misc.Unsafe: unavailable (Android)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isIkvmDotNet()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: unavailable (IKVM.NET)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"sun.misc.Unsafe: unavailable (IKVM.NET)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasUnsafe = PlatformDependent0.hasUnsafe();</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: &#123;&#125;"</span>, hasUnsafe ? <span class="string">"available"</span> : <span class="string">"unavailable"</span>);</span><br><span class="line">            <span class="keyword">return</span> hasUnsafe ? <span class="keyword">null</span> : PlatformDependent0.getUnsafeUnavailabilityCause();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Could not determine if Unsafe is available"</span>, t);</span><br><span class="line">            <span class="comment">// Probably failed to initialize PlatformDependent0.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Could not determine if Unsafe is available"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>PlatformDependent.hasUnsafe()</code> 方法来判断操作系统是否支持 Unsafe</p>
<ul>
<li>如果支持Unsafe则创建 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code> </li>
<li>如果不支持Unsafe则创建 <code>InstrumentedUnpooledHeapByteBuf</code> </li>
</ul>
<h5 id="InstrumentedUnpooledUnsafeHeapByteBuf"><a href="#InstrumentedUnpooledUnsafeHeapByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeHeapByteBuf"></a>InstrumentedUnpooledUnsafeHeapByteBuf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">super</span>.allocateArray(initialCapacity);</span><br><span class="line">        <span class="comment">// 记录新建的堆空间大小</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementHeap(bytes.length);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledHeapByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledUnsafeHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="comment">// 其实就是通过 unsafe 创建byte[]</span></span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.allocateUninitializedArray(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line">    <span class="keyword">byte</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        <span class="comment">// 调用的是 InstrumentedUnpooledUnsafeHeapByteBuf 的 allocateArray 方法</span></span><br><span class="line">        setArray(allocateArray(initialCapacity));</span><br><span class="line">        setIndex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>&#123;</span><br><span class="line">        array = initialArray;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkBounds) &#123; <span class="comment">// 确保 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity</span></span><br><span class="line">            checkIndexBounds(readerIndex, writerIndex, capacity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用AbstractByteBuf的方法设置 readerIndex 和 writerIndex</span></span><br><span class="line">        setIndex0(readerIndex, writerIndex); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InstrumentedUnpooledHeapByteBuf"><a href="#InstrumentedUnpooledHeapByteBuf" class="headerlink" title="InstrumentedUnpooledHeapByteBuf"></a>InstrumentedUnpooledHeapByteBuf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledHeapByteBuf</span> </span>&#123;</span><br><span class="line">  	InstrumentedUnpooledHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">     	<span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code> 和 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code>最终调用的都是 <code>UnpooledHeapByteBuf</code> 的构造方法，但前者是通过 <code>unsafe</code> 的方式创建字节数组，而后者是通过 <code>new byte[Size]</code> 的方式创建数组。其实不仅是创建数组，读写操作也是这样，前者是通过  <code>unsafe</code> 操作数据，后者则是直接通过数组下标操作数组。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p><strong>分配内存时，根据操作系统是否支持 Unsafe：</strong></p>
<ul>
<li><strong>如果支持 unsafe：则通过 unsafe 的方式创建字节数组（读写数组也是通过 unsafe的方式）</strong></li>
<li><strong>如果不支持 unsafe：则使用 <code>new byte[Size]</code> 关键字创建字节数组（读写数组通过索引操作）</strong></li>
</ul>
<p><strong>释放内存则依赖 JVM 自动释放</strong></p>
<h4 id="堆外内存的分配"><a href="#堆外内存的分配" class="headerlink" title="堆外内存的分配"></a>堆外内存的分配</h4><p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">                &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>PlatformDependent.hasUnsafe()</code> 方法来判断操作系统是否支持 Unsafe</p>
<ul>
<li>如果支持 Unsafe，判断 noCleaner<ul>
<li>noCleaner = true，则创建 <code>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</code> </li>
<li>noCleaner = false，则创建 <code>InstrumentedUnpooledUnsafeDirectByteBuf</code> </li>
</ul>
</li>
<li>如果不支持 Unsafe则创建 <code>InstrumentedUnpooledDirectByteBuf</code> </li>
</ul>
<h5 id="InstrumentedUnpooledDirectByteBuf"><a href="#InstrumentedUnpooledDirectByteBuf" class="headerlink" title="InstrumentedUnpooledDirectByteBuf"></a>InstrumentedUnpooledDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终就是 new DirectByteBuffer(capacity);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 DirectByteBuffer本身的cleaner去释放内存</span></span><br><span class="line">        <span class="comment">// DirectByteBuffer的cleaner 本质上也是使用 unsafe.freeMemory(address);</span></span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer; <span class="comment">// accessed by UnpooledUnsafeNoCleanerDirectByteBuf.reallocateDirect()</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">        ObjectUtil.checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        checkPositiveOrZero(initialCapacity, <span class="string">"initialCapacity"</span>);</span><br><span class="line">        checkPositiveOrZero(maxCapacity, <span class="string">"maxCapacity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">         <span class="comment">// 调用的是 InstrumentedUnpooledDirectByteBuf 的 allocateArray 方法</span></span><br><span class="line">        setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setByteBuffer</span><span class="params">(ByteBuffer buffer, <span class="keyword">boolean</span> tryFree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryFree) &#123;</span><br><span class="line">            ByteBuffer oldBuffer = <span class="keyword">this</span>.buffer;</span><br><span class="line">            <span class="keyword">if</span> (oldBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (doNotFree) &#123;</span><br><span class="line">                    doNotFree = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeDirect(oldBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer; <span class="comment">// buffer赋值</span></span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        capacity = buffer.remaining();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InstrumentedUnpooledUnsafeDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeDirectByteBuf"></a>InstrumentedUnpooledUnsafeDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终就是 new DirectByteBuffer(capacity);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 DirectByteBuffer本身的cleaner去释放内存</span></span><br><span class="line">        <span class="comment">// DirectByteBuffer的cleaner 本质上也是使用 unsafe.freeMemory(address);</span></span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledUnsafeDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">        ObjectUtil.checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        checkPositiveOrZero(initialCapacity, <span class="string">"initialCapacity"</span>);</span><br><span class="line">        checkPositiveOrZero(maxCapacity, <span class="string">"maxCapacity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">        <span class="comment">// 调用的是 InstrumentedUnpooledUnsafeDirectByteBuf 的 allocateDirect 方法</span></span><br><span class="line">        setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发现 <code>InstrumentedUnpooledDirectByteBuf</code> 和 <code>InstrumentedUnpooledUnsafeDirectByteBuf</code>都是通过<code>new DirectByteBuffer(capacity)</code> 的方式创建堆外内存，并且释放内存也是通过 <code>DirectByteBuffer</code> 的 cleaner 释放，那它们的区别是什么呢？<strong>其实就是读写数据的方式不同</strong>。</p>
<p><code>InstrumentedUnpooledDirectByteBuf</code> 的父类 <code>UnpooledDirectByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.get(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((unsafe.getByte(ix(checkIndex(i)))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UnpooledDirectByteBuf</code> 通过 <code>DirectByteBuffer</code> 本身的方法来操作数据，不过 <code>DirectByteBuffer</code> 本身也是使用 unsafe 来操作数据的。</p>
<p> <code>InstrumentedUnpooledUnsafeDirectByteBuf</code>的父类 <code>UnpooledUnsafeDirectByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkIndex(index);</span><br><span class="line">    <span class="keyword">return</span> _getByte(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终就是 UNSAFE.getByte(address);</span></span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.getByte(addr(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>UnpooledUnsafeDirectByteBuf</code> 是直接使用的 unsafe 来操作数据的。</p>
<h5 id="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"></a>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射初始化一个 cleaner=null 的 DirectByteBuffer </span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ByteBuffer <span class="title">reallocateDirect</span><span class="params">(ByteBuffer oldBuffer, <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = oldBuffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 UNSAFE.freeMemory(address);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.reallocateDirect(oldBuffer, initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity() - capacity);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// UnpooledUnsafeNoCleanerDirectByteBuf 继承了 UnpooledUnsafeDirectByteBuf</span></span><br><span class="line">    <span class="comment">// 没有重写读写操作，都是使用的 UnpooledUnsafeDirectByteBuf 中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p><strong>分配内存时</strong></p>
<ul>
<li><strong>如果操作系统不支持 unsafe 或 noCleaner = false，则通过 <code>new DirectByteBuffer(capacity)</code> 的方式创建带有 cleaner 的 <code>DirectByteBuffer</code> 。</strong></li>
<li><strong>不过操作系统支持 unsafe 并且 noCleaner = true，则通过反射创建 cleaner 为空的 <code>DirectByteBuffer</code> 。</strong></li>
</ul>
<p><strong>释放内存时</strong></p>
<ul>
<li><strong>如果创建的 <code>DirectByteBuffer</code> 带有 cleaner，使用 DirectByteBuffer本身的cleaner释放</strong></li>
<li><strong>如果创建的 <code>DirectByteBuffer</code> 没有 cleaner，则使用 unsafe 释放内存</strong></li>
</ul>
<h3 id="池化内存的分配"><a href="#池化内存的分配" class="headerlink" title="池化内存的分配"></a>池化内存的分配</h3><p><code>PooledByteBufAllocator</code> 实现了池化内存分配策略</p>
<p>由于高版本 Netty 池化内存分配策略有所变更，这部分源码参考 <strong>Netty 版本 4.1.42.Final</strong></p>
<h4 id="PooledByteBufAllocator"><a href="#PooledByteBufAllocator" class="headerlink" title="PooledByteBufAllocator"></a>PooledByteBufAllocator</h4><p>构造方法的相关参数如下：</p>
<ul>
<li>preferDirect：优先分配直接内存，默认值是 false。</li>
<li>nHeapArena：HeapArena的数量，默认值是 CPU核数 * 2。</li>
<li>nDirectArena：DirectArena的数量，默认值是 CPU核数 * 2。</li>
<li>pageSize：page 的个数，默认值是 8192。</li>
<li>maxOrder：二叉树的最大深度，默认值是 11。</li>
<li>tinyCacheSize：tiny 类型的缓存列表容量，默认值是512。</li>
<li>smallCacheSize：small 类型的缓存列表容量，默认值是 256。</li>
<li>normalCacheSize：normal 类型的缓存列表容量，默认值是 64。</li>
<li>useCacheForAllThreads：默认值是 true。</li>
<li>directMemoryCacheAlignment：默认值是 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉了一些非核心的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> normalCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> useCacheForAllThreads, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> directMemoryCacheAlignment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    threadCache = <span class="keyword">new</span> PoolThreadLocalCache(useCacheForAllThreads);</span><br><span class="line">    <span class="keyword">this</span>.tinyCacheSize = tinyCacheSize;  <span class="comment">// 默认是512</span></span><br><span class="line">    <span class="keyword">this</span>.smallCacheSize = smallCacheSize; <span class="comment">// 默认是256</span></span><br><span class="line">    <span class="keyword">this</span>.normalCacheSize = normalCacheSize; <span class="comment">// 默认是64</span></span><br><span class="line">    <span class="comment">// 校验并计算chunkSize的大小，默认是 8192 * (2 ^ 11) = 1677216 byte = 16MB</span></span><br><span class="line">    chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);</span><br><span class="line">    <span class="comment">// 校验并计算pageShifts的大小，默认是 13</span></span><br><span class="line">    <span class="keyword">int</span> pageShifts = validateAndCalculatePageShifts(pageSize);</span><br><span class="line">    <span class="comment">// 初始化HeapArenas</span></span><br><span class="line">    <span class="keyword">if</span> (nHeapArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于 new PoolArena[nHeapArena]</span></span><br><span class="line">        heapArenas = newArenaArray(nHeapArena);</span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapArenas.length; i ++) &#123;</span><br><span class="line">            PoolArena.HeapArena arena = <span class="keyword">new</span> PoolArena.HeapArena(<span class="keyword">this</span>, pageSize, maxOrder, 						pageShifts, chunkSize,directMemoryCacheAlignment);</span><br><span class="line">            heapArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        &#125;</span><br><span class="line">        heapArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heapArenas = <span class="keyword">null</span>;</span><br><span class="line">        heapArenaMetrics = Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化DirectArenas</span></span><br><span class="line">    <span class="keyword">if</span> (nDirectArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于 new PoolArena[nDirectArena]</span></span><br><span class="line">        directArenas = newArenaArray(nDirectArena);</span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directArenas.length; i ++) &#123;</span><br><span class="line">            PoolArena.DirectArena arena = <span class="keyword">new</span> PoolArena.DirectArena(</span><br><span class="line">                <span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">            directArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        &#125;</span><br><span class="line">        directArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        directArenas = <span class="keyword">null</span>;</span><br><span class="line">        directArenaMetrics = Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    metric = <span class="keyword">new</span> PooledByteBufAllocatorMetric(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapArena 和 DirectArena 分别为 CPU核数 * 2，<strong>目的就是保证Netty中的每一个任务线程都可以有一个独享的Arena，保证在每个线程分配内存的时候不用加锁</strong>。</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/EventLoop%E5%92%8CArena.jpg" class="" title="EventLoop和Arena">

<p><code>PooledByteBufAllocator</code> 实现分配内存的两个方法：newDirectBuffer() 方法和newHeapBuffer() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get(); <span class="comment">// PoolThreadLocalCache threadCache;</span></span><br><span class="line">    PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = cache.heapArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// PoolArena的allocate方法</span></span><br><span class="line">        buf = heapArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">            <span class="keyword">new</span> UnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> UnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get(); <span class="comment">// PoolThreadLocalCache threadCache;</span></span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">            UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这两个方法大体结构是一样的，以 newDirectBuffer 为例：</p>
<ol>
<li>通过 threadCache.get() 方法获取一个类型为 PoolThreadCache 的 cache 对象</li>
<li>通过 cache 获得 directArena 对象</li>
<li>调用 directArena.allocate() 方法分配 ByteBuf</li>
</ol>
<h4 id="PoolThreadLocalCache"><a href="#PoolThreadLocalCache" class="headerlink" title="PoolThreadLocalCache"></a>PoolThreadLocalCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadLocalCache</span> <span class="keyword">extends</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">PoolThreadCache</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCacheForAllThreads;</span><br><span class="line"></span><br><span class="line">    PoolThreadLocalCache(<span class="keyword">boolean</span> useCacheForAllThreads) &#123;</span><br><span class="line">        <span class="keyword">this</span>.useCacheForAllThreads = useCacheForAllThreads; <span class="comment">// 默认是true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">        <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (useCacheForAllThreads || current <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">final</span> PoolThreadCache cache = <span class="keyword">new</span> PoolThreadCache(</span><br><span class="line">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> EventExecutor executor = ThreadExecutorMap.currentExecutor();</span><br><span class="line">                <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,</span><br><span class="line">                                                 DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No caching so just use 0 as sizes.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(heapArena, directArena, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 arenas 中获取使用率最少的一个Areana</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">PoolArena&lt;T&gt; <span class="title">leastUsedArena</span><span class="params">(PoolArena&lt;T&gt;[] arenas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arenas == <span class="keyword">null</span> || arenas.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PoolArena&lt;T&gt; minArena = arenas[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arenas.length; i++) &#123;</span><br><span class="line">        PoolArena&lt;T&gt; arena = arenas[i];</span><br><span class="line">        <span class="comment">// final AtomicInteger numThreadCaches = new AtomicInteger();</span></span><br><span class="line">        <span class="keyword">if</span> (arena.numThreadCaches.get() &lt; minArena.numThreadCaches.get()) &#123;</span><br><span class="line">            minArena = arena;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minArena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 leastUsedArena() 方法分别获得使用率最少的 HeapArena 和 DirectArena 对象</li>
<li>然后把 HeapArena 和 DirectArena 对象作为参数传递到 PoolThreadCache 的构造器中</li>
</ol>
<p>PoolThreadCache除了可以在 HeapArena 和 DirectArena 上进行内存分配，还可以在它底层维护的 ByteBuf 缓存列表进行分配。</p>
<p>举个例子：我们通过 PooledByteBufAllocator 创建了一个1024字节的ByteBuf，当用完释放后，可能在其他地方会继续分配1024字节的ByteBuf。这时，其实不需要在 Arena 上进行内存分配，而是直接通过 PoolThreadCache中维护的 ByteBuf 的缓存列表直接拿过来返回。</p>
<p>PooledByteBufAllocator 维护着三种规格大小的缓存列表，分别是：tiny，small，normal，其容量分别为 512，256，64。</p>
<p>通过这种方式，Netty 预创建了固定规格的内存池，大大提高了内存分配的性能。</p>
<h4 id="DirectArena内存分配流程"><a href="#DirectArena内存分配流程" class="headerlink" title="DirectArena内存分配流程"></a>DirectArena内存分配流程</h4><p>HeapArena 和 DirectArena 分配内存的基本流程有三个步骤。</p>
<ol>
<li><strong>从对象池里获得 PooledByteBuf 进行复用</strong></li>
<li><strong>从缓存中进行内存分配</strong></li>
<li><strong>从缓存中分配失败，则从内存堆里进行内存分配</strong></li>
</ol>
<h5 id="对象池获取-ByteBuf"><a href="#对象池获取-ByteBuf" class="headerlink" title="对象池获取 ByteBuf"></a>对象池获取 ByteBuf</h5><p>以 DirectBuffer 为例，首先来看从对象池里获得 PooledByteBuf 进行复用的情况。</p>
<p>PooledByteBufAllocator 的 newDirectBuffer() 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">            UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PoolArena 的 allocate方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectArena 的 newByteBuf方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123; <span class="comment">// 判断是否支持Unsafe</span></span><br><span class="line">        <span class="comment">// 创建的是 PooledUnsafeDirectByteBuf</span></span><br><span class="line">        <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建的是 PooledDirectByteBuf</span></span><br><span class="line">        <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是否支持Unsafe：</p>
<ul>
<li>支持 Unsafe 创建的是 PooledUnsafeDirectByteBuf，它通过Unsafe方法操作数组。</li>
<li>不支持 Unsafe 创建的是 PooledDirectByteBuf，它通过数组索引操作数组。</li>
</ul>
<p>默认情况下一般是支持Unsafe的，PooledUnsafeDirectByteBuf 的 newInstance方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PooledUnsafeDirectByteBuf的RECYCLER属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;PooledUnsafeDirectByteBuf&gt; RECYCLER = ObjectPool.newPool(</span><br><span class="line">    <span class="keyword">new</span> ObjectCreator&lt;PooledUnsafeDirectByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PooledUnsafeDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledUnsafeDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当Recycler里面没有可用的buf时就会创建一个新的buf</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PooledUnsafeDirectByteBuf(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// PooledUnsafeDirectByteBuf的newInstance方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.reuse(maxCapacity); <span class="comment">// 让所有的参数重新归为初始状态</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PooledByteBuf的reuse方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reuse</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    maxCapacity(maxCapacity);</span><br><span class="line">    resetRefCnt();</span><br><span class="line">    setIndex0(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    discardMarks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <strong>RECYCLER</strong>（内存回收站）对象的 get() 方法获得一个 ByteBuf。当回收站里面没有可用的buf时就会创建一个新的 ByteBuf。<strong>获得的 ByteBuf 可能是回收站里取出来的，所以复用前需要重置相关属性。</strong></p>
<h4 id="内存池的内存规格"><a href="#内存池的内存规格" class="headerlink" title="内存池的内存规格"></a>内存池的内存规格</h4><p>Netty 底层还有一个内存单位的封装，为了更高效地管理内存，避免内存浪费，把每一个区间的内存规格又做了细分。Netty 内存池中主要设置了四种规格大小的内存：</p>
<ul>
<li><strong>tiny</strong>：0～512Byte</li>
<li><strong>small</strong>：512Byte～8KB</li>
<li><strong>normal</strong>：8KB～16MB</li>
<li><strong>huge</strong>：16MB以上</li>
</ul>
<p>那么为什么以这几个节点来进行分段呢，其实这里面是有原因的：</p>
<ul>
<li>首先为什么以<strong>16M</strong>作为分界点，16M在 Netty 中就是一个<strong>Chunk</strong>，Netty 中所有的内存申请都是以 Chunk 为单位向系统申请的，后续的所有内存分配都是在这个 Chunk 里的操作。</li>
<li>然后为什么又以<strong>8k</strong>作为分界点的，8K在Netty中就是一个 <strong>Page</strong>，每个Chunk 中有 2^11 个 Page 这样就能更细粒度的分配内存。</li>
<li>最后在 0 到 8K 的内存区间中有一个 <strong>SubPage</strong> 的对象来进行精确的分配内存。</li>
</ul>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E5%86%85%E5%AD%98%E8%A7%84%E6%A0%BC%E5%A4%A7%E5%B0%8F.jpg" class="" title="内存规格大小">

<h4 id="缓存的分配"><a href="#缓存的分配" class="headerlink" title="缓存的分配"></a>缓存的分配</h4><h5 id="缓存的数据结构"><a href="#缓存的数据结构" class="headerlink" title="缓存的数据结构"></a>缓存的数据结构</h5><p>在Netty中缓存的数据结构是一个叫做 <strong>MemoryRegionCache</strong> 的类，其结构如下：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/MemoryRegionCache%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" class="" title="MemoryRegionCache结构图">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryRegionCache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Entry&lt;T&gt;&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SizeClass sizeClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> allocations;</span><br><span class="line"></span><br><span class="line">    MemoryRegionCache(<span class="keyword">int</span> size, SizeClass sizeClass) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = MathUtil.safeFindNextPositivePowerOfTwo(size);</span><br><span class="line">        queue = PlatformDependent.newFixedMpscQueue(<span class="keyword">this</span>.size);</span><br><span class="line">        <span class="keyword">this</span>.sizeClass = sizeClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle;</span><br><span class="line">    PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    ByteBuffer nioBuffer;</span><br><span class="line">    <span class="keyword">long</span> handle = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entry(Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        nioBuffer = <span class="keyword">null</span>;</span><br><span class="line">        handle = -<span class="number">1</span>;</span><br><span class="line">        recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> SizeClass &#123;</span><br><span class="line">    Tiny,</span><br><span class="line">    Small,</span><br><span class="line">    Normal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MemoryRegionCache</strong> 由三部分组成：</p>
<ul>
<li>queue：队列中每个节点都是一个 Entry 实体</li>
<li>sizeClass：对应Netty中的内存规格，分别是 tiny、small、normal（huge规格不用缓存分配）</li>
<li>size：队列的容量，可能是 512，256，64（对应tinyCacheSize，smallCacheSize，normalCacheSize）</li>
</ul>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/%E7%BC%93%E5%AD%98%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" class="" title="缓存数组的数据结构">

<ul>
<li>tiny：共32种规格，均是16的整数倍，0Byte、16Byte、32Byte、48Byte、……496Byte。</li>
<li>small：4种规格，512Byte、1KB、2KB、4KB。</li>
<li>normal：3种规格，8KB、16KB、32KB。</li>
</ul>
<p>PoolThreadCache中维护了六个缓存数组（HeapCaches省略）：</p>
<ul>
<li>tinySubPageDirectCaches：tiny 类型的缓存列表</li>
<li>smallSubPageDirectCaches：small 类型的缓存列表</li>
<li>normalDirectCaches：normal 类型的缓存数组</li>
</ul>
<p>代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena;</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hold the caches for the different size classes, which are tiny, small and normal.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] tinySubPageHeapCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] smallSubPageHeapCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] normalHeapCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PoolThreadCache 的构造方法中进行了初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉了一些非核心的代码</span></span><br><span class="line">PoolThreadCache(PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena, <span class="comment">// 使用率最少的HeapArena</span></span><br><span class="line">                PoolArena&lt;ByteBuffer&gt; directArena,<span class="comment">// 使用率最少的DirectArena</span></span><br><span class="line">                <span class="keyword">int</span> tinyCacheSize, <span class="comment">// 默认为512</span></span><br><span class="line">                <span class="keyword">int</span> smallCacheSize, <span class="comment">// 默认为216</span></span><br><span class="line">                <span class="keyword">int</span> normalCacheSize, <span class="comment">// 默认为64</span></span><br><span class="line">                <span class="keyword">int</span> maxCachedBufferCapacity, </span><br><span class="line">                <span class="keyword">int</span> freeSweepAllocationThreshold) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.freeSweepAllocationThreshold = freeSweepAllocationThreshold;</span><br><span class="line">    <span class="keyword">this</span>.heapArena = heapArena;</span><br><span class="line">    <span class="keyword">this</span>.directArena = directArena;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// PoolArena.numTinySubpagePools = 512 &gt;&gt;&gt; 4 = 32</span></span><br><span class="line">        tinySubPageDirectCaches = createSubPageCaches(</span><br><span class="line">            tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line">        <span class="comment">// directArena.numSmallSubpagePools = pageShifts - 9 = 13 - 9 = 4</span></span><br><span class="line">        smallSubPageDirectCaches = createSubPageCaches(</span><br><span class="line">            smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"></span><br><span class="line">        numShiftsNormalDirect = log2(directArena.pageSize);</span><br><span class="line">        normalDirectCaches = createNormalCaches(</span><br><span class="line">            normalCacheSize, maxCachedBufferCapacity, directArena);</span><br><span class="line"></span><br><span class="line">        directArena.numThreadCaches.getAndIncrement();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No directArea is configured so just null out all caches</span></span><br><span class="line">        tinySubPageDirectCaches = <span class="keyword">null</span>;</span><br><span class="line">        smallSubPageDirectCaches = <span class="keyword">null</span>;</span><br><span class="line">        normalDirectCaches = <span class="keyword">null</span>;</span><br><span class="line">        numShiftsNormalDirect = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create the caches for the heap allocations</span></span><br><span class="line">        tinySubPageHeapCaches = createSubPageCaches(</span><br><span class="line">            tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line">        smallSubPageHeapCaches = createSubPageCaches(</span><br><span class="line">            smallCacheSize, heapArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"></span><br><span class="line">        numShiftsNormalHeap = log2(heapArena.pageSize);</span><br><span class="line">        normalHeapCaches = createNormalCaches(</span><br><span class="line">            normalCacheSize, maxCachedBufferCapacity, heapArena);</span><br><span class="line"></span><br><span class="line">        heapArena.numThreadCaches.getAndIncrement();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No heapArea is configured so just null out all caches</span></span><br><span class="line">        tinySubPageHeapCaches = <span class="keyword">null</span>;</span><br><span class="line">        smallSubPageHeapCaches = <span class="keyword">null</span>;</span><br><span class="line">        normalHeapCaches = <span class="keyword">null</span>;</span><br><span class="line">        numShiftsNormalHeap = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only check if there are caches in use.</span></span><br><span class="line">    <span class="keyword">if</span> ((tinySubPageDirectCaches != <span class="keyword">null</span> || smallSubPageDirectCaches != <span class="keyword">null</span> || normalDirectCaches != <span class="keyword">null</span></span><br><span class="line">         || tinySubPageHeapCaches != <span class="keyword">null</span> || smallSubPageHeapCaches != <span class="keyword">null</span> || normalHeapCaches != <span class="keyword">null</span>)</span><br><span class="line">        &amp;&amp; freeSweepAllocationThreshold &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"freeSweepAllocationThreshold: "</span></span><br><span class="line">                                           + freeSweepAllocationThreshold + <span class="string">" (expected: &gt; 0)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 tiny 类型为例，具体分析一下SubPage的缓存结构，实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(</span><br><span class="line">    <span class="keyword">int</span> cacheSize, <span class="keyword">int</span> numCaches, SizeClass sizeClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; numCaches &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[numCaches];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> maybe use cacheSize / cache.length</span></span><br><span class="line">            cache[i] = <span class="keyword">new</span> SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是创建了一个缓存数组，这个缓存数组的长度是 numCaches。相当于：</p>
<ul>
<li>创建了 tinySubPageDirectCaches[32]，smallSubPageDirectCaches[4]，normalDirectCaches[3] 三个数组</li>
<li>tinySubPageDirectCaches 中的每个元素 SubPageMemoryRegionCache 中的队列queue容量为 512</li>
<li>smallSubPageDirectCaches 中的每个元素 SubPageMemoryRegionCache 中的队列queue容量为 256</li>
<li>normalDirectCaches 中的每个元素 MemoryRegionCache 中的队列queue容量为 64</li>
</ul>
<h5 id="缓存的分配流程"><a href="#缓存的分配流程" class="headerlink" title="缓存的分配流程"></a>缓存的分配流程</h5><p>在基本了解缓存数组的数据结构之后，继续剖析在缓存中分配内存的逻辑，回到 PoolArena 的 allocate() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 规格化，确保ByteBuf容量统一，向上取与MemoryRegionCache中的内存规格中最接近的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">    <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// 判断 normCapacity 是否小于 pageSize</span></span><br><span class="line">        <span class="keyword">int</span> tableIdx;</span><br><span class="line">        PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">        <span class="comment">// 判断是不是 tiny 类型 即：normCapacity &lt; 512</span></span><br><span class="line">        <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">        <span class="keyword">if</span> (tiny) &#123; <span class="comment">// tiny 类型</span></span><br><span class="line">            <span class="comment">// 缓存分配</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// 能够从缓存中分配</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取 tableIdx，即 tableIdx = normCapacity / (2 ^ 4)</span></span><br><span class="line">            tableIdx = tinyIdx(normCapacity);</span><br><span class="line">            <span class="comment">// subPage 数组</span></span><br><span class="line">            table = tinySubpagePools;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// small 类型</span></span><br><span class="line">            <span class="comment">// 缓存分配</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                 <span class="comment">// 能够从缓存中分配</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取 tableIdx，即 2 ^ tableIdx = normCapacity / (2 ^ 10)</span></span><br><span class="line">            tableIdx = smallIdx(normCapacity);</span><br><span class="line">            table = smallSubpagePools;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取对应的节点</span></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">            <span class="comment">// 默认情况下，head.next == head</span></span><br><span class="line">            <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity);</span><br><span class="line">                incTinySmallAllocation(tiny);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        incTinySmallAllocation(tiny);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">        <span class="comment">// 缓存分配</span></span><br><span class="line">        <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 分配不成功，进行实际的内存分配</span></span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// huge 则直接分配</span></span><br><span class="line">        allocateHuge(buf, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PoolThreadCache 缓存分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateTiny</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据normCapacity找到tiny类型缓存数组中的一个缓存对象</span></span><br><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">    <span class="comment">// 找到tiny类型缓存数组的下标, idx = normCapacity / (2 ^ 4)</span></span><br><span class="line">    <span class="comment">// 例如 normCapacity = 16，idx = 1; normCapacity = 32，idx = 2</span></span><br><span class="line">    <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">    <span class="keyword">if</span> (area.isDirect()) &#123; <span class="comment">// 是否堆外内存</span></span><br><span class="line">        <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MemoryRegionCache&lt;T&gt; <span class="title">cache</span><span class="params">(MemoryRegionCache&lt;T&gt;[] cache, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span> || idx &gt; cache.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(MemoryRegionCache&lt;?&gt; cache, </span></span></span><br><span class="line"><span class="function"><span class="params">                         PooledByteBuf buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// no cache found so just return false here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> allocated = cache.allocate(buf, reqCapacity);</span><br><span class="line">    <span class="keyword">if</span> (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</span><br><span class="line">        allocations = <span class="number">0</span>;</span><br><span class="line">        trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocated;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MemoryRegionCache的allocate方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MemoryRegionCache内部维护着一个队列queue</span></span><br><span class="line">    Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123; <span class="comment">// 为空则说明缓存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    initBuf(entry.chunk, entry.nioBuffer, entry.handle, buf, reqCapacity);</span><br><span class="line">    entry.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocations is not thread-safe which is fine as this is only called from the same thread all time.</span></span><br><span class="line">    ++ allocations;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弹出 Entry 之后，通过 initBuf() 方法初始化 ByteBuf，这里参数传入Entry的Chunk和Handle。</p>
<p>Entry类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle;</span><br><span class="line">    PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    ByteBuffer nioBuffer;</span><br><span class="line">    <span class="keyword">long</span> handle = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chunk：代表一块连续的内存</li>
<li>handle：相当于一个指针，可以唯一定位Chunk里的一块连续内存</li>
</ul>
<p>通过 Chunk 和 Handle 就可以定位 ByteBuf 中指定的一块连续内存，有关ByteBuf相关的读写操作，都会在这块内存中进行。</p>
<p>SubPageMemoryRegionCache 类的 initBuf(entry.chunk，entry.handle，buf，reqCapacity) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">long</span> handle, PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    chunk.initBufWithSubpage(buf, nioBuffer, handle, reqCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PoolChunk的initBufWithSubpage方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, ByteBuffer nioBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    initBufWithSubpage(buf, nioBuffer, handle, bitmapIdx(handle), reqCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitmapIdx</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (handle &gt;&gt;&gt; Integer.SIZE); <span class="comment">// Integer.SIZE 为32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PoolChunk的initBufWithSubpage方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">    <span class="comment">// private final PoolSubpage&lt;T&gt;[] subpages;</span></span><br><span class="line">    PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">    <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line">    <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"></span><br><span class="line">    buf.init(</span><br><span class="line">        <span class="keyword">this</span>, nioBuffer, handle,</span><br><span class="line">        runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize + offset,</span><br><span class="line">        reqCapacity, subpage.elemSize, arena.parent.threadCache());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, </span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    init0(chunk, nioBuffer, handle, offset, length, maxLength, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init0</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定bytebuf分配的内存块</span></span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">    <span class="comment">// 指定当前bytebuf连续内存指向的位置</span></span><br><span class="line">    memory = chunk.memory;</span><br><span class="line">    tmpNioBuf = nioBuffer;</span><br><span class="line">    allocator = chunk.arena.parent;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;<span class="comment">//相对memory中的偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将 PooledUnsafeDirectByteBuf 的各个属性进行了初始化。通过缓存分配 ByteBuf，只要通过一个chunk 和 handle 就可以确定一块内存。以上就是通过缓存分配ByteBuf对象的全过程。</p>
<p>初始化ByteBuf 之后调用 entry.recycle() 将Entry对象回收，因为Entry对象弹出之后没有再被引用，所以可能GC会将Entry对象回收。Netty为了将对象循环利用，将其放在对象回收站进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chunk = <span class="keyword">null</span>;</span><br><span class="line">    nioBuffer = <span class="keyword">null</span>;</span><br><span class="line">    handle = -<span class="number">1</span>;</span><br><span class="line">    recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chunk = null 和 handle = -1 表示当前Entry不指向任何一块内存。recyclerHandle.recycle(this) 将当前 Entry 回收。</p>
<p>以上就是命中缓存的流程。</p>
<h4 id="Page级别的内存分配"><a href="#Page级别的内存分配" class="headerlink" title="Page级别的内存分配"></a>Page级别的内存分配</h4><p>Netty 内存分配的单位是Chunk，一个 Chunk 的大小是16MB，每个 Chunk 都以双向链表的形式保存在一个ChunkList 中。多个 ChunkList 也是以双向链表的形式进行关联的，大概结构如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/ChunkList%E7%BB%93%E6%9E%84.jpg" class="" title="ChunkList结构">

<p>在 ChunkList 中，根据 Chunk 的内存使用率划分 ChunkList。这样在内存分配时，会根据百分比找到相应的ChunkList，在ChunkList 中选择一个 Chunk 进行内存分配。PoolArena 中 ChunkList 的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q050;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q025;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q000;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; qInit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q075;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q100;</span><br></pre></td></tr></table></figure>

<p>这里总共定义了6个 ChunkList，并在构造方法中将其初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line">q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line">qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"></span><br><span class="line">q100.prevList(q075);</span><br><span class="line">q075.prevList(q050);</span><br><span class="line">q050.prevList(q025);</span><br><span class="line">q025.prevList(q000);</span><br><span class="line">q000.prevList(<span class="keyword">null</span>);</span><br><span class="line">qInit.prevList(qInit);</span><br></pre></td></tr></table></figure>

<p>q050 = new PoolChunkList<T>(this, q075, 50, 100, chunkSize) 表示：</p>
<ul>
<li>q075是q050的下一个节点。</li>
<li>当前 ChunkList 中存储的 Chunk 的内存使用率都在50%～100%。</li>
<li>ChunkSize 为其设置大小</li>
</ul>
<p>ChunkList 的节点关系如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/ChunkList%E7%9A%84%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.jpg" class="" title="ChunkList的节点关系">

<p>Netty中，Chunk 又包含了多个Page，每个Page的大小为8KB，如果要分配16KB的内存，则在Chunk中找到连续的两个Page就可以。</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Chunk%E5%92%8CPage.jpg" class="" title="Chunk和Page">

<p>在很多场景下，为缓冲区分配8KB的内存也是一种浪费，比如只需要分配2KB的缓冲区，如果使用8KB会造成6KB的浪费。这种情况下，Netty又会将Page切分成多个SubPage，每个SubPage大小要根据分配的缓冲区大小而定，比如要分配2KB的内存，就会将一个Page切分成4个SubPage，每个SubPage的大小为2KB：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Page%E5%92%8CSubPage.jpg" class="" title="Page和SubPage">

<p>PoolSubpage 的基本结构的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolSubpage</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">PoolSubpageMetric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> memoryMapIdx;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> runOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap;</span><br><span class="line"></span><br><span class="line">    PoolSubpage&lt;T&gt; prev;</span><br><span class="line">    PoolSubpage&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doNotDestroy;</span><br><span class="line">    <span class="keyword">int</span> elemSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxNumElems;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bitmapLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextAvail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numAvail;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chunk代表其子页属于哪个Chunk</li>
<li>bitmap用于记录子页的内存分配情况</li>
<li>prev和next代表子页是按照双向链表进行关联的，分别指向上一个节点和下一个节点</li>
<li>elemSize属性代表的是子页是按照多大内存进行划分的，如果按照1KB划分，则可以划分出8个子页</li>
</ul>
<p>PoolArena 的 allocate() 方法中 allocateNormal(buf，reqCapacity，normCapacity) 实际上就是在Page级别上进行分配，分配一个或者多个Page的空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method must be called inside synchronized(this) &#123; ... &#125; block</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在原有的Chunk中进行内存分配</span></span><br><span class="line">    <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是首次分配，创建Chunk进行内存分配</span></span><br><span class="line">    PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">    <span class="keyword">boolean</span> success = c.allocate(buf, reqCapacity, normCapacity);</span><br><span class="line">    <span class="keyword">assert</span> success;</span><br><span class="line">    qInit.add(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>优先在原有的Chunk中进行内存分配</li>
<li>如果是首次分配，那就创建Chunk进行内存分配</li>
<li>最后初始化ByteBuf</li>
</ol>
<p>以 q050 为例进行分析，q050.allocate(buf，reqCapacity，normCapacity)方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (normCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="comment">// Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</span></span><br><span class="line">        <span class="comment">// be handled by the PoolChunks that are contained in this PoolChunkList.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从Head节点向下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (PoolChunk&lt;T&gt; cur = head; cur != <span class="keyword">null</span>; cur = cur.next) &#123;</span><br><span class="line">        <span class="comment">// 尝试分配</span></span><br><span class="line">        <span class="keyword">if</span> (cur.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            <span class="comment">// 当前Chunk的内存使用率大于其最大使用率</span></span><br><span class="line">            <span class="keyword">if</span> (cur.usage() &gt;= maxUsage) &#123;</span><br><span class="line">                <span class="comment">// 从当前的ChunkList中移除，再添加到下一个ChunkList中</span></span><br><span class="line">                remove(cur);</span><br><span class="line">                nextList.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Head节点往下遍历，对每个Chunk都尝试去分配。</p>
<p>再回到 allocateNormal() 方法，查看首次分配：<code>newChunk(pageSize, maxOrder, pageShifts, chunkSize)</code></p>
<p>其中参数pageSize是8192，也就是8KB；maxOrder为11；pageShifts为13，2的13次方正好是8192，也就是8KB；chunkSize为16777216，也就是16MB。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>,</span><br><span class="line">                                         allocateDirect(chunkSize), pageSize, maxOrder,</span><br><span class="line">                                         pageShifts, chunkSize, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请了一块直接内存</span></span><br><span class="line">    <span class="keyword">final</span> ByteBuffer memory = allocateDirect(chunkSize</span><br><span class="line">                                             + directMemoryCacheAlignment);</span><br><span class="line">    <span class="comment">// 通过构造函数创建了一个Chunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, pageSize,</span><br><span class="line">                                     maxOrder, pageShifts, chunkSize,</span><br><span class="line">                                     offsetCacheLine(memory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PoolChunk 的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, </span><br><span class="line">          <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    unpooled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize; <span class="comment">// 8K</span></span><br><span class="line">    <span class="keyword">this</span>.pageShifts = pageShifts; <span class="comment">// 13</span></span><br><span class="line">    <span class="keyword">this</span>.maxOrder = maxOrder; <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line">    log2ChunkSize = log2(chunkSize);</span><br><span class="line">    subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">    freeBytes = chunkSize;</span><br><span class="line"></span><br><span class="line">    maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the memory map.</span></span><br><span class="line">    memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>]; <span class="comment">// 节点个数4096</span></span><br><span class="line">    depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">    <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">            memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d; <span class="comment">// d代表当前节点的深度</span></span><br><span class="line">            depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">            memoryMapIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line">    cachedNioBuffers = <span class="keyword">new</span> ArrayDeque&lt;ByteBuffer&gt;(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/Chunk%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg" class="" title="Chunk的层级关系">

<p>上图是一个二叉树的结构，左侧的数字代表层级，右侧代表一块连续的内存，每个父节点下又拆分成多个子节点，顶层表示的内存范围为0～16MB，其下又分为两层，范围为0～8MB、8～16MB，依此类推，最后到11层，以8KB的大小划分，也就是一个Page的大小。</p>
<p>如果我们分配一个8MB的缓冲区，则会将第二层的第一个节点，也就是0～8MB这个连续的内存进行分配。分配完成之后，会将这个节点设置为不可用。结合上面的图，我们再看构造方法中的for循环代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">        memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d; <span class="comment">// d代表当前节点的深度</span></span><br><span class="line">        depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">        memoryMapIndex ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这个for循环就是将上面的结构包装成一个字节数组memoryMap，外层循环用于控制层数，内层循环用于控制里面每层的节点。经过循环之后，memoryMap和depthMap内容为以下表现形式：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/depthMap.jpg" class="" title="depthMap">

<p>需要注意的是，因为程序中数组的下标是从1开始设置的，所以第0个节点元素为默认值0。这里数字代表层级，同时也代表了当前层级的节点，相同的数字个数就是这一层级的节点数。其中0为2个（因为分配时下标是从1开始的，所以第0个位置是默认值0，实际上第0层元素只有一个，就是头节点），1为2个，2为4个，3为8个，4为16个，n为2的n次方个，直到11，也就是11有2的11次方个。</p>
<p>继续剖析 cur.allocate(buf, reqCapacity, normCapacity)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolChunk的allocate方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) &#123; <span class="comment">// 大于一个Page</span></span><br><span class="line">        handle =  allocateRun(normCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handle = allocateSubpage(normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123; <span class="comment">// handle小于0说明分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuffer nioBuffer = cachedNioBuffers != <span class="keyword">null</span> ? cachedNioBuffers.pollLast() : <span class="keyword">null</span>;</span><br><span class="line">    initBuf(buf, nioBuffer, handle, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateRun</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示根据normCapacity计算出第几层</span></span><br><span class="line">    <span class="keyword">int</span> d = maxOrder - (log2(normCapacity) - pageShifts);</span><br><span class="line">    <span class="comment">// 根据层级关系去分配一个节点，其中id代表memoryMap中的下标</span></span><br><span class="line">    <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    freeBytes -= runLength(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allocateNode()方法的具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标初始值为1</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 代表当前层级第一个节点的初始下标</span></span><br><span class="line">    <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line">    <span class="comment">// 获取第一个节点的值</span></span><br><span class="line">    <span class="keyword">byte</span> val = value(id);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// 如果值大于层级，说明Chunk不可用</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前下标对应的节点值如果小于层级，或当前下标小于层级的初始下标</span></span><br><span class="line">    <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) &#123; <span class="comment">// id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</span></span><br><span class="line">        <span class="comment">// 当前下标乘2，代表当前节点的子节点的起始位置</span></span><br><span class="line">        id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取id位置的值</span></span><br><span class="line">        val = value(id);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// 如果值大于层级，说明节点不可用</span></span><br><span class="line">            id ^= <span class="number">1</span>; <span class="comment">// id为偶数则+1，id为奇数则-1，用的是兄弟节点</span></span><br><span class="line">            val = value(id); <span class="comment">// 获取id位置的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> value = value(id);</span><br><span class="line">    <span class="keyword">assert</span> value == d &amp;&amp; (id &amp; initial) == <span class="number">1</span> &lt;&lt; d : String.format(<span class="string">"val = %d, id &amp; initial = %d, d = %d"</span>,</span><br><span class="line">                                                                  value, id &amp; initial, d);</span><br><span class="line">    <span class="comment">// 将找到的节点设置为不可用</span></span><br><span class="line">    setValue(id, unusable); <span class="comment">// unusable = maxOrder + 1 = 12</span></span><br><span class="line">    <span class="comment">// 逐层网上标记为被使用</span></span><br><span class="line">    updateParentsAlloc(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实际上是从第一个节点往下找的，找到层级为d、未被使用的节点。找到相关节点后通过 setValue 将当前节点设置为不可用，其中id是当前节点的下标，unusable代表一个不可用的值，这里是12，因为我们的层级只有12层，所以设置为12之后就相当于标记不可用。设置为不可用之后，通过updateParentsAlloc(id)逐层设置为缓存被使用的状态。updateParentsAlloc()方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的父节点的id</span></span><br><span class="line">        <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取当前节点的值</span></span><br><span class="line">        <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">        <span class="comment">// 找到当前节点的兄弟节点</span></span><br><span class="line">        <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果当前节点值小于兄弟节点，则保存当前节点值到val,否则保存兄弟节点值到val</span></span><br><span class="line">        <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">        <span class="comment">// 将val的值设置为父节点下标对应的值</span></span><br><span class="line">        setValue(parentId, val);</span><br><span class="line">        <span class="comment">// id设置为父节点id，继续循环</span></span><br><span class="line">        id = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是将循环兄弟节点的值替换成父节点的值，可以通过注释仔细地进行逻辑分析。简单起见，这里只设置三层，如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc1.jpg" class="" title="updateParentsAlloc">

<p>我们模拟其分配场景，假设只有三层，其中index代表数组memoryMap的下标，value代表其值，memoryMap中的值就为[0，0，1，1，2，2，2，2]。我们要分配一个4MB的ByteBuf，在调用allocateNode(int d)中传入的d是2，也就是第二层。根据上面分析的逻辑，这里会找到第二层的第一个节点，也就是0～4MB这个节点，找到之后将其设置为不可用，这样memoryMap中的值就为[0，0，1，1，12，2，2，2]，二叉树的结构就会如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc2.jpg" class="" title="updateParentsAlloc">

<p>注意深色节点部分，将index为4的节点设置为不可用，之后则将向上设置不可用，循环将兄弟节点数值较小的节点替换到父节点，也就是将index为2的节点的值替换成了index为5的节点的值，这样数组的值就会变为[0，1，2，1，12，2，2，2]，二叉树的结构如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc3.jpg" class="" title="updateParentsAlloc">

<p>注意：这里深色节点仅仅代表节点变化，并不是当前节点为不可用状态，不可用状态的真正判断依据是value值为12。</p>
<p>这样，如果再次分配一个4MB内存的ByteBuf，根据其逻辑，则会找到第二层的第二个节点，也就是4～8MB。再根据我们的逻辑，通过向上设置不可用，index为2就会设置成不可用状态，将value的值设置为12，数组的值变为[0，1，12，1，12，12，2，2]，二叉树的结构如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/updateParentsAlloc4.jpg" class="" title="updateParentsAlloc">

<p>可以看到，分配两个4MB的ByteBuf之后，当前节点和其父节点都会设置成不可用状态，当index=2的节点设置为不可用之后，将不会再找这个节点下的子节点。依此类推，直到所有的内存分配完毕，index为1的节点也会变成不可用状态，这样所有的Page就都分配完毕，Chunk中再无可用节点。</p>
<p>根据以上分析可知，PoolChunk的allocate方法中的 <code>handle =  allocateRun(normCapacity);</code> 或 <code>handle = allocateSubpage(normCapacity);</code> ，返回的就是memoryMap的一个下标。通过这个下标，我们能唯一地定位一块内存。继续往下跟，通过 initBuf(buf, nioBuffer, handle, reqCapacity) 初始化ByteBuf后，再通过 qInit.add(c)将新创建的Chunk添加到ChunkList中，我们看 initBuf() 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle); <span class="comment">// 其实就是返回handler本身，memoryMapIdx=handle</span></span><br><span class="line">    <span class="comment">// bitmapIdx(handle)是有关SubPage中使用到的逻辑，如果是Page级别的分配，只返回0</span></span><br><span class="line">    <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);<span class="comment">// handle &gt;&gt;&gt; Integer.SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) &#123; <span class="comment">// bitmapIdx == 0 说明是Page级别的分配</span></span><br><span class="line">        <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line">        <span class="keyword">assert</span> val == unusable : String.valueOf(val);<span class="comment">// 判断当前节点是不是不可用</span></span><br><span class="line">        </span><br><span class="line">        buf.init(<span class="keyword">this</span>, nioBuffer, handle, runOffset(memoryMapIdx) + offset,</span><br><span class="line">                 reqCapacity, runLength(memoryMapIdx), arena.parent.threadCache());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initBufWithSubpage(buf, nioBuffer, handle, bitmapIdx, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runOffset</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// represents the 0-based offset in #bytes from start of the byte-array chunk</span></span><br><span class="line">    <span class="keyword">int</span> shift = id ^ <span class="number">1</span> &lt;&lt; depth(id);</span><br><span class="line">    <span class="keyword">return</span> shift * runLength(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runLength</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// represents the size in #bytes supported by node 'id' in the tree</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; log2ChunkSize - depth(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runOffset(memoryMapIdx) + offset 表示偏移量，偏移量相当于分配给缓冲区的这块内存相对于Chunk中申请的内存的首地址偏移了多少。参数runLength(memoryMapIdx)表示根据下标获取可分配的最大长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    init0(chunk, nioBuffer, handle, offset, length, maxLength, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init0</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assert</span> chunk != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk; <span class="comment">// 在哪一块内存进行分配</span></span><br><span class="line">    memory = chunk.memory; <span class="comment">// 这这一块内存的哪一块连续内存</span></span><br><span class="line">    tmpNioBuf = nioBuffer;</span><br><span class="line">    allocator = chunk.arena.parent;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 PooledByteBuf 在Page级别分配的完整流程。</p>
<h4 id="SubPage级别的内存分配"><a href="#SubPage级别的内存分配" class="headerlink" title="SubPage级别的内存分配"></a>SubPage级别的内存分配</h4><p>如果分配一个缓冲区大小远小于Page，直接在一个Page上进行分配会造成内存浪费，所以需要将Page继续切分成多个子块进行分配，子块分配的个数根据要分配的缓冲区大小而定，比如只需要分配1KB的内存，就将一个Page分成8等分。</p>
<p>简单起见，仅以16字节为例，讲解其分配逻辑。在分析其逻辑前，首先看PoolArena的一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br></pre></td></tr></table></figure>

<p>这个属性是一个PoolSubpage的数组，有点类似于一个SubPage的缓存。我们创建一个SubPage之后，会将创建好的SubPage与PoolArena中tinySubpagePools数组的每一个元素进行关联，下次再分配的时候可以直接通过tinySubpagePools数组元素去找关联的SubPage。而tinySubpagePools是在PoolArena的构造方法中初始化的，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> cacheAlignment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// numTinySubpagePools = 512 &gt;&gt;&gt; 4 = 32</span></span><br><span class="line">    tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;</span><br><span class="line">        tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> PoolSubpage&lt;T&gt;[] newSubpagePoolArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolSubpage[size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> PoolSubpage&lt;T&gt; <span class="title">newSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    PoolSubpage&lt;T&gt; head = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(pageSize);</span><br><span class="line">    head.prev = head;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码知道，SubPage其实也是一个双向链表，这里将Head的上一个节点和下一个节点都设置为自身，有关PoolSubpage的关联关系，我们稍后分析。通过循环创建PoolSubpage，总共创建32个SubPage，每个SubPage实际代表一块内存大小，如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/tinySubpagePools.jpg" class="" title="tinySubpagePools">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">    <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">    <span class="keyword">int</span> d = maxOrder; <span class="comment">// subpages are only be allocated from pages i.e., leaves</span></span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">        <span class="comment">// 表示在第11层分配节点</span></span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取初始化的SubPage</span></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"></span><br><span class="line">        freeBytes -= pageSize;</span><br><span class="line">        <span class="comment">// 表示第几个subPageIdx</span></span><br><span class="line">        <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">        <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果SubPage为空</span></span><br><span class="line">            subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">            <span class="comment">// 将当前的下标赋值给Subpage</span></span><br><span class="line">            subpages[subpageIdx] = subpage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subpage.init(head, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 抽出一个SubPage</span></span><br><span class="line">        <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 PoolSubpage<T>head=arena.findSubpagePoolHead(normCapacity) 这种方式找到Head节点，实际上这里Head就是之前分析的tinySubpagePools属性的第一个节点，也就是对应16Byte的那个节点。</p>
<p>int d=maxOrder 是将11赋值给d，也就是在内存树的第11层取节点，这部分上一小节已经剖析过。int id=allocateNode(d) 获取的是上一小节分析过的字节数组 memoryMap 的下标，这里指向一个Page，如果是第一次分配，指向的是0～8kB的那个Page。</p>
<p>final PoolSubpage<T>[]subpages=this.subpages 这一步是获得PoolChunk中成员变量SubPages的值，也是个PoolSubpage的数组，在PoolChunk进行初始化的时候，也会初始化该数组，长度为2048。也就是说每个Chunk都维护着一个SubPage的列表。如果每一个Page级别的内存都需要被切分成SubPage，则会将这个Page放入该列表中，专门用于分配SubPage。</p>
<p>所以这个列表中的SubPage其实就是一个用于切分的Page。SubPages如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/SubPage.jpg" class="" title="SubPage">

<p>int subpageIdx=subpageIdx(id) 这一步是通过id获得PoolSubpage数组的下标，如果id对应的Page是0～8KB的节点，这里获得的下标就是0。在 if(subpage==null) 中，因为默认SubPages只是创建一个数组，并没有往数组中赋值，所以第一次执行到这里会返回true，跟到if块中，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">subpages[subpageIdx] = subpage;</span><br></pre></td></tr></table></figure>

<p>通过new PoolSubpage创建一个新的SubPage后，通过subpages[subpageIdx]=subpage将新创建的SubPage根据下标赋值到SubPages中的元素。在new PoolSubpage的构造方法中，传入Head，就是之前提到的tinySubpagePools属性中的节点，如果分配16字节的缓冲区，这里对应的就是第一个节点，PoolSubpage构造方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, </span><br><span class="line">            <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) &#123;</span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">    <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line">    <span class="keyword">this</span>.runOffset = runOffset;</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">// pageSize / 16 / 64</span></span><br><span class="line">    init(head, elemSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注bitmap属性，这是一个long类型的数组，初始大小为8，这只是初始化的大小，真正的大小要根据Page切分成多少块确定，这里将属性进行了赋值，我们看init()方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">    doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.elemSize = elemSize;</span><br><span class="line">    <span class="keyword">if</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">        maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line">        nextAvail = <span class="number">0</span>;</span><br><span class="line">        bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            bitmapLength ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">            <span class="comment">// bitmap用于标识哪个SubPage被分配，0表示未分配，1表示已分配</span></span><br><span class="line">            bitmap[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加到Arena里面</span></span><br><span class="line">    addToPool(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this.elemSize=elemSize 表示保存当前分配的缓冲区大小，因为以16字节为例，所以这里是16。maxNumElems=numAvail=pageSize/elemSize 初始化了两个属性maxNumElems和numAvail，值都为pageSize/elemSize，表示一个Page大小除以分配的缓冲区大小，也就是表示当前Page被划分了多少份。numAvail表示剩余可用的块数，由于第一次分配都是可用的，所以numAvail=maxNumElems。bitmapLength表示bitmap的实际大小，已经分析过，bitmap初始化大小为8，但实际上并不一定需要8个元素，元素个数要根据Page切分的子块而定，这里的大小是所切分的子块数除以64。再往下看，代码if（（maxNumElems&amp;63）！=0）用于判断maxNumElems也就是当前配置所切分的子块是不是64的倍数，如果不是，则bitmapLength加1，最后通过循环，将对应位置的子块标记为0。</p>
<p>这里详细分析一下bitmap，它是个long类型的数组，long数组中的每一个值，也都是long类型的数字，其中每一个比特位都标记着Page中每一个子块的内存是否已分配，如果比特位是1，表示该子块已分配；如果比特位是0，表示该子块未分配，标记顺序是其二进制数从低位到高位进行排列。我们应该知道为什么bitmap大小要设置为子块数量除以64，因为long类型的数字是64位，每一个元素都能记录64个子块的数量，这样就可以通过SubPage个数除以64的方式决定bitmap中元素的数量。如果子块不能整除64，则通过元素数量+1的方式，除以64之后剩余的子块通过long中比特位由低到高进行排列记录，其逻辑结构如下图所示：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/bitmap.jpg" class="" title="bitmap">

<h4 id="Chunk级别的内存分配"><a href="#Chunk级别的内存分配" class="headerlink" title="Chunk级别的内存分配"></a>Chunk级别的内存分配</h4><p>当需要分配的内存大小大于 ChunkSize 时，Netty 采用非池化策略直接分配内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateHuge</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    PoolChunk&lt;T&gt; chunk = newUnpooledChunk(reqCapacity); <span class="comment">// 采用非池化策略直接分配内存</span></span><br><span class="line">    activeBytesHuge.add(chunk.chunkSize());</span><br><span class="line">    buf.initUnpooled(chunk, reqCapacity);</span><br><span class="line">    allocationsHuge.increment();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newUnpooledChunk</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>,</span><br><span class="line">                                         allocateDirect(capacity), capacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer memory = allocateDirect(capacity</span><br><span class="line">                                             + directMemoryCacheAlignment);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, capacity,</span><br><span class="line">                                     offsetCacheLine(memory));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.useDirectBufferNoCleaner() ?</span><br><span class="line">        PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuf的内存回收"><a href="#ByteBuf的内存回收" class="headerlink" title="ByteBuf的内存回收"></a>ByteBuf的内存回收</h4><p>堆外内存是不受JVM垃圾回收机制控制的，分配一块堆外内存进行ByteBuf操作完后要对对象进行回收。</p>
<p>ByteBUf的回收就是调用<strong>release()</strong> 方法，不管是哪种类型的 ByteBuf 都会调用到 release0 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handleRelease(updater.release(<span class="keyword">this</span>, decrement));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">retryRelease0</span><span class="params">(T instance, <span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> rawCnt = updater().get(instance), realCnt = toLiveRealRefCnt(rawCnt, decrement);</span><br><span class="line">        <span class="keyword">if</span> (decrement == realCnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryFinalRelease0(instance, rawCnt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decrement &lt; realCnt) &#123;</span><br><span class="line">            <span class="comment">// all changes to the raw count are 2x the "real" change</span></span><br><span class="line">            <span class="keyword">if</span> (updater().compareAndSet(instance, rawCnt, rawCnt - (decrement &lt;&lt; <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(realCnt, -decrement);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield(); <span class="comment">// this benefits throughput under high contention</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleRelease</span><span class="params">(<span class="keyword">boolean</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        deallocate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是判断剩余引用数是否大于 decrement，如果大于则通过CAS修改引用数。然后通过deallocate()方法进行释放，以 UnpooledDirectByteBuf 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">        <span class="comment">// 表示当前的ByteBuf不在指向任何一块内存</span></span><br><span class="line">        <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">        memory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将ByteBuf内存进行释放</span></span><br><span class="line">        chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        recycle(); <span class="comment">// 将对象放入对象池，循环利用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">        destroyChunk(chunk);</span><br><span class="line">        activeBytesHuge.add(-size);</span><br><span class="line">        deallocationsHuge.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//池化内存</span></span><br><span class="line">        SizeClass sizeClass = sizeClass(normCapacity);<span class="comment">// 判断内存规格</span></span><br><span class="line">        <span class="comment">// 加到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">            <span class="comment">// cached so not free it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> 		<span class="comment">// 将缓存对象标记为未使用</span></span><br><span class="line">        freeChunk(chunk, handle, sizeClass, nioBuffer, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Jace Ding 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Jace Ding 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Netty/" rel="tag"># Netty</a>
              <a href="/tags/%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98/" rel="tag"># 池化内存</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag"># 内存管理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/19/%E7%A3%81%E7%9B%98IO%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" rel="prev" title="磁盘IO调度策略">
      <i class="fa fa-chevron-left"></i> 磁盘IO调度策略
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3FastThreadLocal/" rel="next" title="深入理解FastThreadLocal">
      深入理解FastThreadLocal <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#池化内存"><span class="nav-number">1.</span> <span class="nav-text">池化内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整体原理"><span class="nav-number">1.1.</span> <span class="nav-text">整体原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法结构"><span class="nav-number">1.2.</span> <span class="nav-text">算法结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-number">1.3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正常对象"><span class="nav-number">1.3.1.</span> <span class="nav-text">正常对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小对象"><span class="nav-number">1.3.2.</span> <span class="nav-text">小对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#巨型对象"><span class="nav-number">1.3.3.</span> <span class="nav-text">巨型对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弹性伸缩"><span class="nav-number">1.4.</span> <span class="nav-text">弹性伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PoolChunk"><span class="nav-number">1.4.1.</span> <span class="nav-text">PoolChunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PoolSubpage"><span class="nav-number">1.4.2.</span> <span class="nav-text">PoolSubpage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发设计"><span class="nav-number">1.5.</span> <span class="nav-text">并发设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBuf"><span class="nav-number">2.1.</span> <span class="nav-text">ByteBuf</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本分类"><span class="nav-number">2.1.2.</span> <span class="nav-text">基本分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本操作"><span class="nav-number">2.1.3.</span> <span class="nav-text">基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBufAllocator"><span class="nav-number">2.2.</span> <span class="nav-text">ByteBufAllocator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本操作-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非池化内存分配"><span class="nav-number">2.3.</span> <span class="nav-text">非池化内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#堆内存的分配"><span class="nav-number">2.3.1.</span> <span class="nav-text">堆内存的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InstrumentedUnpooledUnsafeHeapByteBuf"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">InstrumentedUnpooledUnsafeHeapByteBuf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InstrumentedUnpooledHeapByteBuf"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">InstrumentedUnpooledHeapByteBuf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结-1"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆外内存的分配"><span class="nav-number">2.3.2.</span> <span class="nav-text">堆外内存的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InstrumentedUnpooledDirectByteBuf"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">InstrumentedUnpooledDirectByteBuf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InstrumentedUnpooledUnsafeDirectByteBuf"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">InstrumentedUnpooledUnsafeDirectByteBuf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结-2"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#池化内存的分配"><span class="nav-number">2.4.</span> <span class="nav-text">池化内存的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PooledByteBufAllocator"><span class="nav-number">2.4.1.</span> <span class="nav-text">PooledByteBufAllocator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PoolThreadLocalCache"><span class="nav-number">2.4.2.</span> <span class="nav-text">PoolThreadLocalCache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DirectArena内存分配流程"><span class="nav-number">2.4.3.</span> <span class="nav-text">DirectArena内存分配流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象池获取-ByteBuf"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">对象池获取 ByteBuf</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存池的内存规格"><span class="nav-number">2.4.4.</span> <span class="nav-text">内存池的内存规格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存的分配"><span class="nav-number">2.4.5.</span> <span class="nav-text">缓存的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存的数据结构"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">缓存的数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存的分配流程"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">缓存的分配流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page级别的内存分配"><span class="nav-number">2.4.6.</span> <span class="nav-text">Page级别的内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SubPage级别的内存分配"><span class="nav-number">2.4.7.</span> <span class="nav-text">SubPage级别的内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chunk级别的内存分配"><span class="nav-number">2.4.8.</span> <span class="nav-text">Chunk级别的内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuf的内存回收"><span class="nav-number">2.4.9.</span> <span class="nav-text">ByteBuf的内存回收</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jace Ding"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Jace Ding</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jaceding" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jaceding" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:931977674@qq.com" title="E-Mail → mailto:931977674@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jace Ding</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
