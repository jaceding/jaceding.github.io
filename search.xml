<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Canal环境搭建</title>
    <url>/2020/10/20/Canal%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Canal版本：1.1.5</p>
<p><a href="https://github.com/alibaba/canal/wiki" target="_blank" rel="noopener">官网</a>，<a href="https://github.com/alibaba/canal/wiki/AdminGuide" target="_blank" rel="noopener">配置说明</a></p>
<a id="more"></a>

<h2 id="下载、解压"><a href="#下载、解压" class="headerlink" title="下载、解压"></a>下载、解压</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/canal</span><br><span class="line">wget https://github.com/alibaba/canal/releases/download/canal-1.1.5-alpha-2/canal.deployer-1.1.5-SNAPSHOT.tar.gz</span><br><span class="line">tar -zxvf canal.deployer-1.1.5-SNAPSHOT.tar.gz</span><br><span class="line"><span class="comment"># 复制实例配置文件</span></span><br><span class="line"><span class="built_in">cd</span> conf/</span><br><span class="line">cp -r example/ chirp/</span><br><span class="line">cp -r example/ chirpouttest/</span><br><span class="line">rm -rf example/</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>10.86.52.74和10.86.52.74两台节点配置完全一样</p>
<h3 id="canal-properties"><a href="#canal-properties" class="headerlink" title="canal.properties"></a>canal.properties</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########               common argument         #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcp <span class="built_in">bind</span> ip</span></span><br><span class="line">canal.ip =</span><br><span class="line"><span class="meta">#</span><span class="bash"> register ip to zookeeper</span></span><br><span class="line">canal.register.ip =</span><br><span class="line">canal.port = 11111</span><br><span class="line">canal.metrics.pull.port = 11112</span><br><span class="line"><span class="meta">#</span><span class="bash"> canal instance user/passwd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.user = canal</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.passwd = E3619321C1A937C46A0D8BD1DAC39F93B27D4458</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal admin config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.admin.manager = 127.0.0.1:8089</span></span><br><span class="line">canal.admin.port = 11110</span><br><span class="line">canal.admin.user = admin</span><br><span class="line">canal.admin.passwd = 4ACFE3202A5FF5CF467898FC58AAB1D615029441</span><br><span class="line"></span><br><span class="line">canal.zkServers = 10.86.52.74:2181,10.86.52.77:2181,10.82.193.157:2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> flush data to zk</span></span><br><span class="line">canal.zookeeper.flush.period = 1000</span><br><span class="line">canal.withoutNetty = false</span><br><span class="line"><span class="meta">#</span><span class="bash"> tcp, kafka, rocketMQ, rabbitMQ</span></span><br><span class="line">canal.serverMode = kafka</span><br><span class="line"><span class="meta">#</span><span class="bash"> flush meta cursor/parse position to file</span></span><br><span class="line">canal.file.data.dir = $&#123;canal.conf.dir&#125;</span><br><span class="line">canal.file.flush.period = 1000</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># memory store RingBuffer size, should be Math.pow(2,n)</span></span></span><br><span class="line">canal.instance.memory.buffer.size = 16384</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># memory store RingBuffer used memory unit size , default 1kb</span></span></span><br><span class="line">canal.instance.memory.buffer.memunit = 1024 </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># meory store gets mode used MEMSIZE or ITEMSIZE</span></span></span><br><span class="line">canal.instance.memory.batch.mode = MEMSIZE</span><br><span class="line">canal.instance.memory.rawEntry = true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># detecing config</span></span></span><br><span class="line">canal.instance.detecting.enable = true</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()</span></span><br><span class="line">canal.instance.detecting.sql = select 1</span><br><span class="line">canal.instance.detecting.interval.time = 30</span><br><span class="line">canal.instance.detecting.retry.threshold = 3</span><br><span class="line">canal.instance.detecting.heartbeatHaEnable = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> support maximum transaction size, more than the size of the transaction will be cut into multiple transactions delivery</span></span><br><span class="line">canal.instance.transaction.size =  1024</span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql fallback connected to new master should fallback <span class="built_in">times</span></span></span><br><span class="line">canal.instance.fallbackIntervalInSeconds = 60</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> network config</span></span><br><span class="line">canal.instance.network.receiveBufferSize = 16384</span><br><span class="line">canal.instance.network.sendBufferSize = 16384</span><br><span class="line">canal.instance.network.soTimeout = 30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog filter config</span></span><br><span class="line">canal.instance.filter.druid.ddl = true</span><br><span class="line">canal.instance.filter.query.dcl = false</span><br><span class="line">canal.instance.filter.query.dml = false</span><br><span class="line">canal.instance.filter.query.ddl = false</span><br><span class="line">canal.instance.filter.table.error = false</span><br><span class="line">canal.instance.filter.rows = false</span><br><span class="line">canal.instance.filter.transaction.entry = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog format/image check</span></span><br><span class="line">canal.instance.binlog.format = ROW,STATEMENT,MIXED </span><br><span class="line">canal.instance.binlog.image = FULL,MINIMAL,NOBLOB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog ddl isolation</span></span><br><span class="line">canal.instance.get.ddl.isolation = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> parallel parser config</span></span><br><span class="line">canal.instance.parser.parallel = true</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># concurrent thread number, default 60% available processors, suggest not to exceed Runtime.getRuntime().availableProcessors()</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.parser.parallelThreadSize = 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># disruptor ringbuffer size, must be power of 2</span></span></span><br><span class="line">canal.instance.parser.parallelBufferSize = 256</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table meta tsdb info</span></span><br><span class="line">canal.instance.tsdb.enable = true</span><br><span class="line">canal.instance.tsdb.dir = $&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;</span><br><span class="line">canal.instance.tsdb.url = jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;</span><br><span class="line">canal.instance.tsdb.dbUsername = canal</span><br><span class="line">canal.instance.tsdb.dbPassword = canal</span><br><span class="line"><span class="meta">#</span><span class="bash"> dump snapshot interval, default 24 hour</span></span><br><span class="line">canal.instance.tsdb.snapshot.interval = 24</span><br><span class="line"><span class="meta">#</span><span class="bash"> purge snapshot expire , default 360 hour(15 days)</span></span><br><span class="line">canal.instance.tsdb.snapshot.expire = 360</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########               destinations            #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line">canal.destinations = chirp,chirpouttest</span><br><span class="line"><span class="meta">#</span><span class="bash"> conf root dir</span></span><br><span class="line">canal.conf.dir = ../conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> auto scan instance dir add/remove and start/stop instance</span></span><br><span class="line">canal.auto.scan = true</span><br><span class="line">canal.auto.scan.interval = 5</span><br><span class="line"></span><br><span class="line">canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xml</span></span><br><span class="line"></span><br><span class="line">canal.instance.global.mode = spring</span><br><span class="line">canal.instance.global.lazy = false</span><br><span class="line">canal.instance.global.manager.address = $&#123;canal.admin.manager&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.global.spring.xml = classpath:spring/memory-instance.xml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.global.spring.xml = classpath:spring/file-instance.xml</span></span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/default-instance.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########             MQ Properties      #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> aliyun ak/sk , support rds/mq</span></span><br><span class="line">canal.aliyun.accessKey =</span><br><span class="line">canal.aliyun.secretKey =</span><br><span class="line">canal.aliyun.uid=</span><br><span class="line"></span><br><span class="line">canal.mq.flatMessage = false</span><br><span class="line">canal.mq.canalBatchSize = 50</span><br><span class="line">canal.mq.canalGetTimeout = 100</span><br><span class="line"><span class="meta">#</span><span class="bash"> Set this value to <span class="string">"cloud"</span>, <span class="keyword">if</span> you want open message trace feature <span class="keyword">in</span> aliyun.</span></span><br><span class="line">canal.mq.accessChannel = local</span><br><span class="line"></span><br><span class="line">canal.mq.database.hash = true</span><br><span class="line">canal.mq.send.thread.size = 30</span><br><span class="line">canal.mq.build.thread.size = 8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########                    Kafka                   #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">kafka.bootstrap.servers = 10.86.52.74:9092.10.86.52.77:9092,10.82.193.157:9092</span><br><span class="line">kafka.acks = all</span><br><span class="line">kafka.compression.type = none</span><br><span class="line">kafka.batch.size = 16384</span><br><span class="line">kafka.linger.ms = 1</span><br><span class="line">kafka.max.request.size = 1048576</span><br><span class="line">kafka.buffer.memory = 33554432</span><br><span class="line">kafka.max.in.flight.requests.per.connection = 1</span><br><span class="line">kafka.retries = 0</span><br><span class="line"></span><br><span class="line">kafka.kerberos.enable = false</span><br><span class="line">kafka.kerberos.krb5.file = "../conf/kerberos/krb5.conf"</span><br><span class="line">kafka.kerberos.jaas.file = "../conf/kerberos/jaas.conf"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########                   RocketMQ         #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">rocketmq.producer.group = test</span><br><span class="line">rocketmq.enable.message.trace = false</span><br><span class="line">rocketmq.customized.trace.topic =</span><br><span class="line">rocketmq.namespace =</span><br><span class="line">rocketmq.namesrv.addr = 127.0.0.1:9876</span><br><span class="line">rocketmq.retry.times.when.send.failed = 0</span><br><span class="line">rocketmq.vip.channel.enabled = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########                   RabbitMQ         #############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">rabbitmq.host =</span><br><span class="line">rabbitmq.virtual.host =</span><br><span class="line">rabbitmq.exchange =</span><br><span class="line">rabbitmq.username =</span><br><span class="line">rabbitmq.password =</span><br></pre></td></tr></table></figure>

<h3 id="chirp-instance-properties"><a href="#chirp-instance-properties" class="headerlink" title="chirp/instance.properties"></a>chirp/instance.properties</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mysql serverId , v1.0.26+ will autoGen</span></span></span><br><span class="line">canal.instance.mysql.slaveId=179</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> gtid use <span class="literal">true</span>/<span class="literal">false</span></span></span><br><span class="line">canal.instance.gtidon=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> position info</span></span><br><span class="line">canal.instance.master.address=10.86.52.74:3306</span><br><span class="line">canal.instance.master.journal.name=</span><br><span class="line">canal.instance.master.position=</span><br><span class="line">canal.instance.master.timestamp=</span><br><span class="line">canal.instance.master.gtid=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rds oss binlog</span></span><br><span class="line">canal.instance.rds.accesskey=</span><br><span class="line">canal.instance.rds.secretkey=</span><br><span class="line">canal.instance.rds.instanceId=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table meta tsdb info</span></span><br><span class="line">canal.instance.tsdb.enable=true</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbUsername=canal</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbPassword=canal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.address =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.journal.name =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.position =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.timestamp =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.gtid=</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> username/password</span></span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=ZGp1eW9pZW5zMTU0NjQzyuwn</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> druid Decrypt database password</span></span><br><span class="line">canal.instance.enableDruid=false</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table regex</span></span><br><span class="line">canal.instance.filter.regex=chirp.dynamic_tb,chirp.post_tb</span><br><span class="line"><span class="meta">#</span><span class="bash"> table black regex</span></span><br><span class="line">canal.instance.filter.black.regex=mysql\\.slave_.*</span><br><span class="line"><span class="meta">#</span><span class="bash"> table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mq config</span></span><br><span class="line">canal.mq.topic=chirp_default</span><br><span class="line"><span class="meta">#</span><span class="bash"> dynamic topic route by schema or table regex</span></span><br><span class="line">canal.mq.dynamicTopic=chirp_dynamic:chirp.dynamic_tb,chirp_post:chirp.post_tb</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.mq.partition=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> partition config</span></span><br><span class="line">canal.mq.partitionsNum=1</span><br><span class="line">canal.mq.partitionHash=.*\\..*:id</span><br><span class="line">canal.mq.dynamicTopicPartitionNum=chirp.dynamic_tb:10,chirp.post_tb:10</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br></pre></td></tr></table></figure>

<h3 id="chirpouttest-instance-properties"><a href="#chirpouttest-instance-properties" class="headerlink" title="chirpouttest/instance.properties"></a>chirpouttest/instance.properties</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mysql serverId , v1.0.26+ will autoGen</span></span></span><br><span class="line">canal.instance.mysql.slaveId=179</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> gtid use <span class="literal">true</span>/<span class="literal">false</span></span></span><br><span class="line">canal.instance.gtidon=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> position info</span></span><br><span class="line">canal.instance.master.address=10.86.52.74:3306</span><br><span class="line">canal.instance.master.journal.name=</span><br><span class="line">canal.instance.master.position=</span><br><span class="line">canal.instance.master.timestamp=</span><br><span class="line">canal.instance.master.gtid=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rds oss binlog</span></span><br><span class="line">canal.instance.rds.accesskey=</span><br><span class="line">canal.instance.rds.secretkey=</span><br><span class="line">canal.instance.rds.instanceId=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table meta tsdb info</span></span><br><span class="line">canal.instance.tsdb.enable=true</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbUsername=canal</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbPassword=canal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.address =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.journal.name =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.position =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.timestamp =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.gtid=</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> username/password</span></span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=ZGp1eW9pZW5zMTU0NjQzyuwn</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> druid Decrypt database password</span></span><br><span class="line">canal.instance.enableDruid=false</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table regex</span></span><br><span class="line">canal.instance.filter.regex=chirp.dynamic_tb,chirp.post_tb</span><br><span class="line"><span class="meta">#</span><span class="bash"> table black regex</span></span><br><span class="line">canal.instance.filter.black.regex=mysql\\.slave_.*</span><br><span class="line"><span class="meta">#</span><span class="bash"> table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mq config</span></span><br><span class="line">canal.mq.topic=chirp_default</span><br><span class="line"><span class="meta">#</span><span class="bash"> dynamic topic route by schema or table regex</span></span><br><span class="line">canal.mq.dynamicTopic=chirp_dynamic:chirp.dynamic_tb,chirp_post:chirp.post_tb</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.mq.partition=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> partition config</span></span><br><span class="line">canal.mq.partitionsNum=1</span><br><span class="line">canal.mq.partitionHash=.*\\..*:id</span><br><span class="line">canal.mq.dynamicTopicPartitionNum=chirp.dynamic_tb:10,chirp.post_tb:10</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br></pre></td></tr></table></figure>

<h2 id="安装Canal-Admin"><a href="#安装Canal-Admin" class="headerlink" title="安装Canal-Admin"></a>安装Canal-Admin</h2>]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Canal</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装python3环境</title>
    <url>/2020/04/02/CentOS7%E5%AE%89%E8%A3%85python3%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h3><p>系统：Centos 7<br>Python安装包版本：Python-3.7.5.tgz 官网：<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">https://www.python.org/downloads/source/</a></p>
<h3 id="安装开发环境、及相关依赖"><a href="#安装开发环境、及相关依赖" class="headerlink" title="安装开发环境、及相关依赖"></a>安装开发环境、及相关依赖</h3><p><strong>Development tools</strong>这是一个可以给开发编译运维的配置基本初始环境的工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y groupinstall "Development tools"</span><br><span class="line">sudo yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="下载安装包、解压"><a href="#下载安装包、解压" class="headerlink" title="下载安装包、解压"></a>下载安装包、解压</h3><p>建议放在/usr/local目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd /usr/local </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经下载好了，也可以直接上传</span></span><br><span class="line">sudo wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tgz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">sudo tar -zxvf Python-3.7.5.tgz  #或 tar -xvJf Python-3.7.5.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd Python-3.7.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定安装目录 目录可以修改，建议放该目录下</span></span><br><span class="line">sudo ./configure --prefix=/usr/local/python3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p>注意： 这里没有覆盖python以及pip，而是使用python3、pip3，自带的python2.7、pip也依然还可以使用</p>
<p>1.<strong>/usr/bin 的录是系统预装的可执行程序</strong><br>2.<strong>/usr/local/bin 目录是给用户放置自己的可执行程序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3</span><br><span class="line">sudo ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3</span><br><span class="line">sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>

<h3 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h3><p>这里使用豆瓣源</p>
<p>如果只是临时使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install &lt;packagename&gt; -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">pip3 install &lt;packagename&gt; -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>永久修改（pip和pip3同时会生效）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到家目录</span></span><br><span class="line">cd ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建.pip目录 已存在则直接进入该目录</span></span><br><span class="line">mkdir .pip #</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入.pip目录</span></span><br><span class="line">cd .pip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建pip.conf配置文件</span></span><br><span class="line">touch pip.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 已存在则直接编辑</span></span><br><span class="line">vim pip.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改为</span></span><br><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>国内的其他镜像源分别如下：<br>1.清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>2.阿里：<a href="https://mirrors.aliyun.com/pypi/simple" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple</a><br>3.豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7环境配置</title>
    <url>/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y vim*</span><br></pre></td></tr></table></figure>

<h3 id="net-tools"><a href="#net-tools" class="headerlink" title="net-tools"></a>net-tools</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install net-tools</span><br></pre></td></tr></table></figure>

<h3 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装同步工具</span></span><br><span class="line">sudo yum -y install ntp ntpdate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置时间同步</span></span><br><span class="line">sudo ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将系统时间写入硬件时间</span></span><br><span class="line">sudo hwclock --systohc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统时间</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">sudo systemctl status sshd.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">sudo systemctl start sshd.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">sudo systemctl restart sshd.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">sudo systemctl enable sshd.service</span><br></pre></td></tr></table></figure>

<h2 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先安装wget方便后续下载</span></span><br><span class="line">sudo yum install -y wget</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd /etc/yum.repos.d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份旧的配置文件</span></span><br><span class="line">sudo mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载阿里的源文件</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理缓存</span></span><br><span class="line">yum clean all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h2 id="配置ip地址"><a href="#配置ip地址" class="headerlink" title="配置ip地址"></a>配置ip地址</h2><p><strong>相关命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是否能上网</span></span><br><span class="line">ping www.baidu.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ip地址,下面两个任选一个，可能需要安装net-tools</span></span><br><span class="line">ip addr</span><br><span class="line">ifconfig</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启网络，下面两个人选一个</span></span><br><span class="line">service network restart</span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h3 id="配置动态IP地址"><a href="#配置动态IP地址" class="headerlink" title="配置动态IP地址"></a>配置动态IP地址</h3><p><strong>前提是你的路由器已经开启了DHCP</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd /etc/sysconfig/network-scripts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改网卡配置</span></span><br><span class="line">vi ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p><strong>修改两个配置</strong>：</p>
<ol>
<li>BOOTPROTO=dhcp</li>
<li>ONBOOT=yes</li>
</ol>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%BF%AE%E6%94%B9ifcfg-ens33.png" class="" title="修改ifcfg-ens33">

<p><strong>修改后重启一下网络服务即可</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h3 id="配置静态IP地址"><a href="#配置静态IP地址" class="headerlink" title="配置静态IP地址"></a>配置静态IP地址</h3><p>配置静态ip地址同样也需要修改网卡配置，所以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd /etc/sysconfig/network-scripts/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改网卡配置</span></span><br><span class="line">vi ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p><strong>需要作如下修改</strong>：</p>
<ol>
<li><p>BOOTPROTO=static</p>
</li>
<li><p>ONBOOT=yes</p>
</li>
<li><p>在最后加上几行，IP地址、子网掩码、网关、dns服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置IP地址</span></span><br><span class="line">IPADDR=192.168.1.160</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置子网掩码</span></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置网关</span></span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置主DNS</span></span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置备DNS</span></span><br><span class="line">DNS2=114.114.114.114</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>修改后重启一下网络服务即可</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h2 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>系统：Centos 7</p>
<p>jdk安装包版本：jdk-8u231-linux-x64.tar.gz，官网下载：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p>
<h3 id="上传安装包、解压"><a href="#上传安装包、解压" class="headerlink" title="上传安装包、解压"></a>上传安装包、解压</h3><p>将安装包放在/usr/local目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd /usr/local </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf jdk-8u231-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在末尾添加，JAVA_HOME根据实际情况修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> java environment</span></span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_home/bin:$PATH</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>

<h3 id="使配置文件生效"><a href="#使配置文件生效" class="headerlink" title="使配置文件生效"></a>使配置文件生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="配置文件失效问题"><a href="#配置文件失效问题" class="headerlink" title="配置文件失效问题"></a>配置文件失效问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>/etc/profile```可以使配置文件生效。在当前终端环境下的确是生效了，但是打开新的终端会发现，怎么没有生效？</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 解决版本</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line"># 编辑~&#x2F;.bashrc或者&#x2F;etc&#x2F;bashrc</span><br><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line"># 最后一行添加</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h2 id="分区扩容"><a href="#分区扩容" class="headerlink" title="分区扩容"></a>分区扩容</h2><ol>
<li><p>先进入虚拟机设置里扩展磁盘容量，原本磁盘容量为160，这里设置为300（VMWare需要停止虚拟机才能）</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VMWare_%E6%89%A9%E5%AE%B9%E8%AE%BE%E7%BD%AE.png" class="" title="VMWare_扩容设置">
</li>
<li><p>进入虚拟机执行<code>fdisk -l</code></p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E6%89%A7%E8%A1%8Cfdisk_-l.png" class="" title="执行fdisk -l">

<p>可以看到总磁盘空间（/dev/sda）为322GB，且目前存在两个sda1（53.7G）、sda2（108.6G）分区，还有一个交换内存大概8G，可以忽略。</p>
</li>
<li><p>增加分区</p>
<ol>
<li><p>输入<code>fdisk /dev/sda</code>（和步骤2中总磁盘空间目录对应）</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E6%89%A7%E8%A1%8Cfdisk_devsda.png" class="" title="执行fdisk devsda">
</li>
<li><p>输入<code>m</code>，获取帮助</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/fdisk_devsda_m.png" class="" title="fdisk devsda m">
</li>
<li><p>输入<code>n</code>，增加一个分区</p>
<p>一直回车使用默认即可</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%88%86%E5%8C%BA.png" class="" title="增加一个分区">
</li>
<li><p>输入<code>w</code>，退出</p>
</li>
</ol>
</li>
<li><p>创建物理卷</p>
<p>输入<code>pvcreate /dev/sda3</code>（因为上面有sda1，sda2，所以这里按顺序创建sda3）</p>
<p>如果提示sda3找不到，输入<code>partprobe</code>或者重启虚拟机，再输入<code>pvcreate /dev/sda3</code></p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/pvcreate.png" class="" title="pvcreate">
</li>
<li><p>查询物理卷</p>
<p>输入<code>vgscan</code>，可以看到本机物理卷名称为<code>centos</code></p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/vgscan.png" class="" title="vgscan">

<p>输入<code>vgextend centos /dev/sda3</code>，新增物理卷扩展<code>centos</code>（centos需要根据实际情况修改）</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/vgextend.png" class="" title="vgextend">
</li>
<li><p>扩展</p>
<p>输入<code>lvextend -L +140G  /dev/mapper/centos-root</code>（这里需要根据实际情况修改：原本有160G，扩展到300G，所以+140G，路径这里需要根据上面的物理卷名称进行修改）</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/lvextend.png" class="" title="lvextend">

<p>输入<code>df -h</code>，发现容量没变化，别急，这是因为我们的系统还不认识刚刚添加进来的磁盘的文件系统，所以还需要对文件系统进行扩容。</p>
<p>输入<code>xfs_growfs /dev/mapper/centos-root</code>或者<code>resize2fs – f /dev/mapper/centos-root</code>（这里同样需要根据实际情况修改)</p>
</li>
<li><p>查看</p>
<p>输入<code>df -h</code>，效果如下说明扩容成功</p>
<img src="/2020/06/29/CentOS7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/xfs_growfs.png" class="" title="xfs_growfs"></li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置虚拟内存</title>
    <url>/2020/04/02/CentOS7%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h3 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h3><p>系统：CentOS 7</p>
<h3 id="首先查看当前的内存和swap-空间大小"><a href="#首先查看当前的内存和swap-空间大小" class="headerlink" title="首先查看当前的内存和swap 空间大小"></a>首先查看当前的内存和swap 空间大小</h3><p>默认单位为k, -m 单位为M</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="查看swap信息，包括文件和分区的详细信息"><a href="#查看swap信息，包括文件和分区的详细信息" class="headerlink" title="查看swap信息，包括文件和分区的详细信息"></a>查看swap信息，包括文件和分区的详细信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">cat /proc/swaps</span><br></pre></td></tr></table></figure>

<p>如果没有虚拟内存，我们就需要手动添加交换分区。</p>
<p><strong>注意，OPENVZ架构的VPS是不支持手动添加交换分区的</strong>。</p>
<p>添加交换空间有两种选择：添加一个交换分区或添加一个交换文件。推荐你添加一个交换分区；不过，若你没有</p>
<p>多少空闲空间可用， 则添加交换文件。</p>
<h4 id="查看vps的虚拟架构"><a href="#查看vps的虚拟架构" class="headerlink" title="查看vps的虚拟架构"></a>查看vps的虚拟架构</h4><p>现在市面上的vps虚拟技术有许多种，比如Openvz、Xen、VMware vSphere、Hyper-V、KVM及Xen的HVM与PV</p>
<p>等，在Xen中pv是半虚拟化，hvm是全虚拟化，pv只能用于linux内核的系统，hvm可以虚拟所有常见操作系统</p>
<p>(linux+windows)，理论效率比pv略低，另外hvm需要cpu虚拟化指令支持，pv无此要求，而Openvz是一个类似于</p>
<p>linux-VServer的操作系级全虚拟化解决方案。</p>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p><strong>Centos系统</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install virt-what</span><br></pre></td></tr></table></figure>

<p><strong>Debian/Ubuntu系统</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install virt-what</span><br></pre></td></tr></table></figure>

<h5 id="查看架构"><a href="#查看架构" class="headerlink" title="查看架构"></a>查看架构</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virt-what</span><br></pre></td></tr></table></figure>

<h3 id="增加swap交换文件"><a href="#增加swap交换文件" class="headerlink" title="增加swap交换文件"></a>增加swap交换文件</h3><h4 id="使用dd命令创建一个swap交换文件"><a href="#使用dd命令创建一个swap交换文件" class="headerlink" title="使用dd命令创建一个swap交换文件"></a>使用dd命令创建一个swap交换文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建立一个/home/swap的分区文件，大小为2G。</span></span><br><span class="line">dd if=/dev/zero of=/home/swap bs=1024 count=2048k</span><br></pre></td></tr></table></figure>

<h4 id="制作为swap格式文件"><a href="#制作为swap格式文件" class="headerlink" title="制作为swap格式文件"></a>制作为swap格式文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkswap /home/swap</span><br></pre></td></tr></table></figure>

<h4 id="再用swapon命令把这个文件分区挂载swap分区"><a href="#再用swapon命令把这个文件分区挂载swap分区" class="headerlink" title="再用swapon命令把这个文件分区挂载swap分区"></a>再用swapon命令把这个文件分区挂载swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon /home/swap</span><br></pre></td></tr></table></figure>

<p>我们用free -m命令看一下，发现已经有交换分区了。</p>
<p>但是重启系统后，swap分区又变成0了。</p>
<h4 id="为防止重启后swap分区变成0，要修改-etc-fstab文件"><a href="#为防止重启后swap分区变成0，要修改-etc-fstab文件" class="headerlink" title="为防止重启后swap分区变成0，要修改/etc/fstab文件"></a>为防止重启后swap分区变成0，要修改/etc/fstab文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/fstab</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件末尾（最后一行）加上 这样就算重启系统，swap分区还是有值。</span></span><br><span class="line">/home/swap swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<h4 id="调整-swappiness"><a href="#调整-swappiness" class="headerlink" title="调整 swappiness"></a>调整 swappiness</h4><p>swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。一般linux的默认设置为60，也就是说内存在使用到100-60=40%的时候，就开始出现有交换分区的使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看swappiness的值</span></span><br><span class="line">cat /proc/sys/vm/swappiness</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 临时修改</span></span><br><span class="line">sysctl vm.swappiness=10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久修改 添加vm.swappiness=60</span></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 激活设置</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="删除swap交换文件"><a href="#删除swap交换文件" class="headerlink" title="删除swap交换文件"></a>删除swap交换文件</h3><p>删除操作是基于上述的添加方式，可根据实际情况修改</p>
<h4 id="先停止swap分区"><a href="#先停止swap分区" class="headerlink" title="先停止swap分区"></a>先停止swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/swapoff /home/swap</span><br></pre></td></tr></table></figure>

<h4 id="删除swap分区文件"><a href="#删除swap分区文件" class="headerlink" title="删除swap分区文件"></a>删除swap分区文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /home/swap</span><br></pre></td></tr></table></figure>

<h4 id="删除自动挂载配置命令"><a href="#删除自动挂载配置命令" class="headerlink" title="删除自动挂载配置命令"></a>删除自动挂载配置命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab # 删除 /home/swap swap swap default 0 0</span><br></pre></td></tr></table></figure>

<h3 id="使用分区来做SWAP-虚拟内存"><a href="#使用分区来做SWAP-虚拟内存" class="headerlink" title="使用分区来做SWAP(虚拟内存)"></a>使用分区来做SWAP(虚拟内存)</h3><h4 id="使用fdisk来创建交换分区（-dev-sdb2-是创建的交换分区）"><a href="#使用fdisk来创建交换分区（-dev-sdb2-是创建的交换分区）" class="headerlink" title="使用fdisk来创建交换分区（ /dev/sdb2 是创建的交换分区）"></a>使用fdisk来创建交换分区（ /dev/sdb2 是创建的交换分区）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb2</span><br></pre></td></tr></table></figure>

<h4 id="使用-mkswap-命令来设置交换分区："><a href="#使用-mkswap-命令来设置交换分区：" class="headerlink" title="使用 mkswap 命令来设置交换分区："></a>使用 mkswap 命令来设置交换分区：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkswap /dev/sdb2</span><br></pre></td></tr></table></figure>

<h4 id="启用交换分区"><a href="#启用交换分区" class="headerlink" title="启用交换分区"></a>启用交换分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon /dev/sdb2</span><br></pre></td></tr></table></figure>

<h4 id="写入-etc-fstab-以便在引导时启用"><a href="#写入-etc-fstab-以便在引导时启用" class="headerlink" title="写入/etc/fstab,以便在引导时启用"></a>写入/etc/fstab,以便在引导时启用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/fstab</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line">/dev/sdb2 swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<h3 id="删除交换分区"><a href="#删除交换分区" class="headerlink" title="删除交换分区"></a>删除交换分区</h3><p>删除操作是基于上述的添加方式，可根据实际情况修改</p>
<h4 id="先停止swap分区-1"><a href="#先停止swap分区-1" class="headerlink" title="先停止swap分区"></a>先停止swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/swapoff /dev/sdb2</span><br></pre></td></tr></table></figure>

<h3 id="删除自动挂载配置命令-1"><a href="#删除自动挂载配置命令-1" class="headerlink" title="删除自动挂载配置命令"></a>删除自动挂载配置命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fstab</span><br><span class="line"># 或者</span><br><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"># 删除 &#x2F;dev&#x2F;sdb2 swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK环境搭建</title>
    <url>/2020/05/18/ELK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><strong>环境说明：</strong></p>
<ul>
<li><p>ElasticSearch：7.7.0</p>
</li>
<li><p>Kibana: 7.7.0</p>
</li>
<li><p>Linux: Centos7</p>
</li>
</ul>
<a id="more"></a>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>下面是原始的文件，修改配置后需要挂载到容器中：</p>
<h3 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">"docker-cluster"</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<h3 id="jvm-options"><a href="#jvm-options" class="headerlink" title="jvm.options"></a>jvm.options</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## JVM configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">## IMPORTANT: JVM heap size</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## You should always set the min and max JVM heap</span></span><br><span class="line"><span class="comment">## size to the same value. For example, to set</span></span><br><span class="line"><span class="comment">## the heap to 4 GB, set:</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## -Xms4g</span></span><br><span class="line"><span class="comment">## -Xmx4g</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</span></span><br><span class="line"><span class="comment">## for more information</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Xms represents the initial size of total heap space</span></span><br><span class="line"><span class="comment"># Xmx represents the maximum size of total heap space</span></span><br><span class="line"></span><br><span class="line"><span class="attr">-Xms1g</span></span><br><span class="line"><span class="attr">-Xmx1g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">## Expert settings</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## All settings below this section are considered</span></span><br><span class="line"><span class="comment">## expert settings. Don't tamper with them unless</span></span><br><span class="line"><span class="comment">## you understand what you are doing</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## GC configuration</span></span><br><span class="line"><span class="meta">8-13</span>:<span class="string">-XX:+UseConcMarkSweepGC</span></span><br><span class="line"><span class="meta">8-13</span>:<span class="string">-XX:CMSInitiatingOccupancyFraction=75</span></span><br><span class="line"><span class="meta">8-13</span>:<span class="string">-XX:+UseCMSInitiatingOccupancyOnly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## G1GC Configuration</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> G1 GC is only supported on JDK version 10 or later</span></span><br><span class="line"><span class="comment"># to use G1GC, uncomment the next two lines and update the version on the</span></span><br><span class="line"><span class="comment"># following three lines to your version of the JDK</span></span><br><span class="line"><span class="comment"># 10-13:-XX:-UseConcMarkSweepGC</span></span><br><span class="line"><span class="comment"># 10-13:-XX:-UseCMSInitiatingOccupancyOnly</span></span><br><span class="line"><span class="meta">14-</span>:<span class="string">-XX:+UseG1GC</span></span><br><span class="line"><span class="meta">14-</span>:<span class="string">-XX:G1ReservePercent=25</span></span><br><span class="line"><span class="meta">14-</span>:<span class="string">-XX:InitiatingHeapOccupancyPercent=30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## JVM temporary directory</span></span><br><span class="line"><span class="meta">-Djava.io.tmpdir</span>=<span class="string">$&#123;ES_TMPDIR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## heap dumps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate a heap dump when an allocation from the Java heap fails</span></span><br><span class="line"><span class="comment"># heap dumps are created in the working directory of the JVM</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specify an alternative path for heap dumps; ensure the directory exists and</span></span><br><span class="line"><span class="comment"># has sufficient space</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">HeapDumpPath=data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specify an alternative path for JVM fatal error logs</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">ErrorFile=logs/hs_err_pid%p.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## JDK 8 GC logging</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:+PrintGCDetails</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:+PrintGCDateStamps</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:+PrintGCApplicationStoppedTime</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-Xloggc:logs/gc.log</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:+UseGCLogFileRotation</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:NumberOfGCLogFiles=32</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">-XX:GCLogFileSize=64m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JDK 9+ GC logging</span></span><br><span class="line"><span class="meta">9-</span>:<span class="string">-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m</span></span><br></pre></td></tr></table></figure>

<h3 id="kibana-yml"><a href="#kibana-yml" class="headerlink" title="kibana.yml"></a>kibana.yml</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ** THIS IS AN AUTO-GENERATED FILE **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default Kibana configuration for docker target</span></span><br><span class="line"><span class="attr">server.name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"0"</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">[</span> <span class="string">"http://elasticsearch:9200"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<h3 id="elastic-stack-ca-p12"><a href="#elastic-stack-ca-p12" class="headerlink" title="elastic-stack-ca.p12"></a>elastic-stack-ca.p12</h3><p>证书需要先生成，如果是使用基础版可以先生成一个，然后复制到宿主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动一个容器</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-</span><br><span class="line">node" elasticsearch:7.7.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成证书</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 会提示输入希望证书的输出路径，直接回车就行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置证书密码，建议不设置，直接回车</span></span><br><span class="line">./bin/elasticsearch-certutil ca</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制证书到宿主机，注意：这条命令需要再宿主机执行</span></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/elastic-stack-ca.p12 /usr/es_kibana</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查证书已复制到相应目录就删除该容器</span></span><br><span class="line">docker rm -f elasticsearch</span><br></pre></td></tr></table></figure>

<img src="/2020/05/18/ELK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6.png" class="生成证书">

<h3 id="log4j2-properties"><a href="#log4j2-properties" class="headerlink" title="log4j2.properties"></a>log4j2.properties</h3><p>有需要可以下载</p>
<a href="/2020/05/18/ELK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/log4j2.properties" title="下载log4j2.properties">下载log4j2.properties</a>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>先创建目录/usr/es_kibana/es01/config</p>
<p>然后把修改后的elasticsearch.yml、jvm.options放入config目录中</p>
<p>目录结构如下</p>
<p>/usr/es_kibana:</p>
<ol>
<li>node01/conf<ol>
<li>elasticsearch.yml</li>
<li>jvm.options</li>
</ol>
</li>
<li>node02/conf<ol>
<li>elasticsearch.yml</li>
<li>jvm.options</li>
</ol>
</li>
<li>node03/conf<ol>
<li>elasticsearch.yml</li>
<li>jvm.options</li>
</ol>
</li>
<li>kibana.yml</li>
<li>elastic-stack-ca.p12</li>
<li>docker-compose.yml</li>
</ol>
<p>然后docker-compose up -d启动</p>
<p>此时，再进入主节点，如设置密码，然后docker-compose down，docker-compose up -d重启服务</p>
<h3 id="elasticsearch-yml-1"><a href="#elasticsearch-yml-1" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster.name: "docker-cluster"</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: "*"</span><br><span class="line">http.cors.allow-headers: "*"</span><br><span class="line"></span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate </span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-stack-ca.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-stack-ca.p12</span><br></pre></td></tr></table></figure>

<h3 id="jvm-options-1"><a href="#jvm-options-1" class="headerlink" title="jvm.options"></a>jvm.options</h3><p>可以修改内存占用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># JVM configuration</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># IMPORTANT: JVM heap size</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># You should always set the min and max JVM heap</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># size to the same value. For example, to set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># the heap to 4 GB, set:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -Xms4g</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -Xmx4g</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># for more information</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Xms represents the initial size of total heap space</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Xmx represents the maximum size of total heap space</span></span><br><span class="line"></span><br><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Expert settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># All settings below this section are considered</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># expert settings. Don't tamper with them unless</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># you understand what you are doing</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># GC configuration</span></span></span><br><span class="line">8-13:-XX:+UseConcMarkSweepGC</span><br><span class="line">8-13:-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">8-13:-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># G1GC Configuration</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NOTE: G1 GC is only supported on JDK version 10 or later</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to use G1GC, uncomment the next two lines and update the version on the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> following three lines to your version of the JDK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10-13:-XX:-UseConcMarkSweepGC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10-13:-XX:-UseCMSInitiatingOccupancyOnly</span></span><br><span class="line">14-:-XX:+UseG1GC</span><br><span class="line">14-:-XX:G1ReservePercent=25</span><br><span class="line">14-:-XX:InitiatingHeapOccupancyPercent=30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># JVM temporary directory</span></span></span><br><span class="line">-Djava.io.tmpdir=$&#123;ES_TMPDIR&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># heap dumps</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> generate a heap dump when an allocation from the Java heap fails</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> heap dumps are created <span class="keyword">in</span> the working directory of the JVM</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> specify an alternative path <span class="keyword">for</span> heap dumps; ensure the directory exists and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> has sufficient space</span></span><br><span class="line">-XX:HeapDumpPath=data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> specify an alternative path <span class="keyword">for</span> JVM fatal error logs</span></span><br><span class="line">-XX:ErrorFile=logs/hs_err_pid%p.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># JDK 8 GC logging</span></span></span><br><span class="line">8:-XX:+PrintGCDetails</span><br><span class="line">8:-XX:+PrintGCDateStamps</span><br><span class="line">8:-XX:+PrintTenuringDistribution</span><br><span class="line">8:-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">8:-Xloggc:logs/gc.log</span><br><span class="line">8:-XX:+UseGCLogFileRotation</span><br><span class="line">8:-XX:NumberOfGCLogFiles=32</span><br><span class="line">8:-XX:GCLogFileSize=64m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JDK 9+ GC logging</span></span><br><span class="line">9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m</span><br></pre></td></tr></table></figure>

<h3 id="kibana-yml-1"><a href="#kibana-yml-1" class="headerlink" title="kibana.yml"></a>kibana.yml</h3><p><strong>elasticsearch.username、elasticsearch.password</strong> 可以等配置完x-pack密码再设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ** THIS IS AN AUTO-GENERATED FILE **</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default Kibana configuration <span class="keyword">for</span> docker target</span></span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: "0"</span><br><span class="line">elasticsearch.hosts: [ "http://es01:9200"]</span><br><span class="line"></span><br><span class="line">elasticsearch.username: elastic</span><br><span class="line">elasticsearch.password: "elastic20200518"</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node01/data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node01/logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node01/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node01/config/jvm.options:/usr/share/elasticsearch/config/jvm.options</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elastic-stack-ca.p12:/usr/share/elasticsearch/config/elastic-stack-ca.p12</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9201</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9301</span><span class="string">:9300</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node02/data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node02/logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node02/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node02/config/jvm.options:/usr/share/elasticsearch/config/jvm.options</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elastic-stack-ca.p12:/usr/share/elasticsearch/config/elastic-stack-ca.p12</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node03/data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node03/logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node03/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node03/config/jvm.options:/usr/share/elasticsearch/config/jvm.options</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elastic-stack-ca.p12:/usr/share/elasticsearch/config/elastic-stack-ca.p12</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:7.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_NAME=kibana</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTICSEARCH_HOSTS=http://es01:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">I18N_LOCALE=zh-CN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">XPACK_MONITORING_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es03</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-x-pack密码"><a href="#配置-x-pack密码" class="headerlink" title="配置 x-pack密码"></a>配置 x-pack密码</h3><p>先进入容器再设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it es01 /bin/bash</span><br><span class="line">bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure>

<h2 id="真分布式环境搭建"><a href="#真分布式环境搭建" class="headerlink" title="真分布式环境搭建"></a>真分布式环境搭建</h2><p>ElasticSearch版本：7.9.2</p>
<p>Kibana版本：7.9.2</p>
<p>服务器列表：</p>
<ol>
<li>10.86.52.74</li>
<li>10.86.52.77</li>
<li>10.82.193.157</li>
</ol>
<h3 id="docker-compose-yml-1"><a href="#docker-compose-yml-1" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>可参考官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docker.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docker.html</a></p>
<h4 id="10-86-52-74"><a href="#10-86-52-74" class="headerlink" title="10.86.52.74"></a>10.86.52.74</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.9.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms2g -Xmx2g"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li>配置bootstrap.memory_lock=true，可以锁定物理内存地址，防止es内存被交换出去，也就是避免es使用swap交换分区，频繁的交换，会导致IOPS变高。</li>
<li>配置TAKE_FILE_OWNERSHIP=true，可以解决volumes挂载权限问题。</li>
</ul>
<h4 id="10-86-52-77"><a href="#10-86-52-77" class="headerlink" title="10.86.52.77"></a>10.86.52.77</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.9.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms2g -Xmx2g"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br></pre></td></tr></table></figure>

<h4 id="10-82-193-157"><a href="#10-82-193-157" class="headerlink" title="10.82.193.157"></a>10.82.193.157</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.9.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms2g -Xmx2g"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br></pre></td></tr></table></figure>

<h3 id="elasticsearch-yml-2"><a href="#elasticsearch-yml-2" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><p>创建elasticsearch.yml文件，添加如下内容：</p>
<h4 id="10-86-52-74-1"><a href="#10-86-52-74-1" class="headerlink" title="10.86.52.74"></a>10.86.52.74</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">"es-cluster"</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">es01</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">110.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br></pre></td></tr></table></figure>

<h4 id="10-86-52-77-1"><a href="#10-86-52-77-1" class="headerlink" title="10.86.52.77"></a>10.86.52.77</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">"es-cluster"</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">es02</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">110.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br></pre></td></tr></table></figure>

<h4 id="10-82-193-157-1"><a href="#10-82-193-157-1" class="headerlink" title="10.82.193.157"></a>10.82.193.157</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">"es-cluster"</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">es03</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">110.86</span><span class="number">.52</span><span class="number">.74</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.86</span><span class="number">.52</span><span class="number">.77</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.82</span><span class="number">.193</span><span class="number">.157</span></span><br></pre></td></tr></table></figure>

<h3 id="启动和验证"><a href="#启动和验证" class="headerlink" title="启动和验证"></a>启动和验证</h3><p>使用docker-compose up -d 分别启动，然后输入<a href="http://10.86.52.74:9200/_cat/nodes?v&amp;pretty" target="_blank" rel="noopener">http://10.86.52.74:9200/_cat/nodes?v&amp;pretty</a> 查看是否成功</p>
<img src="/2020/05/18/ELK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%AA%8C%E8%AF%81.png" class="" title="验证">

<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h4 id="docker-compose-yml-2"><a href="#docker-compose-yml-2" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:7.9.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_NAME=kibana</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br></pre></td></tr></table></figure>

<h4 id="kibana-yml-2"><a href="#kibana-yml-2" class="headerlink" title="kibana.yml"></a>kibana.yml</h4><p>创建kibana.yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ** THIS IS AN AUTO-GENERATED FILE **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default Kibana configuration for docker target</span></span><br><span class="line"><span class="attr">server.name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"0"</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://10.86.52.74:9200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://10.86.52.77:9200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://10.82.193.157:9200</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>项目地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>选择和ES版本对应的ik分词器下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择和ES版本对应的ik分词器下载</span></span><br><span class="line">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.2/elasticsearch-analysis-ik-7.9.2.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">unzip -d ./ik elasticsearch-analysis-ik-7.9.2.zip</span><br></pre></td></tr></table></figure>

<p>映射主机文件到容器中，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.9.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms2g -Xmx2g"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TAKE_FILE_OWNERSHIP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ik:/usr/share/elasticsearch/plugins/ik</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br></pre></td></tr></table></figure>

<p>然后重启即可</p>
<h4 id="测试分词效果"><a href="#测试分词效果" class="headerlink" title="测试分词效果"></a>测试分词效果</h4><h5 id="默认分词器"><a href="#默认分词器" class="headerlink" title="默认分词器"></a>默认分词器</h5><p>POST <a href="http://10.86.52.74:9200/_analyze" target="_blank" rel="noopener">http://10.86.52.74:9200/_analyze</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"我是中国人"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"我"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"&lt;IDEOGRAPHIC&gt;"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"是"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"&lt;IDEOGRAPHIC&gt;"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"中"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"&lt;IDEOGRAPHIC&gt;"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"国"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"&lt;IDEOGRAPHIC&gt;"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"人"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"&lt;IDEOGRAPHIC&gt;"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ik分词器-smart模式"><a href="#ik分词器-smart模式" class="headerlink" title="ik分词器 smart模式"></a>ik分词器 smart模式</h5><p>POST <a href="http://10.86.52.74:9200/_analyze" target="_blank" rel="noopener">http://10.86.52.74:9200/_analyze</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_smart"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"我是中国人"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"我"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"是"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"中国人"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ik分词器-max-word模式"><a href="#ik分词器-max-word模式" class="headerlink" title="ik分词器 max_word模式"></a>ik分词器 max_word模式</h5><p>POST <a href="http://10.86.52.74:9200/_analyze" target="_blank" rel="noopener">http://10.86.52.74:9200/_analyze</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"我是中国人"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"我"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"是"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"中国人"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"中国"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"国人"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ol>
<li><p><strong>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</strong></p>
<p>修改配置sysctl.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改sysctl.conf，添加配置 vm.max_map_count=655360</span></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使其生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<p>然后重新启动elasticsearch</p>
</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>ElasticSearch</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase集群搭建</title>
    <url>/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol>
<li>Zookeeper已安装并启动</li>
<li>HDFS已启动（YARN可不启动）</li>
</ol>
<a id="more"></a>

<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul>
<li>操作系统： CentOS 7</li>
<li>Hadoop版本： Hadoop 3.2.1</li>
<li>Zookeeper版本： Zookeeper3.4.14</li>
<li>HBase版本： hbase-2.3.0</li>
</ul>
<h2 id="下载、解压"><a href="#下载、解压" class="headerlink" title="下载、解压"></a>下载、解压</h2><p>下载HBase安装包<code>hbase-2.3.0-bin.tar.gz</code>并上传至服务器</p>
<p>注意选择与Hadoop对应的Hbase版本，具体可参考：<a href="http://hbase.apache.org/book.html#hadoop" target="_blank" rel="noopener">http://hbase.apache.org/book.html#hadoop</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf hbase-2.3.0-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群所有全部解压可使用pdsh -a</span></span><br><span class="line">pdsh -a tar -zxvf /opt/hbase-2.3.0-bin.tar.gz  -C /opt</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置hbase-env-sh"><a href="#配置hbase-env-sh" class="headerlink" title="配置hbase-env.sh"></a>配置hbase-env.sh</h3><p>末尾添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>

<p>复制配置文件到其他集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a hbase-env.sh /opt/hbase-2.3.0/conf/</span><br></pre></td></tr></table></figure>

<h3 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置/etc/profile"></a>配置/etc/profile</h3><p>编辑，<code>vim /etc/profile</code>，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hbase environment</span></span><br><span class="line">export HBASE_HOME=/opt/hbase-2.3.0/</span><br><span class="line">export PATH=$PATH:$HBASE_HOME/bin</span><br><span class="line">export PATH=$PATH:$HBASE_HOME/sbin</span><br></pre></td></tr></table></figure>

<p>复制配置文件到其他集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /etc/profile /etc</span><br></pre></td></tr></table></figure>

<p>使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">pdsh -a source /etc/profile</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $HBASE_HOME</span><br><span class="line">pdsh -a echo $HBASE_HOME</span><br></pre></td></tr></table></figure>

<h3 id="配置hbase-site-xml"><a href="#配置hbase-site-xml" class="headerlink" title="配置hbase-site.xml"></a>配置hbase-site.xml</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">        &lt;!-- hadoop引入JQM负载均衡时，这里配置dfs.nameservices指定的集群逻辑名称 --&gt;</span><br><span class="line">        &lt;value&gt;hdfs://mycluster/hbase&lt;/value&gt;</span><br><span class="line">        &lt;!-- 指定Hadoop master服务器的写法，hbase监听hdfs默认的端口是9000，这里的配置端口只能写9000 --&gt;</span><br><span class="line">        &lt;!--&lt;value&gt;hdfs://hadoop.master01:9820/hbase&lt;/value&gt;--&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 开启集群模式 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;./tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 解决启动HMaster无法初始化WAL的问题 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 指定HBase Master web页面访问端口，默认端口号16010 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.master.info.port&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;16010&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 指定HBase RegionServer web页面访问端口，默认端口号16030 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.regionserver.info.port&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;16030&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 指定zookeeper集群，有多个用英文逗号分隔 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>复制配置文件到其他集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /opt/hbase-2.3.0/conf/hbase-site.xml /opt/hbase-2.3.0/conf/</span><br></pre></td></tr></table></figure>

<h3 id="配置regionservers"><a href="#配置regionservers" class="headerlink" title="配置regionservers"></a>配置regionservers</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>

<p>复制配置文件到其他集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /opt/hbase-2.3.0/conf/regionservers /opt/hbase-2.3.0/conf/</span><br></pre></td></tr></table></figure>

<h3 id="复制HDFS配置文件"><a href="#复制HDFS配置文件" class="headerlink" title="复制HDFS配置文件"></a>复制HDFS配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /opt/hadoop-3.2.1/etc/hadoop/core-site.xml /opt/hbase-2.3.0/conf/core-site.xml</span><br><span class="line">cp /opt/hadoop-3.2.1/etc/hadoop/hdfs-site.xml /opt/hbase-2.3.0/conf/hdfs-site.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/core-site.xml /opt/hbase-2.3.0/conf/core-site.xml</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/hdfs-site.xml /opt/hbase-2.3.0/conf/hdfs-site.xml</span><br></pre></td></tr></table></figure>

<h3 id="配置HMaster高可用"><a href="#配置HMaster高可用" class="headerlink" title="配置HMaster高可用"></a>配置HMaster高可用</h3><p>在conf目录下创建backup-masters文件，添加以下内容（代表master、slave1两个节点启动HMaster）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br></pre></td></tr></table></figure>

<p>复制配置文件到其他集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /opt/hbase-2.3.0/conf/backup-masters /opt/hbase-2.3.0/conf/backup-masters</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/start-hbase.sh</span><br></pre></td></tr></table></figure>

<p>然后三台服务器分别执行jps，查看进程</p>
<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_jps.png" class="" title="master_jps">

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_jps.png" class="" title="slave1_jps">

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave2_jps.png" class="" title="slave2_jps">

<p>从上面可以看出，<strong>HMaster和HRegionServer正好与backup-masters和regionservers对应</strong></p>
<p>查看HMasterWeb的Web页面</p>
<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_hmaster_web.png" class="" title="master_hmaster_web">

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_hmaster_web.png" class="" title="slave1_hmaster_web">

<p>从上面可以看出，<strong>当前hmaster的主节点（active）在master节点上</strong></p>
<p>查看HRegionServer的Web页面</p>
<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_hregionserver_web.png" class="" title="master_hregionserver_web">

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_hregionserver_web.png" class="" title="slave1_hregionserver_web">

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave2_hregionserver_web.png" class="" title="slave2_hregionserver_web">

<h2 id="验证高可用"><a href="#验证高可用" class="headerlink" title="验证高可用"></a>验证高可用</h2><p>上面看到HMaster在master节点上，所以在master节点上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 32803</span><br></pre></td></tr></table></figure>

<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_hmaster_web_2.png" class="" title="slave1_hmaster_web_2">

<p>从上面可以看出，<strong>杀掉master节点上的hmaster之后，slave1节点上的hmaster变成了主节点</strong></p>
<p>重启master节点上的hmaster节点<code>bin/hbase-daemon.sh start master</code>后</p>
<img src="/2020/07/17/HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_hmaster_web_2.png" class="" title="master_hmaster_web_2">

<p>从上面可以看出，<strong>master节点上的hmaster重启后，变成了从节点</strong></p>
<h2 id="启动-关闭"><a href="#启动-关闭" class="headerlink" title="启动/关闭"></a>启动/关闭</h2><h3 id="启动-关闭集群"><a href="#启动-关闭集群" class="headerlink" title="启动/关闭集群"></a>启动/关闭集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/start-hbase.sh</span><br><span class="line">bin/stop-hbase.sh</span><br></pre></td></tr></table></figure>

<h3 id="启动-关闭单点"><a href="#启动-关闭单点" class="headerlink" title="启动/关闭单点"></a>启动/关闭单点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hbase-daemon.sh start master</span><br><span class="line">bin/hbase-daemon.sh stop master</span><br><span class="line">bin/hbase-daemon.sh start regionserver</span><br><span class="line">bin/hbase-daemon.sh stop regionserver</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建</title>
    <url>/2017/03/19/Hexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架</p>
<a id="more"></a>

<h2 id="自定义列表样式"><a href="#自定义列表样式" class="headerlink" title="自定义列表样式"></a>自定义列表样式</h2><p>以 <code>next</code> 主题为例，修改文件 <code>themes\next\source\css\_common\components\post\post-expand.styl</code></p>
<p>添加如下样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">list-style-type</span>: disc;</span><br><span class="line">  <span class="attribute">margin-block-start</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin-block-end</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin-inline-start</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-inline-end</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">padding-inline-start</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">list-style-type</span>: disc;</span><br><span class="line">  <span class="attribute">margin-block-start</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin-block-end</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin-inline-start</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-inline-end</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">padding-inline-start</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123; </span><br><span class="line">  <span class="attribute">list-style-type</span>: circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="腾讯公益404"><a href="#腾讯公益404" class="headerlink" title="腾讯公益404"></a>腾讯公益404</h2><p>新建 404.html 页面，放到主题的 <code>source</code> 目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://qzone.qq.com/gy/404/style/404style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/plain"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">homePageName</span>=<span class="string">"回到我的主页"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Next-主题配置"><a href="#Next-主题配置" class="headerlink" title="Next 主题配置"></a>Next 主题配置</h2><p><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Next 主题配置</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop3集群搭建</title>
    <url>/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>相关安装包准备：</p>
<ul>
<li><code>hadoop-3.2.1.tar.gz</code></li>
<li><code>pdsh-2.26.tar.bz2</code></li>
<li><code>jdk-8u231-linux-x64.tar.gz</code></li>
</ul>
<a id="more"></a>

<h2 id="虚拟机环境准备"><a href="#虚拟机环境准备" class="headerlink" title="虚拟机环境准备"></a>虚拟机环境准备</h2><ol>
<li><p><strong>准备3台客户机</strong>，使用VMWare创建一台虚拟机后可以使用<strong>克隆</strong>功能</p>
</li>
<li><p>分别修改三台虚拟机的ip，建议<strong>设置静态ip</strong></p>
<p>修改网卡配置：<code>vim /etc/sysconfig/network-scriptsif/cfg-ens33</code>，如下：</p>
<ol>
<li><p>修改<code>BOOTPROTO=static</code></p>
</li>
<li><p>修改<code>ONBOOT=yes</code></p>
</li>
<li><p>配置IP地址、子网掩码、网关、dns服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只需修改IPADDR即可，三台服务器设置不同的ip地址，建议分别设置为100、101、102</span></span><br><span class="line">IPADDR=192.168.3.100</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.3.1</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=114.114.114.114</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启配置<code>systemctl restart network</code></p>
</li>
<li><p>执行<code>ifconfig</code>查看ip地址是否已经成功修改为<code>192.168.3.100</code>,<code>192.168.3.101</code>,<code>192.168.3.102</code></p>
</li>
</ol>
</li>
<li><p>修改主机名<code>/etc/hosts</code></p>
<p>三台虚拟机分别加入如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.3.100 master</span><br><span class="line">192.168.3.101 slave1</span><br><span class="line">192.168.3.102 slave2</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时时间同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装同步工具</span></span><br><span class="line">sudo yum -y install ntp ntpdate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置时间同步</span></span><br><span class="line">sudo ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将系统时间写入硬件时间</span></span><br><span class="line">sudo hwclock --systohc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统时间</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure>

<p><strong>添加定时任务，每隔十分钟同步一次</strong>，<code>crontab -e</code>添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/10 * * * * ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传相关安装包到/opt目录下（三台都需上传）</p>
</li>
<li><p>安装ssh、pdsh（建议三台都安装。ssh三台必须都安装，pdsh可只安装在需要批量执行命令的服务器）</p>
<p>一般ssh默认已安装，查看是否运行<code>systemctl status sshd</code>，这里只需安装pdsh，安装步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">tar -jxvf pdsh-2.26.tar.bz2</span><br><span class="line">cd pdsh-2.26</span><br><span class="line">./configure \</span><br><span class="line">--without-rsh \</span><br><span class="line">--with-ssh \</span><br><span class="line">--with-machines=/etc/pdsh/machines \</span><br><span class="line">--with-dshgroups \</span><br><span class="line">--with-netgroup \</span><br><span class="line">--with-timeout=10</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>检查是否默认使用ssh：<code>pdsh -V</code>，如果不是，自行百度设置</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/pdsh.png" class="" title="pdsh">

<p>设置pdsh主机：<code>vim /etc/pdsh/machines</code>，加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
</li>
<li><p>免密码登录，相关命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三台都需执行</span></span><br><span class="line">ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> 免密码登录自身，(首次需输入yes)</span></span><br><span class="line">ssh localhost</span><br><span class="line"><span class="meta">#</span><span class="bash"> 免密码登录其他机器，三台都需要执行</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试</span></span><br><span class="line">ssh master</span><br><span class="line">ssh slave1</span><br><span class="line">ssh slave2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出登录</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙，相关命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙状态</span></span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止开机自启用</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装jdk，可借助pdsh执行部分操作，例如：<code>pdsh -a &quot;cd /usr/local &amp;&amp; tar -zxvf jdk-8u231-linux-x64.tar.gz&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd /usr/local </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf jdk-8u231-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在末尾添加，JAVA_HOME根据实际情况修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> java environment</span></span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_home/bin:$PATH</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使配置文件生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3><p>借助pdsh执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdsh -a "cd /opt &amp;&amp; tar -zxvf /opt/hadoop-3.2.1.tar.gz"</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/profile</code>，末尾添加（三台都需添加）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hadoop environment</span></span><br><span class="line">export HADOOP_HOME=/opt/hadoop-3.2.1</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<p><strong>检查是否安装成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure>

<h3 id="集群部署规划"><a href="#集群部署规划" class="headerlink" title="集群部署规划"></a>集群部署规划</h3><table>
<thead>
<tr>
<th></th>
<th>master</th>
<th>slave1</th>
<th>slave2</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>DataNode、NameNode</td>
<td>DataNode</td>
<td>DataNode、SecondaryNameNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>NodeManager、ResourceManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p><strong>下面只需配置一台服务器，后续复制文件内容到其他服务器即可</strong></p>
<h4 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h4><p>配置core-site.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定HDFS中NameNode的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop-3.2.1/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="HDFS配置文件"><a href="#HDFS配置文件" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h4><p>配置hadoop-env.sh，末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">export HDFS_NAMENODE_USER="root"</span><br><span class="line">export HDFS_DATANODE_USER="root"</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER="root"</span><br><span class="line">export YARN_RESOURCEMANAGER_USER="root"</span><br><span class="line">export YARN_NODEMANAGER_USER="root"</span><br></pre></td></tr></table></figure>

<p>配置hdfs-site.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置副本数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定Hadoop辅助名称节点主机配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave2:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="YARN配置文件"><a href="#YARN配置文件" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h4><p>配置yarn-env.sh，末尾加上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br></pre></td></tr></table></figure>

<p>配置yarn-site.xml，添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="MapReduce配置文件"><a href="#MapReduce配置文件" class="headerlink" title="MapReduce配置文件"></a>MapReduce配置文件</h4><p>配置mapred-env.sh，末尾加上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br></pre></td></tr></table></figure>

<p>配置mapred-site.xml，添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定MR运行在Yarn上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="复制配置文件到其他服务器"><a href="#复制配置文件到其他服务器" class="headerlink" title="复制配置文件到其他服务器"></a>复制配置文件到其他服务器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/core-site.xml /opt/hadoop-3.2.1/etc/hadoop/core-site.xml</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/hadoop-env.sh /opt/hadoop-3.2.1/etc/hadoop/hadoop-env.sh</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/hdfs-site.xml /opt/hadoop-3.2.1/etc/hadoop/hdfs-site.xml</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/yarn-env.sh /opt/hadoop-3.2.1/etc/hadoop/yarn-env.sh</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/yarn-site.xml /opt/hadoop-3.2.1/etc/hadoop/yarn-site.xml</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/mapred-env.sh /opt/hadoop-3.2.1/etc/hadoop/mapred-env.sh</span><br><span class="line">pdcp -a /opt/hadoop-3.2.1/etc/hadoop/mapred-site.xml /opt/hadoop-3.2.1/etc/hadoop/mapred-site.xml</span><br><span class="line"></span><br><span class="line">pdsh -a "source /etc/profile"</span><br></pre></td></tr></table></figure>

<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><h4 id="配置workers"><a href="#配置workers" class="headerlink" title="配置workers"></a>配置workers</h4><p>在masters上/opt/hadoop-3.2.1/etc/hadoop下编辑workers文件，加入所有datanode主机名（在hadoop 2.x中这个文件叫slaves）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>

<p>同步到其他服务器<code>pdcp -a /opt/hadoop-3.2.1/etc/hadoop/workers /opt/hadoop-3.2.1/etc/hadoop/workers</code></p>
<h4 id="格式化并启动NameNode"><a href="#格式化并启动NameNode" class="headerlink" title="格式化并启动NameNode"></a>格式化并启动NameNode</h4><p>如果集群是第一次启动，需要格式化NameNode。（注意：格式化之前，一定要先停止上次启动的所有namenode和datanode进程，然后再删除data和log数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式化namenode(只需在master上执行)</span></span><br><span class="line">hadoop namenode -format</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在启动namenode(只需在master上执行)</span></span><br><span class="line">hdfs --daemon start namenode</span><br></pre></td></tr></table></figure>

<h4 id="启动DFS集群"><a href="#启动DFS集群" class="headerlink" title="启动DFS集群"></a>启动DFS集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动DFS集群(只需在master上执行)</span></span><br><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>此时master状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_dfs.png" class="" title="master_dfs">

<p>此时slave1状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_dfs.png" class="" title="slave1_dfs">

<p>此时slave2状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave2_dfs.png" class="" title="slave2_dfs">

<p>参照集群部署规划，说明DFS集群启动成功</p>
<h4 id="启动YARN集群"><a href="#启动YARN集群" class="headerlink" title="启动YARN集群"></a>启动YARN集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动DFS集群(只需在ResouceManager对应的机器上执行)</span></span><br><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>

<p>此时master状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_yarn.png" class="" title="master_yarn">

<p>此时slave1状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_yarn.png" class="" title="slave1_yarn">

<p>此时slave2状态如下:</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave2_yarn.png" class="" title="slave2_yarn">

<p>参照集群部署规划，说明YARN的<code>NodeManager</code>集群启动成功，<code>ResourceManager</code>需要单独在slave1启动。</p>
<h4 id="查看SecondaryNameNode"><a href="#查看SecondaryNameNode" class="headerlink" title="查看SecondaryNameNode"></a>查看SecondaryNameNode</h4><p>浏览器打开：<a href="http://192.168.3.102:9868，效果如下：">http://192.168.3.102:9868，效果如下：</a></p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/web_SecondaryNameNode.png" class="" title="web_SecondaryNameNode">

<p><strong>这里显示异常</strong>，需要修改<code>/opt/hadoop-3.2.1/share/hadoop/hdfs/webapps/static/dfs-dust.js</code>第61行</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/web_SecondaryNameNode_error.png" class="" title="web_SecondaryNameNode_error">

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Number</span>(v)).toLocaleString();</span><br></pre></td></tr></table></figure>

<p><strong>复制文件到其他服务器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pdcp -a /opt/hadoop-3.2.1/share/hadoop/hdfs/webapps/static/dfs-dust.js /opt/hadoop-3.2.1/share/hadoop/hdfs/webapps/static/dfs-dust.js</span><br></pre></td></tr></table></figure>

<p><strong>清除浏览器缓存后刷新页面</strong>，效果如下：</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/web_SecondaryNameNode_2.png" class="" title="web_SecondaryNameNode_2">

<h4 id="查看NameNode"><a href="#查看NameNode" class="headerlink" title="查看NameNode"></a>查看NameNode</h4><p>浏览器打开：<a href="http://192.168.3.100:9870，效果如下：">http://192.168.3.100:9870，效果如下：</a></p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/web_NameNode.png" class="" title="web_NameNode">

<h3 id="停止集群"><a href="#停止集群" class="headerlink" title="停止集群"></a>停止集群</h3><h4 id="各个服务组件逐一启动-停止"><a href="#各个服务组件逐一启动-停止" class="headerlink" title="各个服务组件逐一启动/停止"></a>各个服务组件逐一启动/停止</h4><ol>
<li><p>分别启动/停止HDFS组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh  start / stop  namenode / datanode / secondarynamenode</span><br></pre></td></tr></table></figure></li>
<li><p>分别启动/停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh  start / stop  resourcemanager / nodemanager</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="各个模块分开启动-停止（配置ssh是前提）"><a href="#各个模块分开启动-停止（配置ssh是前提）" class="headerlink" title="各个模块分开启动/停止（配置ssh是前提）"></a>各个模块分开启动/停止（配置ssh是前提）</h4><p><strong>常用方式，推荐</strong></p>
<ol>
<li><p>整体启动/停止HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh  / stop-dfs.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体启动/停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh / stop-yarn.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="移除hadoop环境"><a href="#移除hadoop环境" class="headerlink" title="移除hadoop环境"></a>移除hadoop环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /opt/hadoop-3.2.1/data</span><br><span class="line">rm -rf /opt/hadoop-3.2.1/logs</span><br></pre></td></tr></table></figure>

<h2 id="HA配置"><a href="#HA配置" class="headerlink" title="HA配置"></a>HA配置</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>上面已经准备好了就不用准备了，下面只列出部分HA需要修改的配置文件。</p>
<ol>
<li>修改IP</li>
<li>修改主机名及主机名和IP地址的映射</li>
<li>关闭防火墙</li>
<li>ssh免密登录</li>
<li>安装JDK，配置环境变量等</li>
</ol>
<h3 id="HDFS-HA集群配置"><a href="#HDFS-HA集群配置" class="headerlink" title="HDFS-HA集群配置"></a>HDFS-HA集群配置</h3><h4 id="集群部署规划-1"><a href="#集群部署规划-1" class="headerlink" title="集群部署规划"></a>集群部署规划</h4><table>
<thead>
<tr>
<th>master</th>
<th>slave1</th>
<th>slave2</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td>NameNode</td>
<td></td>
</tr>
<tr>
<td>JournalNode</td>
<td>JournalNode</td>
<td>JournalNode</td>
</tr>
<tr>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>ZK</td>
<td>ZK</td>
<td>ZK</td>
</tr>
<tr>
<td></td>
<td>ResourceManager</td>
<td></td>
</tr>
<tr>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h4 id="ZK集群"><a href="#ZK集群" class="headerlink" title="ZK集群"></a>ZK集群</h4><p>在master、slave1、slave2三个节点上部署Zookeeper，这里使用docker部署。</p>
<h5 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h5><p><strong>master</strong>节点，除了zookeeper之外，还部署了consul和zkui（zookeeper的web管理界面）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">consul:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">qnib/consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8500</span><span class="string">:8500</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DC_NAME=qnib</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RUN_SERVER=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">BOOTSTRAP_CONSUL=true</span></span><br><span class="line">    <span class="attr">dns:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zkui:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zkui</span></span><br><span class="line">    <span class="attr">dns:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">dns_search:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.consul</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">service.consul</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">qnib/zkui</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DC_NAME=qnib</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZKUI_ZK_SERVER=192.168.3.100:2181,192.168.3.101:2181,192.168.3.102:2181</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">consul:consul</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9090</span><span class="string">:9090</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>slave1</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p><strong>slave2</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.102</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><p>进入容器，查看集群状态</p>
<figure class="highlight plain"><figcaption><span>status```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">连接zookeeper</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bin&#x2F;&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<p>或者直接访问zkui：<a href="http://192.168.3.100:9090，查看状态">http://192.168.3.100:9090，查看状态</a></p>
<h4 id="核心配置文件-1"><a href="#核心配置文件-1" class="headerlink" title="核心配置文件"></a>核心配置文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把两个NameNode）的地址组装成一个集群mycluster --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop-3.2.1/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:2181,slave1:2181,slave2:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="HDFS配置文件-1"><a href="#HDFS配置文件-1" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h4><p>配置hadoop-env.sh，修改为：（主要是加入了HDFS_JOURNALNODE_USER、HDFS_ZKFC_USER）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">export HDFS_NAMENODE_USER="root"</span><br><span class="line">export HDFS_DATANODE_USER="root"</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER="root"</span><br><span class="line">export YARN_RESOURCEMANAGER_USER="root"</span><br><span class="line">export YARN_NODEMANAGER_USER="root"</span><br><span class="line">export HDFS_JOURNALNODE_USER="root"</span><br><span class="line">export HDFS_ZKFC_USER="root"</span><br></pre></td></tr></table></figure>

<p><strong>配置hdfs-site.xml文件</strong></p>
<p><strong>注意</strong>，这里加上shell(/bin/true)后，namenode才能实现高可用（active的namenode挂了之后，standby的namenode才会自动成为active）。原因是：standby的namenode只有确定了之前active的namenode此时不为active之后，它才会成为standby，目的是防止发生脑裂，但由于active已经挂了，stanby的namenode无法和他通信，加上此配置后，就会忽略确认过程，直接升级为active。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;</span><br><span class="line">        sshfence</span><br><span class="line">        shell(/bin/true)</span><br><span class="line">    &lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 完全分布式集群名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置副本数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 集群中NameNode节点都有哪些 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.mycluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.mycluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9820<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.mycluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1:9820<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.mycluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.mycluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定NameNode元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://master:8485;slave1:8485;slave2:8485/mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop-3.2.1/journaldata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启NameNode失败自动切换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置失败自动切换实现方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.mycluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置隔离机制，即同一时刻只能有一台服务器对外响应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">        	sshfence</span><br><span class="line">            shell(/bin/true)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用sshfence隔离机制时需要ssh免登陆 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置sshfence隔离机制超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.connect-timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="启动集群-1"><a href="#启动集群-1" class="headerlink" title="启动集群"></a>启动集群</h4><ol>
<li><p>先确保zookeeper集群已成功启动</p>
</li>
<li><p>分别在master、slave1、slave2上执行：<code>hdfs --daemon start journalnode</code></p>
</li>
<li><p>格式化namenode，在master上执行<code>hdfs namenode -format</code></p>
</li>
<li><p>在master上执行<code>hdfs --daemon start namenode</code>，启动成功后再slave1上执行<code>hdfs namenode -bootstrapStandby</code></p>
</li>
<li><p>在master上执行<code>hdfs zkfc -formatZK</code>，格式化ZKFC</p>
<p>连接zookeeper可以查看</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/zk_hadoop_mycluster.png" class="" title="zk_hadoop_mycluster">
</li>
<li><p>启动HDFS集群<code>start-dfs.sh</code>（只需在master上执行），效果如下：</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_1.png" class="" title="master_1">

<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_1.png" class="" title="slave1_1">

<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave2_1.png" class="" title="slave2_1">
</li>
<li><p>分别访问<a href="http://master:9870、http://slave1:9870，效果如下：">http://master:9870、http://slave1:9870，效果如下：</a></p>
<p><strong>master是active状态，slaves是standby状态</strong>，由图可知slave1上的nn是master</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_2.png" class="" title="master_2">

<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_2.png" class="" title="slave1_2">

</li>
</ol>
<h4 id="验证高可用"><a href="#验证高可用" class="headerlink" title="验证高可用"></a>验证高可用</h4><p>在slave1上使用jps查看namenode进程，然后kill -9 杀掉namenode进程</p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/slave1_3.png" class="" title="slave1_3">

<p>然后再访问<a href="http://master:9870，此时它已升级为master，如果这一步没能升级，请检查```hdfs-site.xml```配置">http://master:9870，此时它已升级为master，如果这一步没能升级，请检查```hdfs-site.xml```配置</a></p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_3.png" class="" title="master_3">

<p>如果隔离机制没有配置<code>shell(/bin/true)</code>，推荐kill -9 杀掉DFSZKFailoverController进程，这个时候Standby也能变为active，因为namenode还活着，可以确认他没有获取到锁（即杀掉zkfc后，active会变成standby）。</p>
<h3 id="YARN-HA集群配置"><a href="#YARN-HA集群配置" class="headerlink" title="YARN-HA集群配置"></a>YARN-HA集群配置</h3><p>YARN-HA工作机制：<a href="http://hadoop.apache.org/docs/r3.2.1/hadoop-yarn/hadoop-yarn-site/ResourceManagerHA.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r3.2.1/hadoop-yarn/hadoop-yarn-site/ResourceManagerHA.html</a></p>
<h4 id="集群部署规划-2"><a href="#集群部署规划-2" class="headerlink" title="集群部署规划"></a>集群部署规划</h4><table>
<thead>
<tr>
<th>master</th>
<th>slave1</th>
<th>slave2</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td>NameNode</td>
<td></td>
</tr>
<tr>
<td>JournalNode</td>
<td>JournalNode</td>
<td>JournalNode</td>
</tr>
<tr>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>ZK</td>
<td>ZK</td>
<td>ZK</td>
</tr>
<tr>
<td>ResourceManager</td>
<td>ResourceManager</td>
<td></td>
</tr>
<tr>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h4 id="YARN配置文件-1"><a href="#YARN配置文件-1" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h4><p>检查hadoop-env.sh是否存在<code>YARN_RESOURCEMANAGER_USER</code>，<code>YARN_NODEMANAGER_USER</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_231</span><br><span class="line">export HDFS_NAMENODE_USER="root"</span><br><span class="line">export HDFS_DATANODE_USER="root"</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER="root"</span><br><span class="line">export YARN_RESOURCEMANAGER_USER="root"</span><br><span class="line">export YARN_NODEMANAGER_USER="root"</span><br><span class="line">export HDFS_JOURNALNODE_USER="root"</span><br><span class="line">export HDFS_ZKFC_USER="root"</span><br></pre></td></tr></table></figure>

<p><strong>yarn-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启用resourcemanager ha--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--声明两台resourcemanager的地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarncluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>slave1:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:2181,slave1:2181,slave2:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启用自动恢复--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.recovery.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--指定resourcemanager的状态信息存储在zookeeper集群--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.store.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     		 <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.application.classpath<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop-3.2.1/etc/hadoop:/opt/hadoop-3.2.1/share/hadoop/common/lib/*:/opt/hadoop-3.2.1/share/hadoop/common/*:/opt/hadoop-3.2.1/share/hadoop/hdfs:/opt/hadoop-3.2.1/share/hadoop/hdfs/lib/*:/opt/hadoop-3.2.1/share/hadoop/hdfs/*:/opt/hadoop-3.2.1/share/hadoop/mapreduce/lib/*:/opt/hadoop-3.2.1/share/hadoop/mapreduce/*:/opt/hadoop-3.2.1/share/hadoop/yarn:/opt/hadoop-3.2.1/share/hadoop/yarn/lib/*:/opt/hadoop-3.2.1/share/hadoop/yarn/*</span><br><span class="line">       <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="启动集群-2"><a href="#启动集群-2" class="headerlink" title="启动集群"></a>启动集群</h4><p>启动之前先确保HDFA-HA已启动</p>
<p>在slave1上执行<code>sbin/start-yarn.sh</code>，如果这里是在master上执行的，那还需要单独去slave1上执行<code>yarn --daemon start resourcemanager</code>。</p>
<p>查看master上的yarn服务状态<code>bin/yarn rmadmin -getServiceState rm1</code></p>
<p>查看slave1上的yarn服务状态<code>bin/yarn rmadmin -getServiceState rm2</code></p>
<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/yarn_status.png" class="" title="yarn_status">

<h4 id="验证高可用-1"><a href="#验证高可用-1" class="headerlink" title="验证高可用"></a>验证高可用</h4><p>停掉slave1上的resourcemanager（因为它是active）,然后查看rm1状态</p>


<img src="/2020/07/01/Hadoop3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/master_4.png" class="" title="master_4">

<p>rm1变为active，说明高可用验证成功</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>推荐分别群启HDFS、YARN的方式</p>
<h4 id="全部启动-关闭"><a href="#全部启动-关闭" class="headerlink" title="全部启动/关闭"></a>全部启动/关闭</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure>

<h4 id="群启动-关闭HDFS（包含namenode和datanode）"><a href="#群启动-关闭HDFS（包含namenode和datanode）" class="headerlink" title="群启动/关闭HDFS（包含namenode和datanode）"></a>群启动/关闭HDFS（包含namenode和datanode）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure>

<h4 id="群启动-关闭YARN（包含resourcemanager和nodemanager）"><a href="#群启动-关闭YARN（包含resourcemanager和nodemanager）" class="headerlink" title="群启动/关闭YARN（包含resourcemanager和nodemanager）"></a>群启动/关闭YARN（包含resourcemanager和nodemanager）</h4><p>需在包含resoucemanager上的机器启动，否则还需单独再启动resourcemanager（使用<code>yarn --daemon start resoucemanager</code>单独启动）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure>

<h4 id="单独启动namenode和datanode"><a href="#单独启动namenode和datanode" class="headerlink" title="单独启动namenode和datanode"></a>单独启动namenode和datanode</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start namenode</span><br><span class="line">hdfs --daemon stop namenode</span><br><span class="line">hdfs --daemon start datanode</span><br><span class="line">hdfs --daemon stop datanode</span><br></pre></td></tr></table></figure>

<h4 id="单独启动-关闭resourcemanager和nodemanager"><a href="#单独启动-关闭resourcemanager和nodemanager" class="headerlink" title="单独启动/关闭resourcemanager和nodemanager"></a>单独启动/关闭resourcemanager和nodemanager</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --daemon start resourcemanager</span><br><span class="line">yarn --daemon stop resourcemanager</span><br><span class="line">yarn --daemon start nodemanager</span><br><span class="line">yarn --daemon stop nodemanager</span><br></pre></td></tr></table></figure>

<h4 id="单独启动-关闭zkfc"><a href="#单独启动-关闭zkfc" class="headerlink" title="单独启动/关闭zkfc"></a>单独启动/关闭zkfc</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/hadoop-daemon.sh start zkfc</span><br><span class="line">sbin/hadoop-daemon.sh stop zkfc</span><br></pre></td></tr></table></figure>

<h4 id="单独启动-关闭journalnode"><a href="#单独启动-关闭journalnode" class="headerlink" title="单独启动/关闭journalnode"></a>单独启动/关闭journalnode</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start journalnode</span><br><span class="line">hdfs --daemon stop journalnode</span><br></pre></td></tr></table></figure>

<h3 id="端口变动"><a href="#端口变动" class="headerlink" title="端口变动"></a>端口变动</h3><p>从hadoop2到hadoop3端口变动如下：</p>
<ul>
<li>Namenode ports<ul>
<li>50470 –&gt; 9871</li>
<li>50070 –&gt; 9870</li>
<li>8020 –&gt; 9820</li>
</ul>
</li>
<li>Secondary NN ports<ul>
<li>50091 –&gt; 9869,</li>
<li>50090 –&gt; 9868</li>
</ul>
</li>
<li>Datanode ports<ul>
<li>50020 –&gt; 9867</li>
<li>50010 –&gt; 9866</li>
<li>50475 –&gt; 9865</li>
<li>50075 –&gt; 9864</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
        <tag>YARN</tag>
        <tag>HA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA搭建开发环境</title>
    <url>/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><strong>工具善其事，必先利其器</strong></p>
<h2 id="激活篇"><a href="#激活篇" class="headerlink" title="激活篇"></a>激活篇</h2><p>使用<strong>jetbrains-agent-latest.zip</strong>激活，<a href="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/jetbrains-agent-latest.zip" title="下载jetbrains-agent-latest.zip">下载jetbrains-agent-latest.zip</a></p>
<p>详情请看 <a href="https://zhile.io/" target="_blank" rel="noopener">https://zhile.io/</a></p>
<p>推荐使用<strong>Activation code</strong>方式激活，可用于网络不佳或离线环境。</p>
<a id="more"></a>

<h2 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h2><h3 id="设置JDK路径"><a href="#设置JDK路径" class="headerlink" title="设置JDK路径"></a>设置JDK路径</h3><p><strong>configure -&gt; structure for new projects</strong></p>


<h3 id="设置统一编译器和编译版本"><a href="#设置统一编译器和编译版本" class="headerlink" title="设置统一编译器和编译版本"></a>设置统一编译器和编译版本</h3><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BB%9F%E4%B8%80%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC.png" class="" title="统一编译器和编译版本">

<h3 id="设置类注释模板"><a href="#设置类注释模板" class="headerlink" title="设置类注释模板"></a>设置类注释模板</h3><p><strong>Editor -&gt; File and Code Template -&gt; Includes -&gt;  File Header</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jaceding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;DATE&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%B1%BB%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF.png" class="" title="类注释模板">

<h3 id="设置字符编码"><a href="#设置字符编码" class="headerlink" title="设置字符编码"></a>设置字符编码</h3><p><strong>工程设置</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.png" class="" title="字符编码">

<p><strong>控制乱码解决办法</strong></p>
<p> 在对应的VM options加上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<h3 id="设置Ctrl-滚轮缩放文件和图片"><a href="#设置Ctrl-滚轮缩放文件和图片" class="headerlink" title="设置Ctrl + 滚轮缩放文件和图片"></a>设置Ctrl + 滚轮缩放文件和图片</h3><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Ctrl+%E6%BB%9A%E8%BD%AE%E8%B0%83%E8%8A%82%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F.png" class="" title="Ctrl+滚轮调节字体大小">

<h3 id="设置Debug时可进入classes中"><a href="#设置Debug时可进入classes中" class="headerlink" title="设置Debug时可进入classes中"></a>设置Debug时可进入classes中</h3><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Debug%E8%BF%9B%E5%85%A5classes.png" class="" title="Debug进入classes">

<h3 id="设置快捷键自动生成序列化id"><a href="#设置快捷键自动生成序列化id" class="headerlink" title="设置快捷键自动生成序列化id"></a>设置快捷键自动生成序列化id</h3><p><strong>Editor -&gt; Inspections -&gt; 搜索“serialization issues”，选上 Serializable class without ‘serialVersionUID’</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%BA%8F%E5%88%97%E5%8C%96id.png" class="" title="快捷键自动生成序列化id">

<h3 id="设置占用内存大小和查看内存占用"><a href="#设置占用内存大小和查看内存占用" class="headerlink" title="设置占用内存大小和查看内存占用"></a>设置占用内存大小和查看内存占用</h3><p><strong>Xms 是指设定程序启动时占用内存大小</strong></p>
<p><strong>Xmx 是指设定程序运行期间最大可占用的内存大小</strong></p>
<p>测试表明，Xms和Xmx大小一样时效率最佳</p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%AE%BE%E7%BD%AEIDEA%E5%86%85%E5%AD%98.png" class="" title="设置IDEA内存">

<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8.png" class="" title="查看内存占用">

<h3 id="设置Maven"><a href="#设置Maven" class="headerlink" title="设置Maven"></a>设置Maven</h3><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%AE%BE%E7%BD%AEMaven.png" class="" title="设置Maven">

<h3 id="设置查看字节码"><a href="#设置查看字节码" class="headerlink" title="设置查看字节码"></a>设置查看字节码</h3><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%9F%A5%E7%9C%8B%E5%AD%97%E8%8A%82%E7%A0%81.png" class="" title="查看字节码">

<h3 id="启用注解处理（Lombok）"><a href="#启用注解处理（Lombok）" class="headerlink" title="启用注解处理（Lombok）"></a>启用注解处理（Lombok）</h3><p>使用lombok，需要先安装lombok插件，然后启用注解处理。</p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%90%AF%E7%94%A8Lombok.png" class="" title="启用Lombok">

<h3 id="JRebe热部署设置"><a href="#JRebe热部署设置" class="headerlink" title="JRebe热部署设置"></a>JRebe热部署设置</h3><h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA.png" class="" title="自动构建">

<p>破解需要搭建服务：<a href="https://hub.docker.com/r/ilanyu/golang-reverseproxy/" target="_blank" rel="noopener">https://hub.docker.com/r/ilanyu/golang-reverseproxy/</a></p>
<p>破解项目地址：<a href="https://github.com/ilanyu/ReverseProxy" target="_blank" rel="noopener">https://github.com/ilanyu/ReverseProxy</a></p>
<p>破解作者博客：<a href="http://blog.lanyus.com/" target="_blank" rel="noopener">http://blog.lanyus.com/</a></p>
<p>docker-compose部署服务器</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">ip-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ilanyu/golang-reverseproxy</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">golang-reverseproxy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">8082</span><span class="string">:8888</span></span><br></pre></td></tr></table></figure>

<p>激活时，Team URL输入：http://服务器地址:端口/guid，如：<a href="http://120.79.75.96:8082/760d9445-9d4a-4b03-8417-6a832cf68240，邮箱可以随意填写。" target="_blank" rel="noopener">http://120.79.75.96:8082/760d9445-9d4a-4b03-8417-6a832cf68240，邮箱可以随意填写。</a></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/JRebel%E6%BF%80%E6%B4%BB.png" class="" title="JRebel激活">

<p><a href="https://www.guidgen.com/" target="_blank" rel="noopener">在线生成GUID1</a></p>
<p><a href="http://www.ofmonkey.com/transfer/guid" target="_blank" rel="noopener">在线生成GUID2</a></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/JRebel%E8%AE%BE%E7%BD%AE%E7%A6%BB%E7%BA%BF%E5%B7%A5%E4%BD%9C.png" class="" title="JRebel设置离线工作">

<h4 id="设置-compiler-automake-allow-when-app-running"><a href="#设置-compiler-automake-allow-when-app-running" class="headerlink" title="设置 compiler.automake.allow.when.app.running"></a>设置 compiler.automake.allow.when.app.running</h4><p><strong>快捷键： Ctrl+Shift+Alt+/ 点击 Registry 勾选 compiler.automake.allow.when.app.running</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%83%AD%E9%83%A8%E7%BD%B2-1.png" class="" title="热部署-1">

<h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%83%AD%E9%83%A8%E7%BD%B2-2.png" class="" title="热部署-2">

<p><strong>全部选上</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%83%AD%E9%83%A8%E7%BD%B2-3.png" class="" title="热部署-3">

<p><strong>有则需要设置，没有也可不设置</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%83%AD%E9%83%A8%E7%BD%B2-4.png" class="" title="热部署-4">

<p><strong>使用下面的方式启动或者debug</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%83%AD%E9%83%A8%E7%BD%B2-5.png" class="" title="热部署-5">

<h4 id="其他激活方式"><a href="#其他激活方式" class="headerlink" title="其他激活方式"></a>其他激活方式</h4><p>上面的激活方式在内网不可用，可尝试使用其他方式激活，例如：<a href="https://gitee.com/gsls200808/JrebelLicenseServerforJava" target="_blank" rel="noopener">https://gitee.com/gsls200808/JrebelLicenseServerforJava</a></p>
<p>也可直接下载，</p>
<p>运行：java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 18081</p>
<p><strong>激活方式同上</strong></p>
<h3 id="Alibaba-Java-Coding-Guidelines设置"><a href="#Alibaba-Java-Coding-Guidelines设置" class="headerlink" title="Alibaba Java Coding Guidelines设置"></a>Alibaba Java Coding Guidelines设置</h3><h4 id="去掉大括号限制"><a href="#去掉大括号限制" class="headerlink" title="去掉大括号限制"></a>去掉大括号限制</h4><p><strong>setting -&gt; editor -&gt; inspections -&gt; allcheck</strong>，也可以搜索if</p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/allcheck-1.png" class="allcheck-1.png.png">

<h3 id="关闭IDEA自动更新"><a href="#关闭IDEA自动更新" class="headerlink" title="关闭IDEA自动更新"></a>关闭IDEA自动更新</h3><p><strong>Appearance&amp;Behavior-&gt;System Setting-&gt;Updates，也可以直接搜索Updates</strong></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%85%B3%E9%97%ADIDEA%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0.png" class="" title="关闭IDEA自动更新.png">

<h3 id="文件过滤"><a href="#文件过滤" class="headerlink" title="文件过滤"></a>文件过滤</h3><p><strong>Editor-&gt;File Types</strong>，添加<code>*.idea;*.iml;</code></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4.png" class="" title="文件过滤">

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li><p>在官网下载JProfiler安装包进行安装</p>
</li>
<li><p>使用KeyGen.exe进行破解，<a href="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/jprofiler%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7.zip" title="点击下载">点击下载</a></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/jprofiler%E7%A0%B4%E8%A7%A3.png" class="" title="jprofiler破解">
</li>
<li><p>IDEA中安装JProfiler插件</p>
</li>
</ol>
<h3 id="软换行"><a href="#软换行" class="headerlink" title="软换行"></a>软换行</h3><p><strong>Editor-&gt;General</strong>，添加<code>; *.java</code></p>
<img src="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%BD%AF%E6%8D%A2%E8%A1%8C.png" class="" title="软换行">

<h2 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h2><p>推荐直接在IDEA中搜索安装</p>
<ol>
<li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a> 阿里巴巴Java编码指南</li>
<li><a href="https://plugins.jetbrains.com/plugin/6317-lombok" target="_blank" rel="noopener">Lombok</a> 使用注解自动生成代码</li>
<li><a href="https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0" target="_blank" rel="noopener">JUnitGenerator V2.0</a> 快速生成测试代码</li>
<li><a href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x" target="_blank" rel="noopener">Key Promoter X</a> 快捷键提示</li>
<li><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" target="_blank" rel="noopener">Maven Helper</a> 分析和排除冲突依赖关系</li>
<li><a href="https://plugins.jetbrains.com/plugin/7495--ignore" target="_blank" rel="noopener">.ignore</a> 快速生成.ignore</li>
<li><a href="https://plugins.jetbrains.com/plugin/9861-git-commit-template" target="_blank" rel="noopener">Git Commit Template</a> git提交模板</li>
<li><a href="https://plugins.jetbrains.com/plugin/12132-leetcode-editor" target="_blank" rel="noopener">leetcode editor</a> leetcode插件</li>
<li><a href="https://plugins.jetbrains.com/plugin/8579-translation" target="_blank" rel="noopener">Translation</a> 翻译插件</li>
<li><a href="https://plugins.jetbrains.com/plugin/9360-generateallsetter" target="_blank" rel="noopener">GenerateAllSetter</a> 一键生成实体类的set方法</li>
<li><a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit" target="_blank" rel="noopener">RestfulToolkit</a> 根据URL找到controller方法</li>
<li><a href="https://plugins.jetbrains.com/plugin/7125-grep-console" target="_blank" rel="noopener">Grep console</a> 控制台工具</li>
<li><a href="https://plugins.jetbrains.com/plugin/7654-gsonformat" target="_blank" rel="noopener">Gsonformat</a> 快速将JSON字符串转换为实体类</li>
<li><a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation" target="_blank" rel="noopener">String Manipulation</a> 强大的字符串转换工具</li>
<li><a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib Bytecode viewer</a> jclasslib是Java类文件的字节码查看器</li>
<li><a href="https://plugins.jetbrains.com/plugin/7275-codeglance" target="_blank" rel="noopener">CodeGlance</a> 缩略图</li>
<li><a href="https://plugins.jetbrains.com/plugin/8286-sequencediagram" target="_blank" rel="noopener">SequenceDiagram</a> 时序图</li>
<li><a href="https://plugins.jetbrains.com/plugin/13581-arthas-idea" target="_blank" rel="noopener">arthas idea</a> arthas的Idea插件</li>
<li><a href="https://plugins.jetbrains.com/plugin/4509-statistic" target="_blank" rel="noopener">Statistic</a> 项目信息统计</li>
<li><a href="https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij" target="_blank" rel="noopener">JRebel and XRebel for IntelliJ</a><strong>（收费）</strong>热部署</li>
<li><a href="https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro" target="_blank" rel="noopener">MyBatisCodeHelperPro</a><strong>（收费）</strong> mybatis开发必备（安装破解版后输入任意注册码即可破解），<a href="/2020/05/18/IDEA%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/MybatisCodeHelperNew-2.8.1-191-201.zip" title="下载">下载</a></li>
<li><a href="https://plugins.jetbrains.com/plugin/12634-iedis-2" target="_blank" rel="noopener">Iedis 2</a><strong>（收费）</strong> 在JetBrains平台中提供Redis支持</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>热部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-List篇</title>
    <url>/2020/08/03/Java%E9%9B%86%E5%90%88-List%E7%AF%87/</url>
    <content><![CDATA[<p>JDK提供的集合类型主要分为四种类型：</p>
<ol>
<li>List：支持重复元素</li>
<li>Set：不支持重复元素</li>
<li>Map：键/值对的映射集</li>
<li>Queue/Deque（double ended queue）：queue是在集合尾部添加元素，在头部删除元素的队列，deque是可在头部和尾部添加或者删除元素的双端队列，<strong>deque既可以实现队列又可以实现栈</strong>。</li>
</ol>
<a id="more"></a>

<p>本文基于JDK8，java version “1.8.0_251”</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>基于数组，支持随机访问，非线程安全</p>
<ol>
<li><p>实现了RandomAccess接口，支持<strong>随机访问</strong>，查询元素更快，增加元素（非末尾添加）和删除元素比较慢，因为需要移动后面的元素位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * <span class="title">Returns</span> <span class="title">the</span> <span class="title">element</span> <span class="title">at</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">position</span> <span class="title">in</span> <span class="title">this</span> <span class="title">list</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * @<span class="title">param</span>  <span class="title">index</span> <span class="title">index</span> <span class="title">of</span> <span class="title">the</span> <span class="title">element</span> <span class="title">to</span> <span class="title">return</span></span></span><br><span class="line"><span class="class"> * @<span class="title">return</span> <span class="title">the</span> <span class="title">element</span> <span class="title">at</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">position</span> <span class="title">in</span> <span class="title">this</span> <span class="title">list</span></span></span><br><span class="line"><span class="class"> * @<span class="title">throws</span> <span class="title">IndexOutOfBoundsException</span> </span>&#123;<span class="meta">@inheritDoc</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>底层是<strong>数组</strong>，<strong>默认容量10</strong>，<strong>最大容量Integer.MAX_VALUE-8</strong>（2^31 - 8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;	    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment"> * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment"> * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒加载</strong>，使用空参构造方法初始完后，数组容量为0而不是默认容量，添加元素后会扩容至默认容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持<strong>fail-fast</strong>机制，继承了AbstactList抽象类，继承自AbstactList的类每次<strong>调用新增或者删除等修改方法</strong>，属性<strong>modCount都会自增</strong>，当通过Interactor遍历集合时，只要modCount被其他线程修改，就会抛出ConcurrentModificationException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非线程安全</strong>，可以通过<strong>Collections.synchronizedList()</strong>方法把它转成线程安全的集合，不过这样性能不是很高</p>
</li>
<li><p>扩容机制：<strong>扩容为原来的1.5倍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相比LinkedList空间占用更小</p>
</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于双向链表，增加和删除元素快，非线程安全</p>
<ol>
<li><p>实现了Deque接口，表明它是<strong>双向链表</strong>结构的，没有实现RandomAccess接口，所以<strong>不支持随机访问</strong>。增加和删除快，查询和修改元素慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * <span class="title">Returns</span> <span class="title">the</span> <span class="title">element</span> <span class="title">at</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">position</span> <span class="title">in</span> <span class="title">this</span> <span class="title">list</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * @<span class="title">param</span> <span class="title">index</span> <span class="title">index</span> <span class="title">of</span> <span class="title">the</span> <span class="title">element</span> <span class="title">to</span> <span class="title">return</span></span></span><br><span class="line"><span class="class"> * @<span class="title">return</span> <span class="title">the</span> <span class="title">element</span> <span class="title">at</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">position</span> <span class="title">in</span> <span class="title">this</span> <span class="title">list</span></span></span><br><span class="line"><span class="class"> * @<span class="title">throws</span> <span class="title">IndexOutOfBoundsException</span> </span>&#123;<span class="meta">@inheritDoc</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以<strong>用来实现栈</strong>这个数据结构，或者直接把它当成栈来使用，但推荐使用ArrayDeque</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，继承了AbstractSequentialList抽象类，而它又继承了AbstactList抽象类，所以每次<strong>调用新增或者删除等修改方法</strong>，属性<strong>modCount都会自增</strong>，当通过Interactor遍历集合时，只要modCount被其他线程修改，就会抛出ConcurrentModificationException</p>
</li>
<li><p><strong>非线程安全</strong>，可以通过<strong>Collections.synchronizedList()</strong>方法把它转成线程安全的集合，不过这样性能不是很高</p>
</li>
<li><p>由于每个元素包含next和prov指针，所以相比ArrayList空间占用更大</p>
</li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>和ArrayList非常相似，主要不同：Vector是线程安全，ArrayList非线程安全。</p>
<ol>
<li><p>实现了RandomAccess接口，支持<strong>随机访问</strong>，查询元素更快，增加元素（非末尾添加）和删除元素比较慢，因为需要移动后面的元素位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>底层是<strong>数组</strong>，<strong>默认容量10</strong>，<strong>最大容量也是Integer.MAX_VALUE-8</strong>（没有显式定义这点，但是jvm规定数组的最大长度为Integer.MAX_VALUE-8）</p>
</li>
<li><p><strong>无懒加载</strong>，使用空参构造初始化对象后，数组长度为10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector so that its internal data array</span></span><br><span class="line"><span class="comment"> * has size &#123;<span class="doctag">@code</span> 10&#125; and its standard capacity increment is</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持<strong>fail-fast</strong>机制，继承了AbstactList抽象类，继承自AbstactList的类每次<strong>调用新增或者删除等修改方法</strong>，属性<strong>modCount都会自增</strong>，当通过Interactor遍历集合时，只要modCount被其他线程修改，就会抛出ConcurrentModificationException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程安全</strong>，方法使用了<strong>synchronized修饰</strong>保证线程安全，但是效率较低，不推荐使用。</p>
</li>
<li><p>扩容机制：<strong>扩容为原来的2倍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>先进后出，线程安全，效率较低</p>
<ol>
<li>线程安全，继承至Vector，相当于使用Vector的方法实现的栈，但效率较低，建议使用ConcurrentLinkedDeque代替</li>
</ol>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>基于数组，随机访问，线程安全，写时复制，读写分离，内存占用大，弱一致性，适合多读场景</p>
<ol>
<li><p>实现了RandomAccess接口，支持<strong>随机访问</strong>，查询元素更快，增加元素（非末尾添加）和删除元素比较慢，因为需要移动后面的元素位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>底层是<strong>数组</strong>，<strong>默认容量0</strong>，<strong>最大容量Integer.MAX_VALUE-8</strong>（没有显式定义这点，但是jvm规定数组的最大长度为Integer.MAX_VALUE-8）</p>
</li>
<li><p><strong>无懒加载</strong>，默认容量就是0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不支持<strong>fail-fast</strong>机制，没有继承于AbstractList，仅实现了List接口，Iterator实现类中，没有checkForComodification()，更不会抛出ConcurrentModificationException异常！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程安全</strong>。通过volatile和互斥锁来实现。增加、删除、修改操作使用ReenTrantLock实现同时只有一个线程能够获取锁。增加、删除、修改操作都是先复制一个新数组，然后对新操作进行操作，操作完之后再将新数组设置为容器，这种策略叫做<strong>写时复制</strong>，缺点就是<strong>内存占用大</strong>。但是在写入新数组后，将新数组设置为容器之前，执行查询操作，查询的是旧值，这就是<strong>写时复制策略产生的弱一致性问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无扩容机制</strong>，由于每次增加元素都是重新创建新的数组，并且新数组容量为旧数组容量+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么java-util-concurrent包里没有并发的ArrayList实现"><a href="#为什么java-util-concurrent包里没有并发的ArrayList实现" class="headerlink" title="为什么java.util.concurrent包里没有并发的ArrayList实现"></a>为什么java.util.concurrent包里没有并发的ArrayList实现</h3><p>回答：<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的List</strong>，像ConcurrentHashMap这样的类的真正价值并不是它们保证了线程安全。而在于它们在保证线程安全的同时不存在并发瓶颈。</p>
<p>问题在于，像“Array List”这样的数据结构，你不知道如何去规避并发的瓶颈。拿contains() 这样一个操作来说，当你进行搜索的时候如何避免锁住整个list？</p>
<p>另一方面，Queue 和Deque (基于Linked List)有并发的实现是因为他们的接口相比List的接口有更多的限制，这些限制使得实现并发成为可能。</p>
<p>CopyOnWriteArrayList是一个有趣的例子，它规避了只读操作（如get/contains）并发的瓶颈，但是它为了做到这点，在修改操作中做了很多工作和修改可见性规则。 此外，修改操作还会锁住整个List，因此这也是一个并发瓶颈。所以从理论上来说，CopyOnWriteArrayList并不算是一个通用的并发List。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
        <tag>Vector</tag>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>Stack</tag>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-Map篇</title>
    <url>/2020/08/03/Java%E9%9B%86%E5%90%88-Map%E7%AF%87/</url>
    <content><![CDATA[<p>JDK提供的集合类型主要分为四种类型：</p>
<ol>
<li>List：支持重复元素</li>
<li>Set：不支持重复元素</li>
<li>Map：键/值对的映射集</li>
<li>Queue/Deque（double ended queue）：queue是在集合尾部添加元素，在头部删除元素的队列，deque是可在头部和尾部添加或者删除元素的双端队列，<strong>deque既可以实现队列又可以实现栈</strong>。</li>
</ol>
<a id="more"></a>

<p>本文基于JDK8，java version “1.8.0_251”</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>数组+链表/红黑树，非线程安全</p>
<ol>
<li><p>在JDK8之前，hashMap是<strong>数组+链表</strong>的结构，JDK8引入了<strong>红黑树</strong>。当链表元素大于等于8，且table数组长度大于64，链表会转换成红黑树（链表元素个数大于等于8但table数组的长度小于64时，只触发扩容），若红黑树的节点个数小于等于6，树结构还原成链表。因为红黑树的平均查找长度是log_2 n，而链表的平均查找长度是n/2。中间有个差值，可以防止链表和树频繁转换。</p>
</li>
<li><p><strong>默认容量为16，默认负载因子为0.75</strong>，最大容量为2^30</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始容量是16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树化阈值。当添加元素到桶中，如果桶中链表长度被添加到至少8，链表就转换为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表还原阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小数形化容量。桶中链表被转换为红黑树的最小容量是64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>容量总是为2的次幂</strong>（数组索引计算为与运算，i = (n - 1) &amp; hash），在计算机中，  (n - 1) &amp; hash，当n为2次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n，计算更加高效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒加载</strong>，使用空参构造方法初始完后，只是给负载因子赋值，table并没有初始化，执行put方法后，才会将table初始化为默认大小16；且values方法和keySet方法也为懒加载，没有调用values和keySet方法之前，values和keySet为空，调用时才初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态扩容</strong>，当 <strong>元素数量 =  容量*负载因子</strong>时触发扩容，不存在缩容。<strong>新的容量为旧容量的2倍</strong>。然后将原来的Node节点放入新的bucket数组中。这个过程叫作<strong>再散列</strong>，因为它调用hash方法找到新的bucket位置。在JDK8之前，采用的是<strong>头插法</strong>，多个线程发现需要调整hashmap的大小，他们会同时进行rehashing，这样可能<strong>导致链表产生环</strong>，rehashing过程也会死循环，其他线程执行get方法也可能会导致死循环。而JDK8采用<strong>尾插法</strong>，避免了这一点，同时JDK8如果单个链表长度大于8且table数组长度大于64时，链表会转为红黑树，这点也需要计算链表长度，正好一举两得。</p>
</li>
<li><p><strong>非线程安全</strong>，通过<strong>Collections.synchronizedMap()</strong>方法把它转成线程安全的集合，效率较低，推荐使用ConcurrentHashMap。</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，KeyIterator和ValueIterator都继承自HashIterator，而HashIterator的nextNode方法中包含会检查modCount的值，如果modCount != expectedModCount会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许key和value为null</strong>，hash函数做了判空处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>和JDK8之前的HashMap很相似，线程安全</p>
<ol>
<li><p>基于<strong>数组+链表</strong>实现</p>
</li>
<li><p><strong>默认容量为11，默认负载因子为0.75</strong>，显式定义了数组的长度最大为Integer.MAX_VALUE - 8，没有定义节点的最大数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty hashtable with a default initial capacity (11)</span></span><br><span class="line"><span class="comment"> * and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无懒加载</strong>，默认容量就是11</p>
</li>
<li><p><strong>动态扩容</strong>，当 <strong>元素数量 =  容量*负载因子</strong>时触发扩容，不存在缩容。新的容量为旧容量的2倍+1。链表新增元素<strong>采用头插法</strong>，由于put方法使用synchronized修饰，所以不会出现多个线程同时扩容。</p>
</li>
<li><p><strong>线程安全</strong>，get、put、remove等方法均使用synchronized修饰，效率较低，推荐使用ConcurrentHashMap。</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，但是Enumerator无法获取，获取迭代器是私有方法，只能先获取keySet()或values()，再获取iterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">return</span> nextElement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>key和value都不允许为null</strong>，为空会抛出NullPointerException异常</p>
</li>
<li><p>计算数组索引采用<strong>与运算</strong>，(hash &amp; 0x7FFFFFFF) % tab.length，hash &amp; 0x7FFFFFFF的作用是为了得到一个正数。</p>
</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>红黑树结构，有序Map集合，非线程安全,</p>
<ol>
<li><strong>基于红黑树结构的有序Map集合</strong>，元素的顺序基于键的compareTo方法，或者自定义的comparator。</li>
<li>基于红黑树，<strong>无懒加载</strong></li>
<li><strong>非线程安全</strong>，通过<strong>Collections.synchronizedSortedMap()</strong>方法把它转成线程安全的集合，效率较低</li>
<li>支持<strong>fail-fast</strong>机制，如果在创建了Interator后，有其他线程修改了集合导致modCount != expectedModCount则会抛出ConcurrentModificationException异常。</li>
<li>k<strong>ey不允许为null，value允许为null</strong>，key为空会抛出NullPointerException异常</li>
</ol>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><img src="/2020/08/03/Java%E9%9B%86%E5%90%88-Map%E7%AF%87/LinkedHashMap.png" class="" title="LinkedHashMap.png">

<p>继承自HashMap，有序集合，非线程安全，可以用来实现FIFO和LRU缓存淘汰算法</p>
<ol>
<li><p><strong>继承自HashMap的有序集合</strong>，根据初始化参数accessOrder是false还是true来选择是按插入元素时的顺序还是按访问顺序进行排序。<strong>默认accessOrder=false，按插入元素的顺序进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新增双向链表结构</strong>，在HashMap结构的基础上，新增了一个双向链表的结构。重写了HashMap的部分方法，比如<strong>创建Node节</strong>点，会调用linkNodeLast方法，将元素加到链表的尾部；<strong>get方法</strong>，查询到了元素，会根据accessOrder判断，如果为true，会将元素移动到链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒加载</strong>，主要是调用HashMap构造函数，HashMap是懒加载，所以将它也定义为懒加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态扩容</strong>，JDK8之前重写了部分数据迁移的方法transfer（通过遍历双向链表），JDK8直接使用HashMap的扩容机制。从遍历的效率来说，<strong>遍历双向链表的效率要高于遍历table</strong>，因为遍历双向链表是N次（N为元素个数）；而遍历table是N+table的空余个数（N为元素个数）。</p>
</li>
<li><p><strong>非线程安全</strong>，通过<strong>Collections.synchronizedMap()</strong>方法把它转成线程安全的集合，效率较低</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，nextNode方法中会判断modCount值，如果modCount != expectedModCount，则会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许key和value为null</strong>，因为基于HashMap，所以它也允许key和value为null</p>
</li>
</ol>
<p><strong>linkNodeLast</strong></p>
<p>添加一个对象，<strong>创建Node节</strong>点，然后调用linkNodeLast方法，将元素加到链表的尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>afterNodeAccess</strong></p>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>afterNodeInsertion</strong></p>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时（<strong>默认返回false</strong>）会移除最晚的节点，也就是链表首部节点 first。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要实现LRU或者FIFO，首先就需要重写removeEldestEntry()</strong>，当元素容量&gt;缓存容量时，返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> MAX_ENTRIES = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LRU实现思路</strong>：accessOrder设置为true，最新添加的元素在链表的头部，如果一个元素被访问了，这个元素会被移动到链表尾部，链表头部的元素首先被删除。</p>
<p><strong>FIFO实现思路</strong>：accessOrder设置为false，最新添加的元素在链表头，最旧的元素在链表尾，链表头部的元素首先被删除。</p>
<p><strong>LFU实现思路</strong>：使用HashMap，key就是缓存key，value包含缓存value，访问次数，创建时间。查询缓存，修改元素的访问次数；添加缓存，先判断当前缓存容量是否等于最大容量，如果是，则遍历values，找出访问次数最少（次数相同则比较创建时间）的元素并将其移除，然后再添加缓存元素。</p>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2><p>和JDK8之前的HashMap很相似，IdentityHashMap比较的是引用，HashMap是比较equal方法</p>
<ol>
<li><p><strong>基于数组存储</strong>，且key，value是连续存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i] = k;</span><br><span class="line">tab[i + <span class="number">1</span>] = value;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线性探测法</strong>解决hash冲突</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组默认长度为32，既容量为16，默认负载因子为2/3（没有显示定义负载因子，而是在代码中写死）</strong>，最大容量为<strong>1 &lt;&lt; 29</strong>，</p>
</li>
<li><p><strong>容量总是为2的次幂</strong>（数组索引计算为与运算，i = hash &amp; (n - 1) ），在计算机中，  (n - 1) &amp; hash，当n为2次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n，计算更加高效。</p>
</li>
<li><p><strong>无懒加载</strong>，使用空参构造或指定大小都会初始化table数组。</p>
</li>
<li><p><strong>动态扩容</strong>，当 <strong>元素数量 =  容量*负载因子</strong>时触发扩容，不存在缩容。新的容量为旧容量的2倍。扩容之后需要<strong>再散列</strong>。</p>
</li>
<li><p><strong>非线程安全</strong>，通过<strong>Collections.synchronizedMap()</strong>方法把它转成线程安全的集合，效率较低</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，nextNode方法中会判断modCount值，如果modCount != expectedModCount，则会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许key和value为null</strong></p>
</li>
<li><p>key 和 value <strong>比较引用判断是否相等</strong>（HashMap通过equeal方法）</p>
</li>
</ol>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>和HashMap很相似，弱引用，实现缓存（Tomcat中的ConcurrentCache）</p>
<ol>
<li><p>基于<strong>数组+链表</strong>的结构，<strong>默认容量为16，默认负载因子为0.75</strong>，最大容量为2^30。</p>
</li>
<li><p><strong>容量总是为2的次幂</strong>（数组索引计算为与运算，i = (n - 1) &amp; hash），在计算机中，  (n - 1) &amp; hash，当n为2次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n，计算更加高效</p>
</li>
<li><p><strong>无懒加载</strong>，使用空参构造或指定大小都会初始化table数组。</p>
</li>
<li><p><strong>动态扩容</strong>，当 <strong>元素数量 =  容量*负载因子</strong>时触发扩容。<strong>新的容量为旧容量的2倍</strong>。插入和再散列过程采用<strong>头插法</strong>，多个线程执行再散列可能会<strong>导致链表产生环</strong>（和上文HashMap类似）。将元素从旧Map迁移到新表时，若size小于threshold/2，重新将数据从新表迁移到旧表（因为迁移的时候会删除已经被回收的条目：key为null）。</p>
</li>
<li><p><strong>非线程安全</strong>，通过<strong>Collections.synchronizedMap()</strong>方法把它转成线程安全的集合，效率较低。</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，nextNode方法中会判断modCount值，如果modCount != expectedModCount，则会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许key和value为null</strong></p>
</li>
<li><p><strong>Entry继承自WeakReference</strong>，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
</li>
<li><p><strong>expungeStaleEntries方法清除过时的条目</strong>，当key失效时，GC会自动将对应的Entry添加到ReferenceQueue queue中，在调用getTable size resize方法时会调用expungeStaleEntries方法，这些方法会被几乎所有方法调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>线程安全的HashMap，Synchronized + CAS</p>
<ol>
<li><p>基于<strong>数组+链表/红黑树</strong>，当链表元素大于等于8，且table数组长度大于64，链表会转换成红黑树（链表元素个数大于等于8但table数组长度小于64时，只触发扩容），若红黑树的节点个数小于等于6，树结构还原成链表。因为红黑树的平均查找长度是log_2 n，而链表的平均查找长度是n/2。中间有个差值，可以防止链表和树频繁转换。</p>
</li>
<li><p><strong>默认容量为16，默认负载因子为0.75</strong>，最大容量为2^30。<strong>指定的负载因子只在构造方法中有效</strong>，用来计算扩容阈值，不会存储负载因子。<strong>后续扩容还是使用0.75</strong>。</p>
</li>
<li><p><strong>容量总是为2的次幂</strong>（数组索引计算为与运算，i = (n - 1) &amp; hash），在计算机中，  (n - 1) &amp; hash，当n为2次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n，计算更加高效。</p>
</li>
<li><p><strong>懒加载</strong>，空参构造方法什么也没干，指定容量的构造方法中，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程安全</strong>，JDK7采用<strong>分段锁</strong>（Segment）设计，而JDK8采用<strong>Synchronized + CAS</strong>设计实现线程安全。</p>
</li>
<li><p><strong>动态扩容</strong>。新的容量是旧容量的2倍。<strong>数据迁移</strong>。扩容的第一次初始化新表（扩容后的新表）这个动作，只能由一个线程完成。其他线程都是在帮助迁移元素到新数组。数据迁移从后向前进行，通过改变transferIndex的值从n到0，每个线程迁移数组中指定长度Node节点（这个长度叫做<strong>步长</strong>）。transferIndex到0后，还会将其值改回n，检查一遍是否迁移成功。扩容和数据迁移数concurrentHashMap中最难的一部分，参考下面的资料方便理解。</p>
</li>
<li><p><strong>添加元素采用尾插法（方便计数）</strong>，<strong>数据迁移时采用头插法</strong>。</p>
</li>
<li><p><strong>对于获取size</strong>，<strong>使用CounterCell避免大量的CAS</strong> ，当需要修改元素数量时，线程会先去 CAS 修改 baseCount 加1，若成功即返回。若失败，则线程被分配到某个 CounterCell ，然后操作 value 加1。若成功，则返回。否则，给当前线程重新分配一个 CounterCell，再尝试给 value 加1。（这里简略的说，实际更复杂），遍历CounterCell的值和baseCount相加的结果就是容量。</p>
</li>
<li><p><strong>对于get读操作</strong>，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。 如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。</p>
</li>
<li><p><strong>对于put/remove写操作</strong>，如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。</p>
</li>
<li><p>Node类的<strong>value和next使用volatile修饰</strong>，保证可见性。</p>
</li>
<li><p><strong>sizeCtl</strong>，默认为0，用来控制table的初始化和扩容操作。-1 代表table正在初始化，-N 表示有N-1个线程正在进行扩容操作 。如果table未初始化，表示table需要初始化的大小。 如果table初始化完成，表示table的容量，默认是table大小的0.75倍。用来控制扩容操作时，<strong>高16位是数据校验标识，低16位代表当前有几个线程正在帮助扩容</strong>。扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd，如果f == null，则在table中的i位置放入fwd，否则采用头插法的方式把当前旧table数组的指定任务范围的数据给迁移到新的数组中，然后<br>给旧table原位置赋值fwd。直到遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断head节点是否为forwardNode节点，如果是就帮助扩容。</p>
</li>
<li><p><strong>红黑树的根节点的哈希值为-2</strong>，判断的是否为红黑树直接判断第一个元素的哈希值是否大于0。</p>
</li>
<li><p>不支持<strong>fail-fast</strong>机制</p>
</li>
<li><p><strong>key和value都不能为null</strong>，否则会抛出空指针异常。</p>
</li>
<li><p><strong>线程安全</strong>，并发粒度细，性能强。</p>
</li>
<li><p><strong>弱一致性</strong>，因为使用了Counter来帮助计算容量，遍历Counter时没有加锁，所以存在弱一致性问题（实际上juc集合里面的size方法所返回的元素个数都是不保证准确的）。另外JDK8之前迭代器也存在弱一致性问题，HashEntry的next属性定义为final，这意味着它是不可变的，如果线程A 删掉了第 7 个元素，线程B 已经遍历到了第 3 个元素，那么 B 还是可以遍历到被删除的第 7 个元素。</p>
</li>
</ol>
<p><strong>笔记：</strong></p>
<ol>
<li>Thread.yield()；让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。作用：<strong>避免一个线程长时间占有 CPU 资源</strong></li>
</ol>
<p><strong>参考资料</strong>：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/My4P_BBXDnAGX1gh630ZKw" target="_blank" rel="noopener">ConcurrentHashMap 底层原理</a></li>
<li><a href="https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/currency/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%9713%EF%BC%9AJava%20%E4%B8%AD%E7%9A%84%20HashMap%20%E5%92%8C%20ConcurrentHashMap%20%E5%85%A8%E8%A7%A3%E6%9E%90.md#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">Java 中的 HashMap 和 ConcurrentHashMap</a></li>
</ol>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><img src="/2020/08/03/Java%E9%9B%86%E5%90%88-Map%E7%AF%87/ConcurrentSkipListMap.png" class="" title="ConcurrentSkipListMap">

<p>跳跃表，线程安全，CAS，无锁，有序，空间换时间</p>
<ol>
<li><p><strong>基于跳跃表</strong>，理论上能够O(log(n))时间内完成查找、插入、删除操作。</p>
</li>
<li><p><strong>有序</strong>Map集合，key是有序的，元素的顺序基于键的compareTo方法，或者自定义的comparator。</p>
</li>
<li><p><strong>线程安全</strong>，基于CAS+volatile实现，并发粒度细，性能强。</p>
</li>
<li><p><strong>空间换时间</strong>，基于跳跃表实现的有序，包含<strong>多级索引</strong>，每个级别的索引节点按照其关联数据节点的关键字升序排列，且高级别索引是其低级别索引的子集，如果关键字key在级别level=i的索引中出现，则级别level&lt;=i的所有索引中都包含key。</p>
</li>
<li><p>节点主要由 <strong>Node, Index, HeadIndex</strong> 构成，横向纵向都是链表。最下面那层链表是Node层(数据节点层), 上面几层都是Index层(索引)。从纵向链表来看, 最左边的是 HeadIndex 层, 右边的都是Index 层, 且每层的最底端都是对应Node, <strong>纵向上的索引都是指向最底端的Node</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;  <span class="comment">// key 是 final 的, 说明节点一旦定下来, 除了删除, 不然不会改动 key 了</span></span><br><span class="line">    <span class="keyword">volatile</span> Object value; <span class="comment">// 对应的 value</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K, V&gt; next; <span class="comment">// 下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node; <span class="comment">// 索引指向的节点, 纵向上所有索引指向链表最下面的节点</span></span><br><span class="line">    <span class="keyword">final</span> Index&lt;K, V&gt; down; <span class="comment">// 下边level层的 Index</span></span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K, V&gt; right; <span class="comment">// 右边的  Index</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(node, down, right); <span class="comment">// 所有的 HeadIndex 都指向同一个 Base_header 节点</span></span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素的增删改查都从最上层的head指针指向的结点开始</strong>。</p>
</li>
<li><p><strong>头插法</strong>创建Index结点，在删除键值对时，不会立即执行删除，而是通过引入<strong>标记结点</strong>，以<strong>懒删除</strong>的方式进行，以提高并发效率。</p>
</li>
<li><p>每次put操作都会生成随机数，然后用来获取level (50%的几率返回0，25%的几率返回1，12.5%的几率返回2…最大返回31)，如果level大于最大的level，则会新增level。否则只插入一个Index节点。</p>
</li>
<li><p><strong>key和value都不能为null</strong>，否则会抛出空指针异常。</p>
</li>
<li><p>不支持<strong>fail-fast</strong>机制。</p>
</li>
<li><p><strong>无懒加载</strong></p>
</li>
</ol>
<p><strong>参考资料</strong>：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000016168566?utm_source=tag-newest" target="_blank" rel="noopener">J.U.C之collections框架：ConcurrentSkipListMap</a></li>
<li><a href="https://www.jianshu.com/p/edc2fd149255" target="_blank" rel="noopener">ConcurrentSkipListMap 源码分析 (基于Java 8)</a></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="性能谁更强？ConcurrentSkipListMap-VS-ConcurrentHashMap"><a href="#性能谁更强？ConcurrentSkipListMap-VS-ConcurrentHashMap" class="headerlink" title="性能谁更强？ConcurrentSkipListMap VS ConcurrentHashMap"></a>性能谁更强？ConcurrentSkipListMap VS ConcurrentHashMap</h3><p>在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。</p>
<p>但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：</p>
<p>1、ConcurrentSkipListMap 的key是有序的。</p>
<p>2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
        <tag>HashTable</tag>
        <tag>TreeMap</tag>
        <tag>LinkedHashMap</tag>
        <tag>IdentityHashMap</tag>
        <tag>WeakHashMap</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>ConcurrentSkipListMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-Set篇</title>
    <url>/2020/08/03/Java%E9%9B%86%E5%90%88-Set%E7%AF%87/</url>
    <content><![CDATA[<p>JDK提供的集合类型主要分为四种类型：</p>
<ol>
<li>List：支持重复元素</li>
<li>Set：不支持重复元素</li>
<li>Map：键/值对的映射集</li>
<li>Queue/Deque（double ended queue）：queue是在集合尾部添加元素，在头部删除元素的队列，deque是可在头部和尾部添加或者删除元素的双端队列，<strong>deque既可以实现队列又可以实现栈</strong>。</li>
</ol>
<a id="more"></a>

<p>本文基于JDK8，java version “1.8.0_251”</p>
<h2 id="EnumSet（RegularEnumSet-JumboEnumSet）"><a href="#EnumSet（RegularEnumSet-JumboEnumSet）" class="headerlink" title="EnumSet（RegularEnumSet/JumboEnumSet）"></a>EnumSet（RegularEnumSet/JumboEnumSet）</h2><p>枚举类的容器，非线程安全，有序集合</p>
<ol>
<li><p>EnumSet是抽象类，<strong>使用静态方法noneOf构建</strong>，如果枚举类的值不超过64，则使用创建RegularEnumSet实例，如果超过64位，则创建的JumboEnumSet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumSet.noneOf(E<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</span><br><span class="line">    Enum&lt;?&gt;[] universe = getUniverse(elementType);</span><br><span class="line">    <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">" not an enum"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有序集合</strong>，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序</p>
</li>
<li><p>RegularEnumSet内部通过<strong>Bit数组</strong>来存放枚举值，而这个Bit数组其实就是一个Long类型数值，初始时是0L，是一个容量为64的Bit数组（Long类型长度为8字节，一个字节等于8位）。添加元素时，是把对应枚举元素的ordinal（每一个枚举类的枚举值都对应一个ordinal值）值映射到64Bit上的某一个位置为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bit vector representation of this set.  The 2^k bit indicates the</span></span><br><span class="line"><span class="comment"> * presence of universe[k] in this set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> elements = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set changed as a result of the call</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &lt;tt&gt;e&lt;/tt&gt; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldElements = elements;</span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JumboEnumSet内部则通过<strong>long数组</strong>类存放枚举值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bit vector representation of this set.  The ith bit of the jth</span></span><br><span class="line"><span class="comment"> * element of this array represents the  presence of universe[64*j +i]</span></span><br><span class="line"><span class="comment"> * in this set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> elements[];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set changed as a result of the call</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &lt;tt&gt;e&lt;/tt&gt; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> eOrdinal = e.ordinal();</span><br><span class="line">    <span class="keyword">int</span> eWordNum = eOrdinal &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldElements = elements[eWordNum];</span><br><span class="line">    elements[eWordNum] |= (<span class="number">1L</span> &lt;&lt; eOrdinal);</span><br><span class="line">    <span class="keyword">boolean</span> result = (elements[eWordNum] != oldElements);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非线程安全</strong>，可以通过<strong>Collections.synchronizedSet()</strong>方法把它转成线程安全的集合，即使性能不是很高，但是似乎是唯一的选择。</p>
</li>
</ol>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>有序集合，非线程安全，不允许null元素（Treemap不允许null的key，因为要使用它的compareTo方法）</p>
<ol>
<li><p>内部通过<strong>TreeMap</strong>来存储元素，把元素存储在TreeMap的key里，value为同一个Object实例，通过TreeMap存储Key的有序性和无重复性来实现自己的<strong>有序性</strong>和Set的的元素<strong>无重复性</strong>；插入元素时，会<strong>根据元素compareTo方法判断是否重复和顺序</strong>（所以TreeSet中的元素必须实现Comparable接口并重写compareTo方法），然后进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree set, sorted according to the</span></span><br><span class="line"><span class="comment"> * natural ordering of its elements.  All elements inserted into</span></span><br><span class="line"><span class="comment"> * the set must implement the &#123;<span class="doctag">@link</span> Comparable&#125; interface.</span></span><br><span class="line"><span class="comment"> * Furthermore, all such elements must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/i&gt;: &#123;<span class="doctag">@code</span> e1.compareTo(e2)&#125; must not throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements &#123;<span class="doctag">@code</span> e1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add an element</span></span><br><span class="line"><span class="comment"> * to the set that violates this constraint (for example, the user</span></span><br><span class="line"><span class="comment"> * attempts to add a string element to a set whose elements are</span></span><br><span class="line"><span class="comment"> * integers), the &#123;<span class="doctag">@code</span> add&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非线程安全，可以通过<strong>Collections.synchronizedSortedSet()</strong>方法把它转成线程安全的集合</p>
</li>
<li><p>不支持<strong>fail-fast</strong>机制，用的是TreeMap的iterator，没有checkForComodification()，更不会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>不允许null元素</strong>，会抛出空指针异常，Treemap不允许null的key，插入时要使用它的compareTo方法会造成空指针异常</p>
</li>
<li><p><strong>有序集合</strong>，根据元素的CompareTo方法顺序或自定义的comparator比较顺序。</p>
</li>
</ol>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>无序集合，非线程安全，允许null元素</p>
<ol>
<li><p>内部通过<strong>HashMap</strong>来存储元素，把元素存储在HashMap的key里，value为同一个Object实例，通过HashMap存储Key的无重复性来实现自己的无重复性，插入元素时，会根据<strong>元素的hashcode方法判断元素是否重复</strong>（key为null时，hashcode为0），<strong>包含一个基于LinkedHashMap的构造方法</strong>（给同一个包下的其他类使用，比如LinkedHashSet）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非线程安全</strong>，可以通过<strong>Collections.synchronizedSortedSet()</strong>方法把它转成线程安全的集合</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，用的是HashMap的iterator，会判断modCount的值是否被修改，如果modCount != expectedModCount，则抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许null元素</strong>，因为HashMap允许null的key</p>
</li>
<li><p><strong>无序集合</strong></p>
</li>
</ol>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>有序集合，非线程安全，允许null元素</p>
<ol>
<li><p><strong>继承至HashSet</strong>，除了构造方法和重写的spliterator方法，没有任何多余的成员变量和其他的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有序集合</strong>，内部通过<strong>LinkedHashMap</strong>来存储元素，构造方法中主要是调用父类HashSet的构造方法构建一个LinkedHashMap，相比LinkedHashMap可以控制按插入元素时的顺序还是按访问顺序进行排序，<strong>LinkedHashSet只能按插入元素的顺序进行排序</strong>。</p>
</li>
<li><p><strong>非线程安全</strong>，可以通过<strong>Collections.synchronizedSortedSet()</strong>方法把它转成线程安全的集合。</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，nextNode方法中会判断modCount值，如果modCount != expectedModCount，则会抛出ConcurrentModificationException异常。</p>
</li>
<li><p><strong>允许null元素</strong>，因为LinkedHashMap允许null的key</p>
</li>
</ol>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><p>无序集合，基于CopyOnWriteArrayList，线程安全，适合set大小一般很小且多读场景，内存占用大</p>
<ol>
<li><p><strong>基于CopyOnWriteArrayList实现</strong>，所有的操作都是通过CopyOnWriteArrayList对象进行的，构造方法中直接创建一个CopyOnWriteArrayList对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加元素前需要遍历整个数组</strong>，因为不允许重复，所以添加元素之前需要判断元素是否存在，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API,通过这些API来添加元素时，只有当元素不存在时才执行添加操作。</p>
</li>
<li><p><strong>线程安全</strong>。和CopyOnWriteArrayList一样，通过volatile和互斥锁来实现（因为直接使用了CopyOnWriteArrayList的方法）。</p>
</li>
<li><p>不支持<strong>fail-fast</strong>机制</p>
</li>
</ol>
<h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><p>有序集合，基于ConcurrentSkipListMap，线程安全，适用于高并发场景</p>
<ol>
<li><p><strong>基于ConcurrentSkipListMap</strong>，把元素存储在ConcurrentSkipListMap的key里，value为常量<code>Boolean.TRUE</code>，通过ConcurrentSkipListMap存储Key的有序性和无重复性来实现自己的<strong>有序性</strong>和Set的的元素<strong>无重复性</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentNavigableMap&lt;E,Object&gt; m;<span class="comment">//实际上ConcurrentSkipListMap的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程安全</strong>，因为ConcurrentSkipListMap是线程安全的。</p>
</li>
<li><p>不支持<strong>fail-fast</strong>机制，用的是ConcurrentSkipListMap的KeyIterator。</p>
</li>
<li><p><strong>不允许null元素</strong>，会抛出空指针异常。ConcurrentSkipListMap的key和value都不支持null。</p>
</li>
<li><p><strong>有序集合</strong>，根据元素的CompareTo方法顺序或自定义的comparator比较顺序。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
        <tag>Java</tag>
        <tag>EnumSet</tag>
        <tag>TreeSet</tag>
        <tag>LinkedHashSet</tag>
        <tag>CopyOnWriteArraySet</tag>
        <tag>ConcurrentSkipListSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka集群搭建</title>
    <url>/2020/10/17/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Zookeeper版本：3.4.14（需提前安装）</p>
<p>Kafka版本：2.12-2.3.1</p>
<a id="more"></a>

<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>三台节点docker-compose.yml分别如下</p>
<p>192.168.3.100:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka:2.12-2.3.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span><span class="string">:2181,192.168.3.101:2181,192.168.3.102:2181</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/kafka</span></span><br></pre></td></tr></table></figure>

<p>192.168.3.101:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka:2.12-2.3.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.101</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span><span class="string">:2181,192.168.3.101:2181,192.168.3.102:2181</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/kafka</span></span><br></pre></td></tr></table></figure>

<p>192.168.3.102:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka:2.12-2.3.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.102</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span><span class="string">:2181,192.168.3.101:2181,192.168.3.102:2181</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/kafka</span></span><br></pre></td></tr></table></figure>

<p>然后分别启动即可</p>
<h2 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h2><p>这里选择<code>eagle</code>，官网地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kafka-eagle.org%2F" target="_blank" rel="noopener">https://www.kafka-eagle.org/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/smartloli/kafka-eagle-bin/tar.gz/v2.0.2</span><br><span class="line">tar -zxvf kafka-eagle-bin-2.0.2.tar.gz</span><br><span class="line">cd /opt/kafka-eagle-web-2.0.2</span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> multi zookeeper &amp; kafka cluster list</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.zk.cluster.alias=cluster1</span><br><span class="line">cluster1.zk.list=10.86.52.74:2181,10.86.52.77:2181,10.86.122.208:2181</span><br><span class="line"><span class="meta">#</span><span class="bash">cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zookeeper <span class="built_in">enable</span> acl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster1.zk.acl.enable=false</span><br><span class="line">cluster1.zk.acl.schema=digest</span><br><span class="line">cluster1.zk.acl.username=test</span><br><span class="line">cluster1.zk.acl.password=test123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> broker size online list</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster1.kafka.eagle.broker.size=20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zk client thread <span class="built_in">limit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.zk.limit.size=25</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka eagle webui port</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.webui.port=8048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka jmx acl and ssl authenticate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster1.kafka.eagle.jmx.acl=false</span><br><span class="line">cluster1.kafka.eagle.jmx.user=keadmin</span><br><span class="line">cluster1.kafka.eagle.jmx.password=keadmin123</span><br><span class="line">cluster1.kafka.eagle.jmx.ssl=false</span><br><span class="line">cluster1.kafka.eagle.jmx.truststore.location=/Users/dengjie/workspace/ssl/certificates/kafka.truststore</span><br><span class="line">cluster1.kafka.eagle.jmx.truststore.password=ke123456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka offset storage</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster1.kafka.eagle.offset.storage=kafka</span><br><span class="line">cluster2.kafka.eagle.offset.storage=zk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka metrics, 15 days by default</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.metrics.charts=true</span><br><span class="line">kafka.eagle.metrics.retain=15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka sql topic records max</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.sql.topic.records.max=5000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> delete kafka topic token</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.topic.token=keadmin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka sasl authenticate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster1.kafka.eagle.sasl.enable=false</span><br><span class="line">cluster1.kafka.eagle.sasl.protocol=SASL_PLAINTEXT</span><br><span class="line">cluster1.kafka.eagle.sasl.mechanism=SCRAM-SHA-256</span><br><span class="line">cluster1.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="kafka" password="kafka-eagle";</span><br><span class="line">cluster1.kafka.eagle.sasl.client.id=</span><br><span class="line">cluster1.kafka.eagle.blacklist.topics=</span><br><span class="line">cluster1.kafka.eagle.sasl.cgroup.enable=false</span><br><span class="line">cluster1.kafka.eagle.sasl.cgroup.topics=</span><br><span class="line">cluster2.kafka.eagle.sasl.enable=false</span><br><span class="line">cluster2.kafka.eagle.sasl.protocol=SASL_PLAINTEXT</span><br><span class="line">cluster2.kafka.eagle.sasl.mechanism=PLAIN</span><br><span class="line">cluster2.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="kafka" password="kafka-eagle";</span><br><span class="line">cluster2.kafka.eagle.sasl.client.id=</span><br><span class="line">cluster2.kafka.eagle.blacklist.topics=</span><br><span class="line">cluster2.kafka.eagle.sasl.cgroup.enable=false</span><br><span class="line">cluster2.kafka.eagle.sasl.cgroup.topics=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka ssl authenticate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">cluster3.kafka.eagle.ssl.enable=false</span><br><span class="line">cluster3.kafka.eagle.ssl.protocol=SSL</span><br><span class="line">cluster3.kafka.eagle.ssl.truststore.location=</span><br><span class="line">cluster3.kafka.eagle.ssl.truststore.password=</span><br><span class="line">cluster3.kafka.eagle.ssl.keystore.location=</span><br><span class="line">cluster3.kafka.eagle.ssl.keystore.password=</span><br><span class="line">cluster3.kafka.eagle.ssl.key.password=</span><br><span class="line">cluster3.kafka.eagle.blacklist.topics=</span><br><span class="line">cluster3.kafka.eagle.ssl.cgroup.enable=false</span><br><span class="line">cluster3.kafka.eagle.ssl.cgroup.topics=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka sqlite jdbc driver address</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.driver=org.sqlite.JDBC</span><br><span class="line">kafka.eagle.url=jdbc:sqlite:/opt/kafka-eagle-web-2.0.2/db/ke.db</span><br><span class="line">kafka.eagle.username=root</span><br><span class="line">kafka.eagle.password=www.kafka-eagle.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka mysql jdbc driver address</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">kafka.eagle.driver=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">#</span><span class="bash">kafka.eagle.url=jdbc:mysql://127.0.0.1:3306/ke?useUnicode=<span class="literal">true</span>&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">#</span><span class="bash">kafka.eagle.username=root</span></span><br><span class="line"><span class="meta">#</span><span class="bash">kafka.eagle.password=123456</span></span><br></pre></td></tr></table></figure>

<p>新增环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/profile</span></span><br><span class="line">export KE_HOME=/opt/kafka-eagle-web-2.0.2</span><br><span class="line">PATH=$PATH:$KE_HOME/bin</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../bin</span><br><span class="line">./ke.sh start</span><br></pre></td></tr></table></figure>

<p><a href="http://10.86.52.77:8048/，默认账号admin，密码123456" target="_blank" rel="noopener">http://10.86.52.77:8048/，默认账号admin，密码123456</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java集合-Queue/Deque篇</title>
    <url>/2020/08/06/Java%E9%9B%86%E5%90%88-QueueDeque%E7%AF%87/</url>
    <content><![CDATA[<p>JDK提供的集合类型主要分为四种类型：</p>
<ol>
<li>List：支持重复元素</li>
<li>Set：不支持重复元素</li>
<li>Map：键/值对的映射集</li>
<li>Queue/Deque（double ended queue）：queue是在集合尾部添加元素，在头部删除元素的队列，deque是可在头部和尾部添加或者删除元素的双端队列，<strong>deque既可以实现队列又可以实现栈</strong>。</li>
</ol>
<a id="more"></a>

<p>本文基于JDK8，java version “1.8.0_251”</p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p>基于数组，循环数组，非线程安全，效率高，双端队列，即可实现队列也可实现栈</p>
<ol>
<li><p><strong>基于数组</strong>，最小容量为8，默认容量为16，<strong>最大容量Integer.MAX_VALUE-8</strong>（2^31 - 8），<strong>容量总是为2的次幂</strong>（用于判断是否需要扩容）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>即可实现队列也可实现栈</strong>，ArrayDeque 和 LinkedList 都是 Deque 接口的实现类，都具备既可以作为队列，又可以作为栈来使用的特性，两者主要区别在于底层数据结构的不同。ArrayDeque 底层数据结构是以<strong>循环数组</strong>为基础，而 LinkedList 底层数据结构是以<strong>循环链表</strong>为基础。理论上，链表在添加、删除方面性能高于数组结构，在查询方面数组结构性能高于链表结构，但是对于数组结构，如果不进行数组移动，在添加方面效率也很高。<strong>LinkedList的内存开销更大</strong>。对于小数据量，ArrayDeque 和 LinkedList 在效率方面相差不大，但是对于大数据量，<strong>推荐使用 ArrayDeque</strong>。</p>
</li>
<li><p><strong>循环数组</strong>，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组，也就是说数组的任何一点都可能被看作起点或者终点，head和tail分别代表起点和终点的索引值。因为是循环数组，所以 head 不一定总是指向下标为 0 的数组元素，tail 也不一定总是比 head 大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The index of the element at the head of the deque (which is the</span></span><br><span class="line"><span class="comment"> * element that would be removed by remove() or pop()); or an</span></span><br><span class="line"><span class="comment"> * arbitrary number equal to tail if the deque is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The index at which the next element would be added to the tail</span></span><br><span class="line"><span class="comment"> * of the deque (via addLast(E), add(E), or push(E)).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态扩容</strong>，容量为原来的2倍。<code>(tail = (tail + 1) &amp; (elements.length - 1)) == head</code>用与运算来计算终点位置，然后判断tail是否和head重合，如果重合就触发扩容。扩容申请一个2倍大小的数组，将原数组复制到新数组。<strong>复制数组分两次进行，第一次复制 head 头部索引至数组末端的元素到新数组，第二次复制 head 左边的元素到新数组</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ArrayDeque不允许插入null，而 LinkedList 允许插入null</strong>。</p>
</li>
<li><p><strong>非线程安全</strong>，也没办法通过Collections类变为线程安全的类。</p>
</li>
<li><p>支持<strong>fail-fast</strong>机制，如果tail != fence || result == null，则抛出ConcurrentModificationException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cursor == fence)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[cursor];</span><br><span class="line">    <span class="comment">// This check doesn't catch all possible comodifications,</span></span><br><span class="line">    <span class="comment">// but does catch the ones that corrupt traversal</span></span><br><span class="line">    <span class="keyword">if</span> (tail != fence || result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    lastRet = cursor;</span><br><span class="line">    cursor = (cursor + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>优先队列，小顶堆，非线程安全</p>
<ol>
<li><p><strong>基于数组实现的小顶堆</strong>，根据元素的CompareTo方法顺序或自定义的comparator比较顺序。</p>
</li>
<li><p>父节点和子节点的编号是有联系的。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">leftNo</span> = parent<span class="literal">No</span>*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="attr">rightNo</span> = parent<span class="literal">No</span>*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line"><span class="attr">parentNo</span> = (node<span class="literal">No</span>-<span class="number">1</span>)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素。新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p>
</li>
<li><p>删除类似和添加元素类似。</p>
</li>
<li><p>动态扩容，如果原数组容量小于64，则扩容为原数组容量的2倍+2，否则扩容为原数组容量的3/2倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// minCapacity等于原数组容量+1</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>线程安全的非阻塞队列，基于链表的无界线程安全队列，无锁</p>
<ol>
<li><p><strong>基于链表</strong>，不能指定最大容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>head节点表示队头，tail节点表示队尾</strong>，head节点用来出队列使用，一个tail节点用来入队列使用，初始化的时候head = tail 都是一个空节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node from which the last node on list (that is, the unique</span></span><br><span class="line"><span class="comment"> * node with node.next == null) can be reached in O(1) time.</span></span><br><span class="line"><span class="comment"> * Invariants:</span></span><br><span class="line"><span class="comment"> * - the last node is always reachable from tail via succ()</span></span><br><span class="line"><span class="comment"> * - tail != null</span></span><br><span class="line"><span class="comment"> * Non-invariants:</span></span><br><span class="line"><span class="comment"> * - tail.item may or may not be null.</span></span><br><span class="line"><span class="comment"> * - it is permitted for tail to lag behind head, that is, for tail</span></span><br><span class="line"><span class="comment"> *   to not be reachable from head!</span></span><br><span class="line"><span class="comment"> * - tail.next may or may not be self-pointing to tail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>head 未必是队列中第一个元素</strong>（head指向的可能是一个已经被移除的元素），<strong>tail 未必是队列中最后一个元素</strong>（tail.next 可以不为 null）</p>
<p>有了 head 和 tail 节点，如果按照我们平常的思维，head 节点即头节点，tail 节点即尾节点。那么入队列的时候，将 tail 的 next 节点设置为 newNode，将 newNode 设置为 tail；出队列的时候，将 head 节点元素返回，head 的 next 节点设置为 head。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的做法 tail 节点永远作为队列的尾节点，head 节点永远为队列的头节点。实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环 CAS 更新 tail 节点。所以 doug lea 为了减少 CAS 更新 tail 节点的次数，提高入队的效率，使用增加循环来控制 tail 节点的更新频率，并不是每次节点入队后都将 tail 节点更新成尾节点，而是当 tail 节点和尾节点不一致时（也就是循环两次）才更新 tail 节点。</p>
</li>
<li><p><strong>size方法可能不准确</strong>，（实际上juc集合里面的size方法所返回的元素个数都是不保证准确的）</p>
</li>
</ol>
<p>参考资料：</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1496869" target="_blank" rel="noopener">ConcurrentLinkedQueue 源码解读</a></li>
<li><a href="https://www.jianshu.com/p/0c5a672b2ade" target="_blank" rel="noopener">JUC源码分析-集合篇（四）：ConcurrentLinkedQueue</a></li>
</ol>
<h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h2><p>基于双向链表结构的无界并发队列，CAS，与 ConcurrentLinkedQueue 的区别是该阻塞队列同时支持<strong>FIFO</strong>和<strong>FILO</strong>两种操作方式</p>
<ol>
<li>基于双向链表结构的无界并发队列</li>
</ol>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/602b3240afaf" target="_blank" rel="noopener">JUC源码分析-集合篇（五）：ConcurrentLinkedDeque</a></li>
</ol>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><ol>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界（但大小默认值为Interger.MAX_VALUE）阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列，也即单个元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向有界阻塞队列。</li>
</ol>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界阻塞队列，基于循环数组，线程安全</p>
<ol>
<li><p><strong>基于循环数组</strong>，关键成员变量如下：</p>
<ol>
<li><strong>lock的作用</strong>：在多线程下操作的，所有修改items、takeIndex、putIndex和count这些成员变量时，必须要考虑多线程安全问题，这里使用lock<strong>独占锁</strong>，来<strong>保证并发操作的安全</strong>。</li>
<li><strong>notEmpty与notFull的作用</strong>：因为阻塞队列必须实现，当队列为空或队列已满的时候，队列的读取或插入操作要等待。当队列从空时，插入元素需要唤醒之前因为读取等待的线程。当队列已满时，移出元素需要唤醒之前因为插入等待的线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 储存队列的中元素 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列头的位置 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列尾的位置 */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前队列拥有的元素个数 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用来保证多线程操作共享变量的安全问题 */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当队列为空时，就会调用notEmpty的wait方法，让当前线程等待 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当队列为满时，就会调用notFull的wait方法，让当前线程等待 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有界队列</strong>，构造方法需要指定队列大小，并且<strong>可以指定lock使用公平锁还是非公平锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>循环数组</strong>，和ArrayDeque同理。</p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
</ol>
<h4 id="源码说明："><a href="#源码说明：" class="headerlink" title="源码说明："></a>源码说明：</h4><p>lock.lock()是保证同一时间只有一个线程修改成员变量，防止出现并发操作问题。虽然它也会阻塞当前线程，但是它并不是条件等待，只是因为锁被其他线程持有，而ArrayBlockingQueue中方法操作时间都不长，这里相当于不阻塞线程。</p>
<h4 id="add-E-e-与offer-E-e-方法"><a href="#add-E-e-与offer-E-e-方法" class="headerlink" title="add(E e)与offer(E e)方法"></a>add(E e)与offer(E e)方法</h4><p>向队尾新添加元素，如果队列已满，返回false，否则添加成功返回true。</p>
<p>add方法调用父类的方法，父类的方法会调用offer方法，最终add方法实际就是调用offer方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enqueue-E-x-方法"><a href="#enqueue-E-x-方法" class="headerlink" title="enqueue(E x)方法"></a>enqueue(E x)方法</h4><p>向队尾新添加元素，向队列末尾新添加元素，添加成功则将putIndex+1，如果达到数组长度，putIndex=0（因为循环数组），然后唤醒因为数组为空时获取元素阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问：调用notEmpty.signal()之前是不是应该判断一下当前的长度是否为1？</p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>向队尾新添加元素。向队列末尾新添加元素，如果队列已满，则调用notFull.await()，这里判断需要用while而不能用if，目的是防止<strong>虚假唤醒</strong>。线程被唤醒之后，检查是否已满，如果队列还是满的，则继续等待，如果不是满的，则向队尾添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="offer-E-e-long-timeout-TimeUnit-unit-方法"><a href="#offer-E-e-long-timeout-TimeUnit-unit-方法" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)方法"></a>offer(E e, long timeout, TimeUnit unit)方法</h4><p>向队尾新添加元素，可设置最大的阻塞时间。</p>
<p>如果队列中没有可用空间，当前线程就等待， 如果等待时间超过timeout了，那么返回false，表示添加失败。如果被唤醒，则检查是否有可用空间，如果有可用空间，则继续添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-和poll-方法"><a href="#remove-和poll-方法" class="headerlink" title="remove()和poll()方法"></a>remove()和poll()方法</h4><p>删除队头元素，如果队列为空，返回null，不为空删除成功返回元素。</p>
<p>remove方法调用父类的方法，父类的方法会调用poll方法，最终remove方法实际就是调用poll方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dequeue方法"><a href="#dequeue方法" class="headerlink" title="dequeue方法"></a>dequeue方法</h4><p>删除队头元素，先将队头元素删除，然后将takeIndex的值+1，如果达到数组长度，takeIndex=0（因为循环数组），然后唤醒因为数组已满时添加元素阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>疑问</strong>：调用notFull.signal();之前是否应该先判断容量为数组长度-1？</p>
<h4 id="take-方法"><a href="#take-方法" class="headerlink" title="take()方法"></a>take()方法</h4><p>删除队头元素，如果当前容量为0，则等待。否则删除元素。这里判断当前容量不能用if，目的是防止虚假唤醒。如果被唤醒，则检查队里是否有元素，如果有元素，则继续删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="poll-long-timeout-TimeUnit-unit-方法"><a href="#poll-long-timeout-TimeUnit-unit-方法" class="headerlink" title="poll(long timeout, TimeUnit unit)方法"></a>poll(long timeout, TimeUnit unit)方法</h4><p>删除队头元素，可设置最大的阻塞时间。</p>
<p>如果当前容量为0，则等待，等待超过最大等待时间则返回null。如果被唤醒，则检查队里是否有元素，如果有元，则继续删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="element-与peek-方法"><a href="#element-与peek-方法" class="headerlink" title="element()与peek() 方法"></a>element()与peek() 方法</h4><p>查看元素</p>
<p>element方法调用父类的方法，父类的方法会调用peek方法，最终element方法实际就是调用peek方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h4><p>删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从队列中删除指定对象o，那么就要遍历队列，删除第一个与对象o相同的元素，如果队列中没有对象o元素，那么返回false删除失败。这里有两点需要注意：</p>
<ol>
<li>如何遍历队列，就是从队列头遍历到队列尾。就要靠takeIndex和putIndex两个变量了。</li>
<li><strong>为什么Object[] items = this.items</strong>;这句代码没有放到同步锁lock代码块内。items是成员变量，那么多线程操作的时候，不会有并发问题么？<br>这个是因为items是个引用变量，不是基本数据类型，而且我们对队列的插入和删除操作，都是针对这一个items数组，没有改变数组的引用，所以在lock代码中，items会得到其他线程对它最新的修改。但是如果这里将int putIndex = this.putIndex;方法lock代码块外面，就会产生问题。</li>
</ol>
<h4 id="removeAt-final-int-removeIndex-方法"><a href="#removeAt-final-int-removeIndex-方法" class="headerlink" title="removeAt(final int removeIndex)方法"></a>removeAt(final int removeIndex)方法</h4><p>删除指定位置的元素，需要注意的是删除之后的数组还能保持队列形式，分为两种情况：</p>
<ol>
<li>如果删除位置是队列头，那么简单，只需要将队列头的位置元素设置为null，将将队列头位置+1</li>
<li>如果删除位置不是队列头，那么麻烦了，这个时候，我们就要将从removeIndex位置后的元素全部左移一位，覆盖前一个元素。最后将原来队列尾的元素置位null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[removeIndex] != null;</span></span><br><span class="line">    <span class="comment">// assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">        <span class="comment">// removing front item; just advance</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// an "interior" remove</span></span><br><span class="line">        <span class="comment">// slide over all others up through putIndex.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="疑问：为什么构造方法要加锁？"><a href="#疑问：为什么构造方法要加锁？" class="headerlink" title="疑问：为什么构造方法要加锁？"></a>疑问：为什么构造方法要加锁？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity, the specified access policy and initially containing the</span></span><br><span class="line"><span class="comment"> * elements of the given collection,</span></span><br><span class="line"><span class="comment"> * added in traversal order of the collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is less than</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> c.size()&#125;, or less than 1.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中有写：锁的用处在于可见性而不是竞争。此处使用锁的意义在于避免指令重排序，避免出现对象未初始化完，就将将内存空间的地址赋值给对应的引用。保证count,putIndex,items[i]的可见性。</p>
<p>注意item被final修饰，只能保证final字段对应的引用是up-to-date的。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>有界阻塞队列，基于链表，线程安全，双锁</p>
<ol>
<li><p><strong>基于链表</strong>，关键成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Linked list node class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * One of:</span></span><br><span class="line"><span class="comment">     * - the real successor Node</span></span><br><span class="line"><span class="comment">     * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">     * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>双锁。一个take锁，控制消费者并发，一个put锁，控制生产者并发</p>
</li>
<li><p><strong>有界队列</strong>，默认和最大长度为 Integer.MAX_VALUE，并且<strong>可以指定lock使用公平锁还是非公平锁</strong>。</p>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
</ol>
<h4 id="add-E-e-与offer-E-e-方法-1"><a href="#add-E-e-与offer-E-e-方法-1" class="headerlink" title="add(E e)与offer(E e)方法"></a>add(E e)与offer(E e)方法</h4><p>向队尾新添加元素，如果队列已满，返回false。如果队列没有满，添加元素，添加成功后采用CAS操作更新队列容量，如果当前容量小于最大的容量（注意这里cas拿到的c是旧值），则唤醒因为队列已满，添加元素被阻塞的线程。如果之前队列为空，则唤醒因为队列为空，删除元素被阻塞的线程。</p>
<p>add方法调用父类的方法，父类的方法会调用offer方法，最终add方法实际就是调用offer方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h4><p>向队尾新添加元素。向队列末尾新添加元素，如果队列已满，则调用notFull.await()，这里判断需要用while而不能用if，目的是防止<strong>虚假唤醒</strong>。线程被唤醒之后，检查是否已满，如果队列还是满的，则继续等待，如果不是满的，则向队尾添加元素。添加成功后采用CAS操作更新队列容量，如果当前容量小于最大的容量（注意这里cas拿到的c是旧值），则唤醒因为队列已满，添加元素被阻塞的线程。如果之前队列为空，则唤醒因为队列为空，删除元素被阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment"> * necessary for space to become available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">            * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">            * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">            * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">            * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">            * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="offer-E-e-long-timeout-TimeUnit-unit-方法-1"><a href="#offer-E-e-long-timeout-TimeUnit-unit-方法-1" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)方法"></a>offer(E e, long timeout, TimeUnit unit)方法</h4><p>向队尾新添加元素，可设置最大的阻塞时间。</p>
<p>如果队列中没有可用空间，当前线程就等待， 如果等待时间超过timeout了，那么返回false，表示添加失败。如果被唤醒，则检查队列是否已满，如果没满，则继续添加元素，添加成功后采用CAS操作更新队列容量，如果当前容量小于最大的容量（注意这里cas拿到的c是旧值），则唤醒因为队列已满，添加元素被阻塞的线程。如果之前队列为空，则唤醒因为队列为空，删除元素被阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment"> * necessary up to the specified wait time for space to become available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful, or &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment"> *         the specified waiting time elapses before space is available</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-和poll-方法-1"><a href="#remove-和poll-方法-1" class="headerlink" title="remove()和poll()方法"></a>remove()和poll()方法</h4><p>删除队头元素，如果队列为空，返回null，不为空就删除元素，删除成功后采用CAS操作更新队列容量，最后返回元素。如果当前容量小于0（注意这里cas拿到的c是旧值），则唤醒因为队列为空，删除元素被阻塞的线程。如果之前队列已满，则唤醒因为队列已满，添加元素被阻塞的线程。</p>
<p>remove方法调用父类的方法，父类的方法会调用poll方法，最终remove方法实际就是调用poll方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="take-方法-1"><a href="#take-方法-1" class="headerlink" title="take()方法"></a>take()方法</h4><p>删除队头元素，如果当前容量为0，则等待。否则删除元素。这里判断当前容量不能用if，目的是防止虚假唤醒。如果被唤醒，则检查队里是否有元素，如果有元素，则继续删除元素。删除成功后采用CAS操作更新队列容量，最后返回元素。如果当前容量小于0（注意这里cas拿到的c是旧值），则唤醒因为队列为空，删除元素被阻塞的线程。如果之前队列已满，则唤醒因为队列已满，添加元素被阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="poll-long-timeout-TimeUnit-unit-方法-1"><a href="#poll-long-timeout-TimeUnit-unit-方法-1" class="headerlink" title="poll(long timeout, TimeUnit unit)方法"></a>poll(long timeout, TimeUnit unit)方法</h4><p>删除队头元素，可设置最大的阻塞时间。</p>
<p>如果当前容量为0，则等待，等待超过最大等待时间则返回null。如果被唤醒，则检查队里是否有元素，如果有元，则继续删除元素。删除成功后采用CAS操作更新队列容量，最后返回元素。如果当前容量小于0（注意这里cas拿到的c是旧值），则唤醒因为队列为空，删除元素被阻塞的线程。如果之前队列已满，则唤醒因为队列已满，添加元素被阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="element-与peek-方法-1"><a href="#element-与peek-方法-1" class="headerlink" title="element()与peek() 方法"></a>element()与peek() 方法</h4><p>查看元素，需要放置元素被删除，增加不影响</p>
<p>element方法调用父类的方法，父类的方法会调用peek方法，最终element方法实际就是调用peek方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-Object-o-方法-1"><a href="#remove-Object-o-方法-1" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h4><p>删除指定元素，删除和添加都需要加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="疑问：为什么ArrayBlockingQueue只用单锁？"><a href="#疑问：为什么ArrayBlockingQueue只用单锁？" class="headerlink" title="疑问：为什么ArrayBlockingQueue只用单锁？"></a>疑问：为什么ArrayBlockingQueue只用单锁？</h4><p>目前没有找到确切的答案，但可以确定的是，ArrayBlockingQueue可以使用双锁实现，并且有明显的性能提升。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://pastebin.com/ZD1uFy7S" target="_blank" rel="noopener">ABQ双锁实现代码</a></li>
<li><a href="https://blog.csdn.net/liubenlong007/article/details/102823081" target="_blank" rel="noopener">ABQ为什么只用单锁，以及双锁改造和性能测试</a></li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>无界阻塞队列，基于数组实现的小顶堆，线程安全，CAS</p>
<ol>
<li><p><strong>基于数组实现的小顶堆</strong>，根据元素的CompareTo方法顺序或自定义的comparator比较顺序。关键成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 阻塞队列容量最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">// 阻塞队列中元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 比较器，元素没有实现comparable接口时，需提供比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">// 独占锁，读写线程共用这一把锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">// 读线程等待队列，写线程永远不会阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">// 写线程扩容锁，通过CAS控制，只有一个写线程会将此变量从0变成1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无界阻塞队列，可以声明初始容量，但是会超过初始容量会自动扩容，最大容量为Integer.MAX_VALUE-8。</p>
</li>
<li><p><strong>写线程不阻塞，读线程在队列为空时阻塞</strong>。</p>
<p>当队列为满时，写线程不会阻塞，而会尝试去扩容，扩容成功就继续向阻塞队列写入数据。当队列为空时，读线程会阻塞等待，直到队列不为空，被写线程唤醒。因此该阻塞队列适用于读多于写的场景，不然，写线程过多，会导致内存消耗过大，影响性能。读写线程共用同一把独占锁。</p>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
<li><p><strong>动态扩容</strong>，如果原数组容量小于64，则扩容为原数组容量的2倍+2，否则扩容为原数组容量的3/2倍。</p>
</li>
</ol>
<p>阻塞队列PriorityBlockingQueue从不阻塞写线程，当队列满时，写线程会尝试扩容阻塞队列，扩容成功后再向阻塞队列中新增元素，而当队列元素为空时，会阻塞读线程的读取，当然也有非阻塞的方法（poll）。该阻塞队列适用于读多于写的场景，不然，写线程过多，会导致内存消耗过大，影响性能。阻塞队列采用堆存储结构，因此每次冲阻塞队列取出的元素总是最小元素（或最大元素）。而堆存储需要提供比较器或者元素实现了阻塞接口，否则程序会抛出ClassCastException。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>延迟队列，基于优先队列，线程安全，无界</p>
<ol>
<li><p>DelayQueue是一个使用优先队列（PriorityQueue）实现的BlockingQueue，优先队列的比较基准值是时间。本质上即：DelayQueue = BlockingQueue +PriorityQueue + Delayed。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列中<strong>只能存放实现Delayed接口的对象</strong>，而此接口有两个需要实现的方法。最重要的就是getDelay，这个方法需要返回对象过期前的时间。简单说，队列在某些方法处理前，会调用此方法来判断对象有没有超时。</p>
</li>
<li><p>关键成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞等待使用了可重入锁，只有一把</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 优先队列，用来对不同延迟任务的排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"><span class="comment">// 这个Leader 有意思，解决了队列头的数据和线程的关联</span></span><br><span class="line"><span class="comment">// 同时解决了其他线程由谁唤醒</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 与Leader Thread配合 唤醒等待的Leader或者新Leader替换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重入锁是非公平的</strong>，且不支持设置。</p>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
<li><p>动态扩容，依赖PriorityQueue动态扩容。</p>
</li>
</ol>
<h4 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element with an expired delay is available on this queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出延迟的实现原理就是用到了 Condition.awaitNanos(delay) 方法。先 peek 看看有没有元素，再看看元素有没有过期，过期就 poll 取出，还没过期就是 await 等待。<br>这里有两点需要注意：</p>
<ol>
<li><p>leader线程的作用，下面是官方的说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread designated to wait for the element at the head of</span></span><br><span class="line"><span class="comment"> * the queue.  This variant of the Leader-Follower pattern</span></span><br><span class="line"><span class="comment"> * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to</span></span><br><span class="line"><span class="comment"> * minimize unnecessary timed waiting.  When a thread becomes</span></span><br><span class="line"><span class="comment"> * the leader, it waits only for the next delay to elapse, but</span></span><br><span class="line"><span class="comment"> * other threads await indefinitely.  The leader thread must</span></span><br><span class="line"><span class="comment"> * signal some other thread before returning from take() or</span></span><br><span class="line"><span class="comment"> * poll(...), unless some other thread becomes leader in the</span></span><br><span class="line"><span class="comment"> * interim.  Whenever the head of the queue is replaced with</span></span><br><span class="line"><span class="comment"> * an element with an earlier expiration time, the leader</span></span><br><span class="line"><span class="comment"> * field is invalidated by being reset to null, and some</span></span><br><span class="line"><span class="comment"> * waiting thread, but not necessarily the current leader, is</span></span><br><span class="line"><span class="comment"> * signalled.  So waiting threads must be prepared to acquire</span></span><br><span class="line"><span class="comment"> * and lose leadership while waiting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>说了是用到 <strong>Leader-Follower 模式</strong>。如果一个线程是 leader 线程，那么它只会等待available.awaitNanos(delay) 这么多时间，其他后来的 follower 线程只能干等。意思就是一定是 leader 线程先取到头元素，其他线程需要等待 leader 线程的唤醒。这样就可以简化竞争的操作，直接让后面的线程等待，把竞争交给 Condition 来做。</p>
</li>
<li><p>first == null</p>
<p><strong>目的是为了做 GC</strong>。假设没有这一句，那么这里很有可能是 follower 线程在等待的过程中一直持有 first 的引用，而 leader 线程已经完成任务了，都把 first 都释放了，原来希望被回收的 first 却一直没有被回收。在极端的情况下，在一瞬间高并发，会有大量的 follower 线程持有 first，而需要等这些线程都会唤醒后，first 才会被释放回收。</p>
</li>
</ol>
<h4 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h4><p>offer 方法，add 和 put 最终还是调到 offer 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this delay queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放入元素，如果插入的元素是放在了头部的话：</p>
<ol>
<li>把 leader 线程置为 null。因为 leader 的意义就是想要取头元素的那个线程，那么旧的 leader 将没有意义。</li>
<li>唤醒在等待的线程。原本线程都在等待头元素，但是头元素改变了，就唤醒一个线程让它重新取出头元素，并成为新的 leader （看 take 方法里面是一个 for 的死循环）。</li>
</ol>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>内部没有容器，线程安全，无锁，CAS，配对通信机制</p>
<ol>
<li><p><strong>内部没有容器</strong>，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。使用实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"put thread start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"put thread end"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"take thread start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"take from putThread: "</span> + queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">"take thread end"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">put thread start</span><br><span class="line">take thread start</span><br><span class="line">take from putThread: <span class="number">1</span></span><br><span class="line">put thread end</span><br><span class="line">take thread end</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认非公平模型（基于栈所以是后进先出），支持公平模型（基于队列，先进先出）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平模式下，底层实现使用的是TransferQueue这个内部队列，它有一个head和tail指针，用于指向当前正在等待匹配的线程节点。公平策略总结下来就是：<strong>队尾匹配队头出队</strong>。</p>
<p>非公平模式下，底层实现使用的是TransferStack这个内部栈，有一个head指针指向栈顶。</p>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
</ol>
<p>参考资料：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/29227508" target="_blank" rel="noopener">SynchronousQueue实现原理</a></li>
<li><a href="https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/currency/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%9711%EF%BC%9A%E8%A7%A3%E8%AF%BB%20Java%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%20BlockingQueue.md#blockingqueue-%E5%AE%9E%E7%8E%B0%E4%B9%8B-synchronousqueue" target="_blank" rel="noopener">BlockingQueue 实现之 SynchronousQueue</a></li>
</ol>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>无界，基于单链表，无锁，线程安全，双重队列</p>
<ol>
<li><p>实现了TransferQueue接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3223113410248163686L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//该方法放入元素后，一定要被消费者消费后，线程才释放，否则会一直堵塞</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryTransfer 和上面的 transfer 方法相比，</span></span><br><span class="line"><span class="comment">     * 该方入队元素后，无论是否消费都立即返回</span></span><br><span class="line"><span class="comment">     * 如果没有消费者接收元素，则元素不入队，返回的是 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法加入了时间等待，假设超过时间没有消费者线程接收</span></span><br><span class="line"><span class="comment">     * 则元素不会入队，并返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  判断是否有等待中的客户端线程</span></span><br><span class="line"><span class="comment">     */</span>       </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取等待接收元素的消费者数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取处理器数量，判断是否是多个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> MP =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自旋次数，阻塞前的自旋次数（这里向左偏移，一定是 2 的 n 次方）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="comment">//自旋次数，一样是为 2 的 n 次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//达到该阈值时关闭</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重队列，放取元素使用同一个队列，队列中的节点具有两种模式，一种是数据节点，一种是非数据节点。</p>
<p>放元素时先跟队列头节点对比，如果头节点是非数据节点，就让他们匹配，如果头节点是数据节点，就生成一个数据节点放在队列尾端（入队）。    </p>
<p>取元素时也是先跟队列头节点对比，如果头节点是数据节点，就让他们匹配，如果头节点是非数据节点，就生成一个非数据节点放在队列尾端（入队）。</p>
<p>不管是放元素还是取元素，都先跟头节点对比，如果二者模式不一样就匹配它们，如果二者模式一样，就入队。</p>
</li>
<li><p>基于单链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是数据节点（也就标识了是生产者还是消费者）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;   <span class="comment">// false if this is a request node</span></span><br><span class="line">    <span class="comment">// 元素的值</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;   <span class="comment">// initially non-null if isData; CASed to match</span></span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 持有元素的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter; <span class="comment">// null until waiting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型的单链表结构，内部除了存储元素的值和下一个节点的指针外，还包含了是否为数据节点和持有元素的线程。内部通过isData区分是生产者还是消费者。</p>
</li>
<li><p>无界的一个阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedTransferQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedTransferQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有这两个构造方法，且没有初始容量，所以是无界的一个阻塞队列。</p>
</li>
</ol>
<p><strong>参考资料</strong>：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/64002492" target="_blank" rel="noopener">死磕 java集合之LinkedTransferQueue源码分析</a></li>
<li><a href="https://www.jianshu.com/p/328e0d022f75" target="_blank" rel="noopener">LinkedTransferQueue详解</a></li>
<li><a href="https://segmentfault.com/a/1190000016460411" target="_blank" rel="noopener">J.U.C之collections框架：LinkedTransferQueue</a></li>
</ol>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>基于双向链表，双端阻塞队列，线程安全，有界队列</p>
<ol>
<li><p>LinkedBlockingDeque有 LinkedBlockingQueue的所有方法，并且还提供了双端队列的一些其他方法。可以向队尾添加元素，也可以向队头添加元素，删除同理。</p>
</li>
<li><p><strong>有界队列</strong>，默认和最大长度为 Integer.MAX_VALUE，并且<strong>可以指定lock使用公平锁还是非公平锁</strong>。</p>
</li>
<li><p><strong>不允许插入null</strong></p>
</li>
<li><p><strong>线程安全</strong></p>
</li>
<li><p><strong>不支持fail-fast</strong>机制</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>LinkedBlockingDeque和LinkedBlockingQueue的相同点在于：</p>
<ol>
<li>基于链表</li>
<li>容量可选，不设置的话，就是Int的最大值</li>
</ol>
<p>和LinkedBlockingQueue的不同点在于：</p>
<ol>
<li>双端链表和单链表</li>
<li>LinkedBlockingDeque不存在头节点</li>
<li>LinkedBlockingDeque是基于单锁实现</li>
</ol>
<p><strong>参考资料</strong>：</p>
<ol>
<li><a href="https://www.jianshu.com/p/91d9f434da91" target="_blank" rel="noopener">说说LinkedBlockingDeque</a></li>
</ol>
<h4 id="疑问：为什么LinkedBlockingDeque不能像LinkedBlockingQueue使用双锁？"><a href="#疑问：为什么LinkedBlockingDeque不能像LinkedBlockingQueue使用双锁？" class="headerlink" title="疑问：为什么LinkedBlockingDeque不能像LinkedBlockingQueue使用双锁？"></a>疑问：为什么LinkedBlockingDeque不能像LinkedBlockingQueue使用双锁？</h4><p>关键在于：<strong>LinkedBlockingDeque使用双锁无法像LinkedBlockingQueue细化并发粒度</strong>。</p>
<ul>
<li><p>先从现有的实现分析：</p>
<p>现有实现基于单锁，2个条件notEmply，notFull</p>
<ol>
<li>假设队列已满，A线程调用putLast方法，发现队列已满，调用notFull.await方法进入阻塞状态</li>
<li>然后，B线程调用putFirst方法，发现队列已满，调用notFull.await方法进入阻塞状态</li>
<li>然后，C线程调用takeLast方法，然后再调用notFull.signal方法唤醒A、B线程。</li>
</ol>
</li>
<li><p>然后分析双锁如何实现LinkedBlockingDeque：</p>
<p>我们参考LinkedBlockingQueue使用双锁：</p>
<p>putLock，takeLock，notEmply = putLock.newCondition()，notFull = takeLock.newCondition()</p>
<p>但是很遗憾，这样是不行的。因为如果根据操作类型区分锁的话，队头和队尾就可以同时删除，同时添加（因为是两把不同的独占锁）。</p>
<p>那就换个思路，根据头尾节点区分锁，分别叫做lastlock，firstlock，因为头尾节点既可以添加元素也可以删除元素，所以需要四个条件，假设分别是lastNotEmply，lastNotFull，firstNotEmply，firstNotFull。</p>
<p>这样看起来似乎是可行的（实际也是可实现的，但是跟单锁+2个条件效果一样），依然用上面的例子：</p>
<ol>
<li>假设队列已满，A线程调用putLast方法，发现队列已满，调用lastNotFull.await方法进入阻塞状态</li>
<li>然后，B线程调用putFirst方法，发现队列已满，调用firstNotFull.await方法进入阻塞状态</li>
<li>然后，C线程调用takeLast方法，这个时候问题来了，因为我们需要同时唤醒AB，所以需要分别调用lastNotFull.signal，firstNotFull.signal。</li>
</ol>
<p>仔细一想，这和单锁+2个条件是一个意思啊，所以干脆直接用单锁实现了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Queue</tag>
        <tag>Deque</tag>
        <tag>ArrayDeque</tag>
        <tag>PriorityQueue</tag>
        <tag>ConcurrentLinkedQueue</tag>
        <tag>ConcurrentLinkedDeque</tag>
        <tag>BlockingQueue</tag>
        <tag>ArrayBlockingQueue</tag>
        <tag>LinkedBlockingQueue</tag>
        <tag>PriorityBlockingQueue</tag>
        <tag>DelayQueue</tag>
        <tag>SynchronousQueue</tag>
        <tag>LinkedTransferQueue</tag>
        <tag>LinkedBlockingDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>Kylin环境搭建</title>
    <url>/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文详细描述了安装Kylin单点环境的过程和步骤</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol>
<li>Zookeeper已启动</li>
<li>Hadoop已启动</li>
<li>HBase已启动</li>
</ol>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul>
<li>操作系统： CentOS 7</li>
<li>Hadoop版本： Hadoop 3.2.1</li>
<li>Zookeeper版本： Zookeeper3.4.14</li>
<li>HBase版本： hbase-2.3.0</li>
<li>JDK版本：1.8</li>
</ul>
<a id="more"></a>

<h2 id="下载、解压"><a href="#下载、解压" class="headerlink" title="下载、解压"></a>下载、解压</h2><p>下载Kylin安装包<code>apache-kylin-3.1.0-bin-hadoop3.tar.gz</code>并上传至服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf apache-kylin-3.1.0-bin-hadoop3.tar.gz</span><br></pre></td></tr></table></figure>

<p>由于新版kylin安装包中不带spark，所以需要自行下载spark，这里下载的是<a href="http://archive.apache.org/dist/spark/spark-2.4.6/spark-2.4.6-bin-hadoop2.7.tgz" target="_blank" rel="noopener">spark-2.4.6-bin-hadoop2.7.tgz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf spark-2.4.6-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure>

<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在配置文件末尾添加以下内容，注意路径替换成自己真实路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> spark enviroment</span></span><br><span class="line">export SPARK_HOME=/opt/spark-2.4.6</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> kylin enviroment</span></span><br><span class="line">export KYLIN_HOME=/opt/kylin-3.1.0</span><br><span class="line">export PATH=$PATH:$KYLIN_HOME/bin</span><br><span class="line">export PATH=$PATH:$KYLIN_HOME/sbin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使环境变量生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="检查运行环境"><a href="#检查运行环境" class="headerlink" title="检查运行环境"></a>检查运行环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">KYLIN_HOME/bin/check-env.sh</span></span><br></pre></td></tr></table></figure>

<p>控制台输出如下（如果您的环境存在任何的问题，脚本将打印出详细报错信息。如果没有报错信息，代表您的环境适合 Kylin 运行）：</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/check-env.png" class="" title="check-env">

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">KYLIN_HOME/bin/kylin.sh start</span></span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/start_1.png" class="" title="start_1">

<p><strong>启动报错hbase-common lib not found</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到hbase安装目录下的/bin/hbase文件</span></span><br><span class="line">vim /opt/hbase-2.3.0/bin/hbase</span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到 CLASSPATH=<span class="variable">$&#123;CLASSPATH&#125;</span>:<span class="variable">$JAVA_HOME</span>/lib/tools.jar 这行，修改为</span></span><br><span class="line">CLASSPATH=$&#123;CLASSPATH&#125;:$JAVA_HOME/lib/tools.jar:$HBASE_HOME/lib/*</span><br></pre></td></tr></table></figure>

<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/start_2.png" class="" title="start_2">

<p><strong>发现zookeeper地址不对</strong>，检查HBase的配置文件<code>hbase-site.xml</code>，发现zookeeper地址那多配置了端口</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/start_2_1.png" class="" title="start_2_1">

<p>修改为：</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/start_2_2.png" class="" title="start_2_2">

<p>重启hbase，继续启动kylin</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/start_3.png" class="" title="start_3">

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="kylin无法从Hive中同步"><a href="#kylin无法从Hive中同步" class="headerlink" title="kylin无法从Hive中同步"></a>kylin无法从Hive中同步</h3><p><strong>load table metadata from tree时</strong>，加载不出hive的元数据，如下图所示：</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/error_1.png" class="" title="error_1">

<p>查看Hive的元数据表，如图：</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/error_2.png" class="" title="error_2">

<p>发现：<strong>kylin查询的字段和hive中的字段名字不匹配</strong></p>
<p>解决办法：在dbs表中添加一个字段名<code>CATALOG_NAME</code>，属性设置和<code>CTLG_NAME</code>字段一样</p>
<img src="/2020/07/31/Kylin%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/error_3.png" class="" title="error_3">

<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>Kylin和Hive版本不兼容。。。未解决</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Kylin</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL环境搭建</title>
    <url>/2020/10/16/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>MySQL版本：8.0.20</p>
<a id="more"></a>

<h2 id="docker搭建MySQL8"><a href="#docker搭建MySQL8" class="headerlink" title="docker搭建MySQL8"></a>docker搭建MySQL8</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>直接使用下面的docker-compose.yml，用<code>docker-compose up -d</code>启动</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.20</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">jTc7Y9AFzMRp083Ubw5s</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>

<p>此时应该已经能够正常连接，但如果需要修改配置文件，我们还需要将配置文件从容器中复制出来（不能一开始就映射，因为配置文件不会自动生成）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp mysql:/etc/mysql /usr/mysql/config</span><br></pre></td></tr></table></figure>

<p>需要修改配置文件则修改/usr/mysql/config/my.conf文件</p>
<p>最后修改docker-compose.yml，添加配置文件映射，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/etc/mysql</span></span><br></pre></td></tr></table></figure>

<p>映射完配置文件后需要重启镜像，使用<code>docker-compose up</code>重启容器。</p>
<h2 id="慢查询日志配置"><a href="#慢查询日志配置" class="headerlink" title="慢查询日志配置"></a>慢查询日志配置</h2><p>参考my.conf配置说明，修改my.conf，添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=2</span><br><span class="line">slow_query_log_file=mysql-slow.log</span><br></pre></td></tr></table></figure>

<p>使用<code>sleep()</code>函数，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sleep</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>查看慢查询日志文件</p>
<img src="/2020/10/16/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png" class="" title="慢查询日志">

<h2 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h2><h3 id="配置主库"><a href="#配置主库" class="headerlink" title="配置主库"></a>配置主库</h3><p>参考my.conf配置说明，修改my.conf，添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server-id=1</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=ROW</span><br><span class="line">binlog-do-db=chirp</span><br><span class="line">expire_logs_days=7</span><br></pre></td></tr></table></figure>

<p>修改配置后重启数据库</p>
<h3 id="配置从库"><a href="#配置从库" class="headerlink" title="配置从库"></a>配置从库</h3><p>修改my.conf，添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server-id=2</span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<p>修改配置后重启数据库</p>
<h3 id="创建账户并授权"><a href="#创建账户并授权" class="headerlink" title="创建账户并授权"></a>创建账户并授权</h3><p>当前也可以直接使用root账户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER 'slave1'@'%' IDENTIFIED WITH mysql_native_password BY 'slave123456';</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%';</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h3 id="查看主库状态"><a href="#查看主库状态" class="headerlink" title="查看主库状态"></a>查看主库状态</h3><img src="/2020/10/16/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B61.png" class="" title="主从复制1">

<p>记录下File和Position的值</p>
<h3 id="在从库节点上设置主库节点参数"><a href="#在从库节点上设置主库节点参数" class="headerlink" title="在从库节点上设置主库节点参数"></a>在从库节点上设置主库节点参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST='10.86.52.74',</span><br><span class="line">MASTER_PORT=3306,</span><br><span class="line">MASTER_USER='slave1',</span><br><span class="line">MASTER_PASSWORD='slave123456',</span><br><span class="line">MASTER_LOG_FILE='mysql-bin.000001',</span><br><span class="line">MASTER_LOG_POS=837;</span><br></pre></td></tr></table></figure>

<h3 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h3><p>启动主从复制：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>查看状态：</p>
<img src="/2020/10/16/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B62.png" class="" title="主从复制2">

<p>Slave_IO_Running和Slave_SQL_Running的状态都为YES则表示同步成功。</p>
<h2 id="my-conf常见配置说明"><a href="#my-conf常见配置说明" class="headerlink" title="my.conf常见配置说明"></a>my.conf常见配置说明</h2><p>注意：修改配置后需要重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the Free Software Foundation; version 2 of the License.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This program is distributed <span class="keyword">in</span> the hope that it will be useful,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GNU General Public License <span class="keyword">for</span> more details.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> along with this program; <span class="keyword">if</span> not, write to the Free Software</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The MySQL  Server configuration file.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For explanations see</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库数据存放目录</span></span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用DNS主机名查找</span></span><br><span class="line">skip-host-cache</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用主机名缓存</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大连接数</span></span><br><span class="line">max_connections = 400</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单次网络传输的最大值传输量，系统默认值 为1MB，最大值是1GB，必须设置1024的倍数</span></span><br><span class="line">max_allowed_packet = 64M</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器w唯一id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启二进制日志功能，默认不开启</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog格式</span></span><br><span class="line">binlog_format=ROW</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置需要同步的库(可配置多个)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog-do-db=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog-do-db=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置不需要同步的库(可配置多个)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog-ignore-db=mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置binlog自动删除/过期的天数，避免占用磁盘空间。默认值为0，表示不自动删除</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启慢查询日志，默认不开启</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 慢查询阈值，单位为妙</span></span><br><span class="line">long_query_time=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置慢查询文件名</span></span><br><span class="line">slow_query_log_file=mysql-slow.log</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"><span class="meta">#</span><span class="bash"> Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Custom config should go here</span></span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO与零拷贝</title>
    <url>/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>零拷贝是网络编程的关键，很多性能优化都离不开它。</p>
<ul>
<li><strong>零拷贝可以减少用户态与内核态的上下文切换</strong></li>
<li><strong>零拷贝可以减少内存拷贝的次数</strong></li>
</ul>
<a id="more"></a>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h3><p>在没有 DMA 技术前，IO 的过程是这样的：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/DMA_1.jpg" class="" title="DMA">

<ol>
<li>用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回；</li>
<li>CPU 在接收到指令以后对磁盘发起 IO 请求，将磁盘数据先放入磁盘控制器缓冲区；</li>
<li>数据准备完成以后，磁盘向 CPU 发起 IO 中断；</li>
<li>CPU 收到 IO 中断以后将磁盘缓冲区中的数据拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户缓冲区；</li>
<li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟；</li>
</ol>
<p>整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。于是就发明了 <strong>DMA</strong> 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> ，简单理解就是，<strong>在进行 IO 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p>使用 DMA 控制器进行数据传输的过程是这样的：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/DMA_2.jpg" class="" title="DMA">

<ol>
<li>用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。</li>
<li>CPU 在接收到指令以后对 DMA 磁盘控制器发起调度指令。</li>
<li>DMA 磁盘控制器对磁盘发起 IO 请求，将磁盘数据先放入磁盘控制器缓冲区，CPU 全程不参与此过程。</li>
<li>数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据从磁盘控制器缓冲区拷贝到内核缓冲区。</li>
<li>DMA 磁盘控制器向 CPU 发出数据读完的信号，由 CPU 负责将数据从内核缓冲区拷贝到用户缓冲区。</li>
<li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。</li>
</ol>
<p>整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p>
<p>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p>
<h3 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h3><p><strong>PageCache，也叫内核缓冲区</strong>。读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把读写磁盘替换成读写内存，但内存空间比较小，所以 <strong>PageCache 用来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存</strong>。</p>
<p>读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<h4 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h4><p>考虑到磁盘IO是非常高昂的操作，操作系统做了预读的优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。</p>
<h4 id="后写"><a href="#后写" class="headerlink" title="后写"></a>后写</h4><p>将很多小的逻辑写操作合并起来组成一个大的物理写操作。</p>
<p>预读和后写大大提高读写磁盘的性能。</p>
<h3 id="缓存IO和直接IO"><a href="#缓存IO和直接IO" class="headerlink" title="缓存IO和直接IO"></a>缓存IO和直接IO</h3><ul>
<li>缓存IO：数据从磁盘先通过DMA copy到内核空间，再从内核空间通过cpu copy到用户空间</li>
<li>直接IO：数据从磁盘通过DMA copy到用户空间</li>
</ul>
<p>绕开 PageCache 的 IO 叫直接 IO，使用 PageCache 的 IO 则叫缓存 IO。</p>
<p>通常，对于磁盘，<strong>异步 IO 只支持直接 IO</strong>。</p>
<p>缓存 IO 又被称为标准 IO，大多数文件系统的<strong>默认IO操作都是缓存IO</strong>。这样可以直接利用 PageCache 的优化。</p>
<p>缓存 IO 的缺点：</p>
<ul>
<li>不适用大文件传输，大文件传输会导致热点小文件无法利用到 PageCache；</li>
</ul>
<p><strong>针对大文件的传输的方式，应该使用 异步 IO + 直接 IO 来替代零拷贝技术。</strong></p>
<p>直接IO 的应用场景：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 IO，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致热点文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 IO。</li>
</ul>
<p>传输文件的时候，我们可以根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用 <strong>异步 IO + 直接 IO</strong>（直接IO也可认为是一种零拷贝技术）；</li>
<li>传输小文件的时候，则使用 <strong>零拷贝技术</strong></li>
</ul>
<h2 id="传统IO方式"><a href="#传统IO方式" class="headerlink" title="传统IO方式"></a>传统IO方式</h2><p>在 Linux 系统中，传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口。如下图所示：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D_1.jpg" class="" title="零拷贝">

<p>这两个系统调用，会<strong>发生 4 次用户态与内核态的上下文切换</strong>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ol>
<li>把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li>把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li>把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li>把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ol>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>要想提高文件传输的性能，就<strong>需要减少 用户态与内核态的上下文切换 和 内存拷贝 的次数</strong>。</p>
<p>一次系统调用必然会发生 2 次上下文切换，所以<strong>要想减少上下文切换次数，就要减少系统调用次数</strong>。</p>
<p>传统的文件传输方式会经历 4 次数据拷贝，从内核的读缓冲区拷贝到用户的缓冲区后，并没有对数据进行再加工，就从用户的缓冲区里又拷贝到 socket 的缓冲区里，因此将数据拷贝到用户的缓冲区是没有必要的，可以<strong>直接从内核的读缓冲区拷贝到socket的缓冲区</strong>。</p>
<h2 id="零拷贝方式"><a href="#零拷贝方式" class="headerlink" title="零拷贝方式"></a>零拷贝方式</h2><p>零拷贝技术实现的方式通常有：</p>
<ul>
<li><strong>mmap + write</strong></li>
<li><strong>sendfile</strong></li>
<li><strong>splice</strong></li>
</ul>
<h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p>在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。</p>
<p>mmap() 系统调用函数会直接<strong>把内核缓冲区里的数据映射到用户空间</strong>，这样操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。如下图</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D_2.jpg" class="" title="零拷贝">

<ol>
<li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核会<strong>共享</strong>这个缓冲区；</li>
<li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ol>
<p>通过使用 mmap() 来代替 read()， 可以<strong>减少一次数据拷贝的过程</strong>。但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且<strong>仍然需要 4 次上下文切换</strong>，因为系统调用还是 2 次。</p>
<p>mmap 主要的用处是提高 I/O 性能，特别是针对大文件。<strong>对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界</strong>，最小单位是 4 KB，一个 5 KB 的文件将会映射占用 8 KB 内存，也就会浪费 3 KB 内存。</p>
<p>mmap 的拷贝虽然减少了 1 次拷贝，提升了效率，但也存在一些隐藏的问题。当 mmap 一个文件时，如果这个文件被另一个进程所截获，那么 write 系统调用会因为访问非法地址被 SIGBUS 信号终止，SIGBUS 默认会杀死进程并产生一个 coredump，<strong>服务器可能因此被终止</strong>。</p>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就<strong>减少了 2 次上下文切换的开销</strong>。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就<strong>只有 2 次上下文切换，和 3 次数据拷贝</strong>。如下图：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D_3.jpg" class="" title="零拷贝">

<p><strong>sendfile 存在的问题是用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程。</strong></p>
<h3 id="sendfile-SG-DMA"><a href="#sendfile-SG-DMA" class="headerlink" title="sendfile + SG-DMA"></a>sendfile + SG-DMA</h3><p>上面还不是真正的零拷贝技术，如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术，我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ethtool -k eth0 | grep scatter-gather</span><br></pre></td></tr></table></figure>

<p>于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：</p>
<ol>
<li>通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ol>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D_4.jpg" class="" title="零拷贝">

<p>这就是所谓的<strong>零拷贝（Zero-copy）</strong>技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p>
<p><strong>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>sendfile + SG-DMA 的方式同样存在<strong>用户程序不能对数据进行修改的问题</strong>，<strong>而且本身需要硬件的支持</strong>，它只适用于将数据从文件拷贝到 socket 套接字上的传输过程。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>Linux 在 2.6.17 版本引入 splice 系统调用，splice 去掉 sendfile 的使用范围限制，可以用于任意两个文件描述符中传输数据。</p>
<p>但是 splice 也有局限，它使用了 Linux 的管道缓冲机制，所以，它的两个文件描述符参数中至少有一个必须是管道设备。</p>
<p>基于 splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p>
<ol>
<li>用户进程通过 splice() 函数向内核发起系统调用，上下文从用户态切换为内核态。</li>
<li>DMA 控制器将数据从主存或硬盘拷贝到内核空间的读缓冲区（read buffer）。</li>
<li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li>
<li>DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li>
<li>上下文从内核态切换回用户态，splice 系统调用执行返回。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">CPU拷贝</th>
<th align="center">DMA拷贝</th>
<th align="center">系统调用</th>
<th align="center">上下文切换</th>
<th align="center">是否可修改数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read + write</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">read + write</td>
<td align="center">4</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">mmap + wirte</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">mmap + write</td>
<td align="center">4</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">sendfile</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">sendfile</td>
<td align="center">2</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">sendfile + SG-DMA</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">sendfile</td>
<td align="center">2</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">splice</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">splice</td>
<td align="center">2</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">directio + aio</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">read + write</td>
<td align="center">4</td>
<td align="center">是</td>
</tr>
</tbody></table>
<ul>
<li>大文件传输，使用 <strong>directio + aio</strong></li>
<li>小文件传输，需要修改数据使用 <strong>mmap + wirte</strong></li>
<li>小文件传输，无需修改数据使用 <strong>sendfile</strong></li>
<li>小文件传输，无需修改数据，且不支持 SG-DMA，有一个文件描述符是管道设备，使用 <strong>splice</strong></li>
</ul>
<h2 id="NIO零拷贝实现"><a href="#NIO零拷贝实现" class="headerlink" title="NIO零拷贝实现"></a>NIO零拷贝实现</h2><p>NIO 的核心是 Channel，Buffer 和 Selector，它们的关系如下：</p>
<img src="/2020/10/25/NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/NIO.png" class="" title="NIO">

<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>FileChannel 是NIO中一个用于文件读写、映射和操作的通道，同时它在并发环境下是线程安全的。</p>
<p>FileChannel 定义了 transferFrom() 和 transferTo() 两个抽象方法，它们是 <strong>NIO 基于 sendfile 这种零拷贝方式的一种实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把文件里面的源数据写入一个 WritableByteChannel 的目的通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</span><br><span class="line"><span class="comment">// 把一个源通道 ReadableByteChannel 中的数据读取到当前 FileChannel 的文件里面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>transferTo使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sourceFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\source.txt"</span>;</span><br><span class="line">    String targetFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\target.txt"</span>;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel sourceCh = <span class="keyword">new</span> RandomAccessFile(sourceFile, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">         FileChannel targetCh = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>).getChannel()) &#123;</span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> offset = sourceCh.size();</span><br><span class="line">        sourceCh.transferTo(position, offset, targetCh);</span><br><span class="line">        targetCh.force(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transferFrom使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferFrom</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sourceFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\source.txt"</span>;</span><br><span class="line">    String targetFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\target.txt"</span>;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel sourceCh = <span class="keyword">new</span> RandomAccessFile(sourceFile, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">         FileChannel targetCh = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>).getChannel()) &#123;</span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> offset = sourceCh.size();</span><br><span class="line">        targetCh.transferFrom(sourceCh, position, offset);</span><br><span class="line">        targetCh.force(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>force方法：将通道里尚未写入磁盘的数据强制写到磁盘上。</strong></p>
<p>出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法，例如：targetCh.force(true)。</p>
<p>transferTo源码实现（sun.nio.ch.FileChannelImpl类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                       WritableByteChannel target)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (!target.isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">    <span class="keyword">if</span> (!readable)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonReadableChannelException();</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> FileChannelImpl &amp;&amp;</span><br><span class="line">        !((FileChannelImpl)target).writable)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonWritableChannelException();</span><br><span class="line">    <span class="keyword">if</span> ((position &lt; <span class="number">0</span>) || (count &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">long</span> sz = size();</span><br><span class="line">    <span class="keyword">if</span> (position &gt; sz)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> icount = (<span class="keyword">int</span>)Math.min(count, Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">if</span> ((sz - position) &lt; icount)</span><br><span class="line">        icount = (<span class="keyword">int</span>)(sz - position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt a direct transfer, if the kernel supports it</span></span><br><span class="line">    <span class="keyword">if</span> ((n = transferToDirectly(position, icount, target)) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// Attempt a mapped transfer, but only to trusted channel types</span></span><br><span class="line">    <span class="keyword">if</span> ((n = transferToTrustedChannel(position, icount, target)) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// Slow path for untrusted targets</span></span><br><span class="line">    <span class="keyword">return</span> transferToArbitraryChannel(position, icount, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先执行 transferToDirectly 方法，以 sendfile 的零拷贝方式尝试数据拷贝。</li>
<li>如果系统内核不支持 sendfile，进一步执行 transferToTrustedChannel() 方法，以 mmap 的零拷贝方式进行内存映射，这种情况下目的通道必须是 FileChannelImpl或者 SelChImpl 类型。</li>
<li>如果都失败了，则执行 transferToArbitraryChannel 方法，基于传统的 I/O 方式完成读写。</li>
</ol>
<h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p><strong>MappedByteBuffer 是 NIO 基于内存映射（mmap）这种零拷贝方式的一种实现</strong>。它继承自 ByteBuffer，通过 FileChannel 的 map 方法创建，可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>mode：限定内存映射区域（MappedByteBuffer）对内存映像文件的访问模式，包括只可读（READ_ONLY）、可读可写（READ_WRITE）和写时拷贝（PRIVATE）三种模式。</li>
<li>position：文件映射的起始地址，对应内存映射区域（MappedByteBuffer）的首地址。</li>
<li>size：文件映射的字节长度，从 position 往后的字节数，对应内存映射区域（MappedByteBuffer）的大小。</li>
</ul>
<p>MappedByteBuffer 相比 ByteBuffer 新增了三个重要方法：</p>
<ul>
<li>force()：对于处于 READ_WRITE 模式下的缓冲区，把对缓冲区内容的修改强制刷新到本地文件。</li>
<li>load()：将缓冲区的内容载入物理内存中，并返回这个缓冲区的引用。</li>
<li>isLoaded()：如果缓冲区的内容在物理内存中，则返回 true，否则返回 false。</li>
</ul>
<p>MappedByteBuffer 使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToFileByMappedByteBuffer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sourceFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\source.txt"</span>;</span><br><span class="line">    String targetFile = <span class="string">"C:\\Users\\Administrator\\Desktop\\target.txt"</span>;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel sourceCh = <span class="keyword">new</span> RandomAccessFile(sourceFile, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">         FileChannel targetCh = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>).getChannel()) &#123;</span><br><span class="line">        ByteBuffer sourceBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) sourceCh.size());</span><br><span class="line">        sourceCh.read(sourceBuffer);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = sourceBuffer.array();</span><br><span class="line">        MappedByteBuffer mappedByteBuffer = targetCh.map(FileChannel.MapMode.READ_WRITE, </span><br><span class="line">                                                         <span class="number">0</span>, bytes.length);</span><br><span class="line">        mappedByteBuffer.put(bytes);</span><br><span class="line">        mappedByteBuffer.force();</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        Cleaner cl = ((DirectBuffer)mappedByteBuffer).cleaner();</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="keyword">null</span>)</span><br><span class="line">                cl.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map 方法源码实现（sun.nio.ch.FileChannelImpl类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 由于代码较长，只保留核心</span></span><br><span class="line">        <span class="keyword">int</span> pagePosition = (<span class="keyword">int</span>)(position % allocationGranularity);</span><br><span class="line">        <span class="keyword">long</span> mapPosition = position - pagePosition;</span><br><span class="line">        <span class="keyword">long</span> mapSize = size + pagePosition;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If no exception was thrown from map0, the address is valid</span></span><br><span class="line">            addr = map0(imode, mapPosition, mapSize);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">            <span class="comment">// An OutOfMemoryError may indicate that we've exhausted memory</span></span><br><span class="line">            <span class="comment">// so force gc and re-attempt map</span></span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException y) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addr = map0(imode, mapPosition, mapSize);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OutOfMemoryError y) &#123;</span><br><span class="line">                <span class="comment">// After a second OOME, fail</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Map failed"</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// On Windows, and potentially other platforms, we need an open</span></span><br><span class="line">        <span class="comment">// file descriptor for some mapping operations.</span></span><br><span class="line">        FileDescriptor mfd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mfd = nd.duplicateForMapping(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            unmap0(addr, mapSize);</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> (IOStatus.checkAll(addr));</span><br><span class="line">        <span class="keyword">assert</span> (addr % allocationGranularity == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> isize = (<span class="keyword">int</span>)size;</span><br><span class="line">        Unmapper um = <span class="keyword">new</span> Unmapper(addr, mapSize, isize, mfd);</span><br><span class="line">        <span class="keyword">if</span> ((!writable) || (imode == MAP_RO)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Util.newMappedByteBufferR(isize,</span><br><span class="line">                                             addr + pagePosition,</span><br><span class="line">                                             mfd,</span><br><span class="line">                                             um);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Util.newMappedByteBuffer(isize,</span><br><span class="line">                                            addr + pagePosition,</span><br><span class="line">                                            mfd,</span><br><span class="line">                                            um);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threads.remove(ti);</span><br><span class="line">        end(IOStatus.checkAll(addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>map() 方法通过本地方法 map0() 为文件分配一块虚拟内存，作为它的内存映射区域，然后返回这块内存映射区域的起始地址。</li>
<li>如果第一次文件映射导致 OOM，则触发垃圾回收，休眠 100ms 后再尝试映射，如果失败则抛出异常。</li>
<li>通过 Util 类使用反射创建一个 DirectByteBuffer 实例，DirectByteBuffer 是 MappedByteBuffer 的子类。</li>
</ol>
<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>DirectByteBuffer 的对象引用位于 Java 内存模型的堆里面，但内部的字节缓冲区位在于堆外的直接内存。</p>
<p>DirectByteBuffer 初始化时通过 Unsafe 的本地方法 allocateMemory() 进行内存分配，底层调用的是操作系统的 malloc() 函数，除此之外，初始化时还会创建一个 Deallocator 线程，并通过 Cleaner 机制来调用 freeMemory() 方法来对直接内存进行回收操作，freeMemory() 底层调用的是操作系统的 free() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键构造方法</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DirectByteBuffer 中，首先向 Bits 类申请额度，Bits类有一个全局的 totalCapacity 变量，记录着全部DirectByteBuffer 的总大小，每次申请，都先看看是否超限，可用 -XX:MaxDirectMemorySize 重新设定。如果不指定，该参数的默认值为Xmx的值减去1个Survior区的值。 如设置启动参数-Xmx20M -Xmn10M -XX：SurvivorRatio=8，那么申请20M-1M=19M的DirectMemory。</p>
<p>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。System.gc() 会触发一个full gc，当然前提是没有显示的设置 <code>-XX:+DisableExplicitGC</code> 来禁用显式GC。不过，调用 System.gc() 并不能够保证 full gc 马上就能被执行。然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出OOM异常。如果额度被批准，就调用大名鼎鼎的 <code>sun.misc.Unsafe</code> 去分配内存，返回内存基地址。</p>
<p>最后，创建一个Cleaner，并把代表清理动作的Deallocator类绑定 – 降低 Bits 里的totalCapacity，并调用 Unsafe free() 去释放内存。</p>
<h4 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h4><p>Cleaner类继承了 <code>java.lang.ref.Reference</code>，GC线程会通过设置 Reference 的内部变量（pending变量为链表头部节点，discovered变量为下一个链表节点），将可被回收的不可达的Reference对象以链表的方式组织起来Reference的内部守护线程从链表的头部(head)消费数据，如果消费到的Reference对象同时也是Cleaner类型，线程会调用clean()方法。</p>
<p>这里可以看到一种尴尬的情况，因为 DirectByteBuffer 本身的个头很小，只要熬过了 young gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。</p>
<p>这时，就只能靠前面提到的申请额度超限时触发的system.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。如果设置了-DisableExplicitGC禁止了system.gc()，那就不好玩了。</p>
<p>所以，堆外内存还是自己主动点回收更好，比如Netty就是这么做的。DirectByteBuffer主动释放内存如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(<span class="number">1</span>);</span><br><span class="line">((DirectBuffer) byteBuffer).cleaner().clean();</span><br></pre></td></tr></table></figure>

<h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p>假设从网络中读入数据，再发送数据，采用 Non-direct ByteBuffer 的简化流程是这样的：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">网络 –&gt; 临时的<span class="keyword">DirectByteBuffer </span>–&gt; 应用 Non-<span class="keyword">direct </span><span class="keyword">ByteBuffer </span>–&gt; 临时的<span class="keyword">Direct </span><span class="keyword">ByteBuffer </span>–&gt; 网络</span><br></pre></td></tr></table></figure>

<p>采用 Direct ByteBuffer 的流程是这样的：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">网络 –&gt; 应用 <span class="keyword">Direct </span><span class="keyword">ByteBuffer </span>–&gt; 网络</span><br></pre></td></tr></table></figure>

<p>第二种方式是直接在堆外分配一个内存来存储数据， 程序通过 JNI 直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在 JVM 管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p>
<p>从上面的流程可以发现，执行 read() 系统调用之后，无论是采取DirectByteBuffer还是Non-direct ByteBuffer，数据都是从内核缓冲区拷贝到DirectByteBuffer。</p>
<p>那么采用 Non-direct ByteBuffer 时，<strong>为什么不直接将数据拷贝到Non-direct ByteBuffer中呢？</strong></p>
<p>原因是执行native方法的线程，被认为是处于SafePoint，所以会发生 NIO，如果不复制到 DirectByteBuffer，就会有 GC 发生重排列对象内存的情况。</p>
<p>传统 BIO 是面向 Stream 的，底层实现可以理解为写入的是 byte 数组，调用 native 方法写入 IO，传的参数是这个数组，就算GC改变了内存地址，但是拿这个数组的引用照样能找到最新的地址，对应的方法时是：FileOutputStream.write</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> append)</span></span></span><br></pre></td></tr></table></figure>

<p>但是NIO，为了提升效率，传的是内存地址，省去了一次间接应用，但是就必须用 DirectByteBuffer 防止内存地址改变，对应的是 NativeDispatcher.write</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>

<p>那为何内存地址会改变呢？GC会回收无用对象，同时还会进行碎片整理，移动对象在内存中的位置，来减少内存碎片。DirectByteBuffer不受GC控制。如果不用 DirectByteBuffer 而是用 HeapByteBuffer，如果在调用系统调用时，发生了GC，导致 HeapByteBuffer 内存位置发生了变化，但是内核态并不能感知到这个变化导致系统调用读取或者写入错误的数据。<strong>所以一定要通过不受GC影响的DirectByteBuffer来进行IO系统调用</strong>。</p>
<p>除了构造和析构临时 Direct ByteBuffer 的时间外，起码还能节约两次内存拷贝的时间。那么是否在任何情况下都采用Direct Buffer呢？对于大部分应用而言，两次内存拷贝的时间几乎可以忽略不计，而构造和析构DirectBuffer的时间却相对较长。</p>
<p><strong>所以，一般的框架里面，会在启动时申请一大块DirectByteBuffer，然后自己做内存管理。</strong></p>
<h3 id="Netty-noCleaner策略"><a href="#Netty-noCleaner策略" class="headerlink" title="Netty noCleaner策略"></a>Netty noCleaner策略</h3><p>带有Cleaner对象的 DirectByteBuffer 在初始化时：</p>
<ol>
<li>只有在DirectByteBuffer(int cap)构造方法中才会初始化Cleaner对象，方法中检查当前内存是否超过允许的最大堆外内存(可由-XX:MaxDirectMemorySize配置)</li>
<li>如果超出，则会先尝试将不可达的Reference对象加入Reference链表中，依赖Reference的内部守护线程触发可以被回收DirectByteBuffer关联的Cleaner的run()方法</li>
<li>如果内存还是不足， 则执行 System.gc()，触发full gc，来回收堆内存中的DirectByteBuffer对象来触发堆外内存回收，如果还是超过限制，则抛出java.lang.OutOfMemoryError(代码位java.nio.Bits#reserveMemory()方法)</li>
</ol>
<p>Netty 在4.1引入可以 noCleaner 策略：创建不带Cleaner的DirectByteBuffer对象，这样做的好处是绕开带Cleaner的DirectByteBuffer执行构造方法和执行Cleaner的clean()方法中一些额外开销，当堆外内存不够的时候，不会触发 System.gc()，提高性能。</p>
<p>hasCleaner 的 DirectByteBuffer 和 noCleaner的 DirectByteBuffer 主要区别如下：</p>
<ul>
<li>创建方式不同<ul>
<li>由反射调用 private DirectByteBuffer(long addr, int cap)创建；</li>
<li>由 ByteBuffer.allocateDirect() -&gt; new DirectByteBuffer(int cap)创建；</li>
</ul>
</li>
<li>释放内存的方式不同<ul>
<li>noCleaner对象：使用 UnSafe.freeMemory(address)；</li>
<li>hasCleaner对象：使用 DirectByteBuffer 的 Cleaner 的 clean() 方法；</li>
</ul>
</li>
</ul>
<p>Netty在启动时需要判断检查当前环境、环境配置参数是否允许noCleaner策略(具体逻辑位于PlatformDependent的static代码块，也可以调用PlatformDependent.useDirectBufferNoCleaner()方法查看当前Netty程序是否使用noClaner策略)，例如运行在Android下时，是没有Unsafe类的，不允许使用noCleaner策略，如果不允许，则使用hasCleaner策略。</p>
<h3 id="查看DirectBuffer使用情况"><a href="#查看DirectBuffer使用情况" class="headerlink" title="查看DirectBuffer使用情况"></a>查看DirectBuffer使用情况</h3><ol>
<li><p>进程内获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MBeanServer mbs = ManagementFactory. getPlatformMBeanServer() ;</span><br><span class="line">ObjectName objectName = <span class="keyword">new</span> ObjectName(<span class="string">"java.nio:type=BufferPool,name=direct"</span> ) ;</span><br><span class="line">MBeanInfo info = mbs.getMBeanInfo(objectName) ;</span><br><span class="line"><span class="keyword">for</span>(MBeanAttributeInfo i : info.getAttributes()) &#123;</span><br><span class="line">    System.out .println(i.getName() + <span class="string">":"</span> + mbs.getAttribute(objectName , i.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程进程</p>
<p>JMX获取 如果目标机器没有启动JMX，那么添加jvm参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=9999 </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">-Dcom.sun.management.jmxremotAe.ssl=false</span><br></pre></td></tr></table></figure>

<p>重启进程，通过 JConsole 等工具查看</p>
</li>
</ol>
<h2 id="Netty-零拷贝实现"><a href="#Netty-零拷贝实现" class="headerlink" title="Netty 零拷贝实现"></a>Netty 零拷贝实现</h2><p>Netty中零拷贝机制主要体现在以下方面：</p>
<ol>
<li>DefaultFileRegion 类对 java.nio.channels.FileChannel 的 tranferTo() 方法进行包装，在文件传输时可以将文件缓冲区的数据直接发送到目的通道（Channel）</li>
<li>ByteBuf 可以通过 wrap 操作把字节数组、ByteBuf、ByteBuffer 包装成一个 ByteBuf 对象，使用堆外内存。</li>
<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免内存的拷贝。</li>
<li>Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。</li>
</ol>
<p>其中第 1 条属于操作系统层面的零拷贝操作，后面 3 条只能算用户层面的数据操作优化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>零拷贝</tag>
        <tag>mmap</tag>
        <tag>sendfile</tag>
        <tag>splice</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty池化内存机制</title>
    <url>/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Netty作为一款高性能网络应用程序框架，实现了一套高性能内存管理机制。</p>
<a id="more"></a>

<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p><strong>ByteBuf 是 Netty 的数据容器，高效分配 ByteBuf 至关重要。</strong></p>
<h3 id="Heap-和-Direct"><a href="#Heap-和-Direct" class="headerlink" title="Heap 和 Direct"></a><strong>Heap 和 Direct</strong></h3><p><strong>Heap</strong>，指 ByteBuf 关联的内存在 JVM 堆内分配，分配的内存受 GC 管理<br><strong>Direct</strong>，指 ByteBuf 关联的内存在 JVM 堆外分配，分配的内存不受 GC 管理，需要通过系统调用实现申请和释放，底层基于Java NIO的DirectByteBuffer对象</p>
<p><strong>一定要通过不受GC影响的 DirectByteBuffer 来进行IO系统调用。</strong></p>
<h3 id="Pooled-和-Unpooled"><a href="#Pooled-和-Unpooled" class="headerlink" title="Pooled 和 Unpooled"></a><strong>Pooled 和 Unpooled</strong></h3><ul>
<li><strong>Unpooled</strong>：非池化内存每次分配时直接调用系统 API 向操作系统申请 ByteBuf 需要的同样大小内存，用完后通过系统调用进行释放。</li>
<li><strong>Pooled</strong>：池化内存分配时基于预分配的一整块大内存，取其中的部分封装成 ByteBuf 提供使用，用完后回收到内存池中。</li>
</ul>
<p><strong>Netty4 默认使用 Pooled 的方式</strong>，可通过参数 <code>-Dio.netty.allocator.type=Pooled</code> 进行设置。</p>
<p>非池化对象管理</p>
<p>使用时：</p>
<p>通过 Unsafe 的本地方法 <code>allocateMemory()</code> 进行内存分配，底层调用的是操作系统的 <code>malloc()</code> 函数。</p>
<p>用完后：</p>
<p>通过 Unsafe 的本地方法 <code>freeMemory()</code> 进行内存释放，底层调用的是操作系统的 <code>free()</code> 函数。</p>
<h2 id="池化内存的分配"><a href="#池化内存的分配" class="headerlink" title="池化内存的分配"></a>池化内存的分配</h2><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h4 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h4><p>Netty 向系统申请一整块连续内存，称为 chunk，默认大小 chunkSize = 16MB，通过 PoolChunk 对象包装。为了更细粒度的管理，Netty 将 chunk进一步拆分为 page，默认每个 chunk 包含 2048 个 page，pageSize = 8KB。</p>
<p>在同一个chunk中，Netty 将 page 按照不同粒度进行多层分组管理</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%841.jpg" class="" title="page分组">

<ul>
<li>第1层，分组大小size = 1*pageSize，一共有2048个组</li>
<li>第2层，分组大小size = 2*pageSize，一共有1024个组</li>
<li>第3层，分组大小size = 4*pageSize，一共有512个组</li>
<li>…</li>
<li>第12层，分组大小size = 2^(12-1) * pageSize = 2048 * pageSize，一共有2048个组</li>
</ul>
<p>当请求分配内存时，将请求分配的内存数向上取值到最接近的分组大小，在该分组大小的相应层级中从左至右寻找空闲分组。例如请求分配内存对象为<code>1.5 * pageSize</code>，向上取值到分组大小 <code>2 * pageSize</code>，在该层分组中找到完全空闲的一组内存进行分配，如下图：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/page%E5%88%86%E7%BB%842.jpg" class="" title="page分组">

<p>当分组大小 <code>2 *pageSize</code> 的内存分配出去后，为了方便下次内存分配，分组被标记为全部已使用（图中红色标记），向上更粗粒度的内存分组被标记为部分已使用（图中黄色标记）。</p>
<h4 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h4><p><strong>Netty 基于平衡二叉树实现不同粒度的多层分组管理</strong></p>
<p>为了方便快速查找 chunk 中能容纳请求内存的位置，算法构建一个基于byte数组（memoryMap）存储的完全平衡树，该平衡树的多个层级深度，就是前面介绍的按照不同粒度对 chunk进行多层分组：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk.jpg" class="" title="poolChunk">

<p>树的深度depth从0开始计算，各层节点数，每个节点对应的内存大小如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depth &#x3D; 0， 1 node，nodeSize &#x3D; chunkSize</span><br><span class="line">depth &#x3D; 1， 2 nodes，nodeSize &#x3D; chunkSize&#x2F;2</span><br><span class="line">...</span><br><span class="line">depth &#x3D; d， 2^d nodes， nodeSize &#x3D; chunkSize&#x2F;(2^d)</span><br><span class="line">...</span><br><span class="line">depth &#x3D; maxOrder， 2^maxOrder nodes， nodeSize &#x3D; chunkSize&#x2F;2^&#123;maxOrder&#125; &#x3D; pageSize</span><br></pre></td></tr></table></figure>

<p>具有n个结点的完全二叉树的深度为:<br>$$<br>int(\log_2n) + 1<br>$$<br>树的最大深度为 maxOrder = 11（注意 depth从0开始），通过这棵树，算法在chunk中的查找就可以转换为：</p>
<p><strong>当申请分配大小为 chunkSize/2^k 的内存，在平衡树高度为k的层级中，从左到右搜索第一个空闲节点。</strong></p>
<p>数组的使用域从index = 1开始，将平衡树按照层次顺序依次存储在数组中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depth &#x3D; n 的第1个节点保存在 memoryMap[2^n] 中</span><br><span class="line">depth &#x3D; n 的第2个节点保存在 memoryMap[2^n+1] 中</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下图代表已分配 chunkSize/2：</p>
<img src="/2021/03/25/Netty%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/poolChunk2.jpg" class="" title="poolChunk">

<h4 id="申请-释放内存"><a href="#申请-释放内存" class="headerlink" title="申请/释放内存"></a>申请/释放内存</h4><p>内存大小在 <strong>(pageSize/2, chunkSize]</strong> 区间范围内的池化对象的分配原理：</p>
<p>当申请分配内存，会首先将请求分配的内存大小归一化（向上取整为page的整数倍）。例如 8000byte 归一化为8192byte（即8KB），8193byte 归一化为16384byte（16KB）。</p>
<p>当分配已归一化处理后大小为 <code>chunkSize/2^d</code> 的内存，即需要在depth = d的层级中找到第一块空闲内存，算法<strong>从根节点开始遍历</strong> (根节点depth = 0， id = 1)，具体步骤如下：</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><strong>Netty 版本 4.1.52.Final</strong></p>
<h3 id="ByteBuf-1"><a href="#ByteBuf-1" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>Java NIO提供了 <strong>ByteBuffer</strong> 作为它的字节容器，但是这个类使用起来过于复杂和繁琐。Netty用 <strong>ByteBuf</strong> 替代了ByteBuffer，实现了<strong>自动扩容</strong>，也更易使用。</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>ByteBuf 源码中的有段注释画出了结构：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"><span class="symbol">*</span> <span class="variable">&lt;pre&gt;</span></span><br><span class="line"><span class="symbol">*</span>      +-------------------+------------------+------------------+</span><br><span class="line"><span class="symbol">*</span>      |<span class="string"> discardable bytes </span>|<span class="string">  readable bytes  </span>|<span class="string">  writable bytes  </span>|</span><br><span class="line"><span class="symbol">*</span>      |<span class="string">                   </span>|<span class="string">     (CONTENT)    </span>|<span class="string">                  </span>|</span><br><span class="line"><span class="symbol">*</span>      +-------------------+------------------+------------------+</span><br><span class="line"><span class="symbol">*</span>      |<span class="string">                   </span>|<span class="string">                  </span>|<span class="string">                  </span>|</span><br><span class="line"><span class="symbol">*</span>      0      <span class="variable">&lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span></span><br><span class="line"><span class="variable">* &lt;/pre&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readerIndex：记录读指针的开始位置</li>
<li>writerIndex：记录读指针的开始位置</li>
<li>capacity：缓冲区的总长度</li>
</ul>
<p>除了这三个指针，ByteBuf里面其实还有一个指针 maxCapacity，它相当于ByteBuf扩容的最大阈值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the maximum allowed capacity of this buffer. This value provides an upper</span></span><br><span class="line"><span class="comment"> * bound on &#123;<span class="doctag">@link</span> #capacity()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">maxCapacity</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些指针将 ByteBuf 分为以下几个区域：</p>
<ul>
<li>discardable bytes：从 0 到 readerIndex 为 discardable bytes，表示是无效的</li>
<li>readable bytes：从 readerIndex 到 writerIndex 为 readable bytes，表示可读数据区</li>
<li>writable bytes：从 writerIndex 到 capacity 为 writable bytes，表示这段区间空闲，可以往里面写数据</li>
</ul>
<h4 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h4><p>ByteBuf 有众多子类，大致可以从以下维度来进行分类：</p>
<ul>
<li><strong>Pooled和UnPooled</strong>：<ul>
<li><strong>Pooled</strong>：每次申请内存都是从预先分配好的内存空间中提取一段连续内存</li>
<li><strong>Unpooled</strong>：每次申请内存都是新的一次申请</li>
</ul>
</li>
<li><strong>unsafe和非unsafe</strong>：<ul>
<li><strong>unsafe</strong>：调用 native 方法底层直接操作内存</li>
<li><strong>非unsafe</strong>：通过 JDK 的 API 间接操作内存</li>
</ul>
</li>
<li><strong>Heap和Direct</strong>：<ul>
<li><strong>Heap</strong>：指 JVM的堆内存</li>
<li><strong>Direct</strong>：堆外内存，直接调用 JDK 的底层 API 进行物理内存分配，不在 JVM的堆内存中，需要手动释放</li>
</ul>
</li>
</ul>
<p>ByteBuf 最基本的读写 API 操作在 <code>AbstractByteBuf</code> 中已经实现了，其众多子类采用不同的策略来分配内存空间。下面是对重要的几个子类的总结：</p>
<ul>
<li><strong>PooledHeapByteBuf</strong>：池化的堆内缓冲区</li>
<li><strong>PooledUnsafeHeapByteBuf</strong>：池化的Unsafe堆内缓冲区</li>
<li><strong>PooledDirectByteBuf</strong>：池化的堆外缓冲区</li>
<li><strong>PooledUnsafeDirectByteBuf</strong>：池化的Unsafe堆外缓冲区</li>
<li><strong>UnpooledHeapByteBuf</strong>：非池化的堆内缓冲区</li>
<li><strong>UnpooledUnsafeHeapByteBuf</strong>：非池化的Unsafe堆内缓冲区</li>
<li><strong>UnpooledDirectByteBuf</strong>：非池化的堆外缓冲区</li>
<li><strong>UnpooledUnsafeDirectByteBuf</strong>：非池化的Unsafe堆外缓冲区</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>下面是 AbstractByteBuf 的 部分 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取指定字节长度的数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查ByteBuf是否可读取length字节的数据</span></span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Unpooled.EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf buf = alloc().buffer(length, maxCapacity);</span><br><span class="line">    buf.writeBytes(<span class="keyword">this</span>, readerIndex, length);</span><br><span class="line">    <span class="comment">// 移动readerIndex</span></span><br><span class="line">    readerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Throws an &#123;<span class="doctag">@link</span> IndexOutOfBoundsException&#125; if the current</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #readableBytes() readable bytes&#125; of this buffer is less</span></span><br><span class="line"><span class="comment"> * than the specified value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkReadableBytes</span><span class="params">(<span class="keyword">int</span> minimumReadableBytes)</span> </span>&#123;</span><br><span class="line">    checkReadableBytes0(checkPositiveOrZero(minimumReadableBytes, <span class="string">"minimumReadableBytes"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReadableBytes0</span><span class="params">(<span class="keyword">int</span> minimumReadableBytes)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();<span class="comment">// 检查是否可以访问</span></span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; readerIndex &gt; writerIndex - minimumReadableBytes) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s"</span>,</span><br><span class="line">                readerIndex, minimumReadableBytes, writerIndex, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Should be called by every method that tries to access the buffers content to check</span></span><br><span class="line"><span class="comment"> * if the buffer was released before.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkAccessible &amp;&amp; !isAccessible()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used internally by &#123;<span class="doctag">@link</span> AbstractByteBuf#ensureAccessible()&#125; to try to guard</span></span><br><span class="line"><span class="comment"> * against using the buffer after it was released (best-effort).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> refCnt() != <span class="number">0</span>; <span class="comment">// 引用计数不等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src数组中从下标 srcIndex 到 srcIndex + srcIndex - 1 的数据写入ByteBuf中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保可以写入 length 个字节的数据</span></span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    ensureWritable0(checkPositiveOrZero(minWritableBytes, <span class="string">"minWritableBytes"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes;</span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        <span class="comment">// 如果写入之后的 writerIndex 小于容量 capacity</span></span><br><span class="line">        ensureAccessible();<span class="comment">// 检查是否可以访问</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        ensureAccessible(); <span class="comment">// 如果写入之后的 writerIndex 超出最大容量 maxCapacity</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明容量不够，需要扩容，新容量会是2的n次方</span></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes(); <span class="comment">// 当前可写的容量</span></span><br><span class="line">    <span class="comment">// 这里 fastWritable &gt;= minWritableBytes 不会成立</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity); <span class="comment">// 调整容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractByteBufAllocator的calculateNewCapacity()方法</span></span><br><span class="line"><span class="comment">// 总感觉这里扩容实现的不是特别好，可能是我在第0层吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    checkPositiveOrZero(minNewCapacity, <span class="string">"minNewCapacity"</span>);</span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minNewCapacity: %d (expected: not greater than maxCapacity(%d)"</span>,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h3><p>Netty 中内存分配有一个顶层的抽象就是 ByteBufAllocator，负责分配所有 ByteBuf 类型的内存。</p>
<p>ByteBufAllocator 有如下几个重要的方法：</p>
<ul>
<li>buffer()：分配一块内存，自动判断是分配堆外内存还是堆内存</li>
<li>ioBuffer()：尽可能分配一块堆外内存，如果系统不支持则分配堆内存</li>
<li>heapBuffer()：分配一块堆内存</li>
<li>directBuffer()：分配一块堆外内存</li>
<li>compositeBuffer()：组合分配，把多个ByteBuf组合到一起变成一个整体</li>
</ul>


<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p><code>AbstractByteBufAllocator</code> 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instance use heap buffers by default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>); <span class="comment">// 默认使用堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">    directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe();</span><br><span class="line">    emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象方法，由子类实现</span></span><br><span class="line"><span class="comment"> * Create a direct &#123;<span class="doctag">@link</span> ByteBuf&#125; with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newHeapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象方法，由子类实现</span></span><br><span class="line"><span class="comment"> * Create a heap &#123;<span class="doctag">@link</span> ByteBuf&#125; with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到这里知道了 directBuffer、heapBuffer 和 Pooled、Unpooled的分配规则，那么Unsafe和非Unsafe是如何判别的呢？其实是Netty自动判别的。如果操作系统底层支持 Unsafe 那就采用 Unsafe 读写，否则采用非 Unsafe 读写。</p>
<p>我们可以从UnpooledByteBufAllocator的源码中验证</p>
<h3 id="非池化内存分配"><a href="#非池化内存分配" class="headerlink" title="非池化内存分配"></a>非池化内存分配</h3><p><code>UnpooledByteBufAllocator</code> 实现了非池化内存分配策略</p>
<h4 id="堆内存的分配"><a href="#堆内存的分配" class="headerlink" title="堆内存的分配"></a>堆内存的分配</h4><p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.hasUnsafe() ?</span><br><span class="line">        <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">    <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlatformDependent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE_UNAVAILABILITY_CAUSE == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Throwable <span class="title">unsafeUnavailabilityCause0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAndroid()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: unavailable (Android)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"sun.misc.Unsafe: unavailable (Android)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isIkvmDotNet()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: unavailable (IKVM.NET)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"sun.misc.Unsafe: unavailable (IKVM.NET)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasUnsafe = PlatformDependent0.hasUnsafe();</span><br><span class="line">            logger.debug(<span class="string">"sun.misc.Unsafe: &#123;&#125;"</span>, hasUnsafe ? <span class="string">"available"</span> : <span class="string">"unavailable"</span>);</span><br><span class="line">            <span class="keyword">return</span> hasUnsafe ? <span class="keyword">null</span> : PlatformDependent0.getUnsafeUnavailabilityCause();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Could not determine if Unsafe is available"</span>, t);</span><br><span class="line">            <span class="comment">// Probably failed to initialize PlatformDependent0.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Could not determine if Unsafe is available"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>PlatformDependent.hasUnsafe()</code> 方法来判断操作系统是否支持 Unsafe</p>
<ul>
<li>如果支持Unsafe则创建 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code> </li>
<li>如果不支持Unsafe则创建 <code>InstrumentedUnpooledHeapByteBuf</code> </li>
</ul>
<h5 id="InstrumentedUnpooledUnsafeHeapByteBuf"><a href="#InstrumentedUnpooledUnsafeHeapByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeHeapByteBuf"></a>InstrumentedUnpooledUnsafeHeapByteBuf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">super</span>.allocateArray(initialCapacity);</span><br><span class="line">        <span class="comment">// 记录新建的堆空间大小</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementHeap(bytes.length);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledHeapByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledUnsafeHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="comment">// 其实就是通过 unsafe 创建byte[]</span></span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.allocateUninitializedArray(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line">    <span class="keyword">byte</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        <span class="comment">// 调用的是 InstrumentedUnpooledUnsafeHeapByteBuf 的 allocateArray 方法</span></span><br><span class="line">        setArray(allocateArray(initialCapacity));</span><br><span class="line">        setIndex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>&#123;</span><br><span class="line">        array = initialArray;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkBounds) &#123; <span class="comment">// 确保 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity</span></span><br><span class="line">            checkIndexBounds(readerIndex, writerIndex, capacity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用AbstractByteBuf的方法设置 readerIndex 和 writerIndex</span></span><br><span class="line">        setIndex0(readerIndex, writerIndex); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InstrumentedUnpooledHeapByteBuf"><a href="#InstrumentedUnpooledHeapByteBuf" class="headerlink" title="InstrumentedUnpooledHeapByteBuf"></a>InstrumentedUnpooledHeapByteBuf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledHeapByteBuf</span> </span>&#123;</span><br><span class="line">  	InstrumentedUnpooledHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">     	<span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code> 和 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code>最终调用的都是 <code>UnpooledHeapByteBuf</code> 的构造方法，但前者是通过 <code>unsafe</code> 的方式创建字节数组，而后者是通过 <code>new byte[Size]</code> 的方式创建数组。其实不仅是创建数组，读写操作也是这样，前者是通过  <code>unsafe</code> 操作数据，后者则是直接通过数组下标操作数组。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><strong>分配内存时，根据操作系统是否支持 Unsafe：</strong></p>
<ul>
<li><strong>如果支持 unsafe：则通过 unsafe 的方式创建字节数组（读写数组也是通过 unsafe的方式）</strong></li>
<li><strong>如果不支持 unsafe：则使用 <code>new byte[Size]</code> 关键字创建字节数组（读写数组通过索引操作）</strong></li>
</ul>
<p><strong>释放内存则依赖 JVM 自动释放</strong></p>
<h4 id="堆外内存的分配"><a href="#堆外内存的分配" class="headerlink" title="堆外内存的分配"></a>堆外内存的分配</h4><p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">                &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>PlatformDependent.hasUnsafe()</code> 方法来判断操作系统是否支持 Unsafe</p>
<ul>
<li>如果支持Unsafe，判断 noCleaner 是否<ul>
<li>noCleaner = true，则创建 <code>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</code> </li>
<li>noCleaner = false，则创建 <code>InstrumentedUnpooledUnsafeDirectByteBuf</code> </li>
</ul>
</li>
<li>如果不支持Unsafe则创建 <code>InstrumentedUnpooledDirectByteBuf</code> </li>
</ul>
<h5 id="InstrumentedUnpooledDirectByteBuf"><a href="#InstrumentedUnpooledDirectByteBuf" class="headerlink" title="InstrumentedUnpooledDirectByteBuf"></a>InstrumentedUnpooledDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终就是 new DirectByteBuffer(capacity);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 DirectByteBuffer本身的cleaner去释放内存</span></span><br><span class="line">        <span class="comment">// DirectByteBuffer的cleaner 本质上也是使用 unsafe.freeMemory(address);</span></span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer; <span class="comment">// accessed by UnpooledUnsafeNoCleanerDirectByteBuf.reallocateDirect()</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">        ObjectUtil.checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        checkPositiveOrZero(initialCapacity, <span class="string">"initialCapacity"</span>);</span><br><span class="line">        checkPositiveOrZero(maxCapacity, <span class="string">"maxCapacity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">         <span class="comment">// 调用的是 InstrumentedUnpooledDirectByteBuf 的 allocateArray 方法</span></span><br><span class="line">        setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setByteBuffer</span><span class="params">(ByteBuffer buffer, <span class="keyword">boolean</span> tryFree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryFree) &#123;</span><br><span class="line">            ByteBuffer oldBuffer = <span class="keyword">this</span>.buffer;</span><br><span class="line">            <span class="keyword">if</span> (oldBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (doNotFree) &#123;</span><br><span class="line">                    doNotFree = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeDirect(oldBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer; <span class="comment">// buffer赋值</span></span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        capacity = buffer.remaining();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InstrumentedUnpooledUnsafeDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeDirectByteBuf"></a>InstrumentedUnpooledUnsafeDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终就是 new DirectByteBuffer(capacity);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 DirectByteBuffer本身的cleaner去释放内存</span></span><br><span class="line">        <span class="comment">// DirectByteBuffer的cleaner 本质上也是使用 unsafe.freeMemory(address);</span></span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledUnsafeDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">        ObjectUtil.checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">        checkPositiveOrZero(initialCapacity, <span class="string">"initialCapacity"</span>);</span><br><span class="line">        checkPositiveOrZero(maxCapacity, <span class="string">"maxCapacity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">        <span class="comment">// 调用的是 InstrumentedUnpooledUnsafeDirectByteBuf 的 allocateDirect 方法</span></span><br><span class="line">        setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发现 <code>InstrumentedUnpooledDirectByteBuf</code> 和 <code>InstrumentedUnpooledUnsafeDirectByteBuf</code>都是通过<code>new DirectByteBuffer(capacity)</code> 的方式创建堆外内存，并且释放内存也是通过 <code>DirectByteBuffer</code> 的 cleaner 释放，那它们的区别是什么呢？<strong>其实就是读写数据的方式不同</strong>。</p>
<p><code>InstrumentedUnpooledDirectByteBuf</code> 的父类 <code>UnpooledDirectByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.get(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((unsafe.getByte(ix(checkIndex(i)))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UnpooledDirectByteBuf</code> 通过 <code>DirectByteBuffer</code> 本身的方法来操作数据，不过 <code>DirectByteBuffer</code> 本身也是使用 unsafe 来操作数据的。</p>
<p> <code>InstrumentedUnpooledUnsafeDirectByteBuf</code>的父类 <code>UnpooledUnsafeDirectByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkIndex(index);</span><br><span class="line">    <span class="keyword">return</span> _getByte(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终就是 UNSAFE.getByte(address);</span></span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.getByte(addr(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>UnpooledUnsafeDirectByteBuf</code> 是直接使用的 unsafe 来操作数据的。</p>
<h5 id="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"></a>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射初始化一个 cleaner=null 的 DirectByteBuffer </span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ByteBuffer <span class="title">reallocateDirect</span><span class="params">(ByteBuffer oldBuffer, <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = oldBuffer.capacity();</span><br><span class="line">        <span class="comment">// 最终就是 调用 UNSAFE.freeMemory(address);</span></span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.reallocateDirect(oldBuffer, initialCapacity);</span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity() - capacity);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// UnpooledUnsafeNoCleanerDirectByteBuf 继承了 UnpooledUnsafeDirectByteBuf</span></span><br><span class="line">    <span class="comment">// 没有重写读写操作，都是使用的 UnpooledUnsafeDirectByteBuf 中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p><strong>分配内存时</strong></p>
<ul>
<li><strong>如果操作系统不支持 unsafe 或 noCleaner = false，则通过 <code>new DirectByteBuffer(capacity)</code> 的方式创建带有 cleaner 的 <code>DirectByteBuffer</code> 。</strong></li>
<li><strong>不过操作系统支持 unsafe 并且 noCleaner = true，则通过反射创建 cleaner 为空的 <code>DirectByteBuffer</code> 。</strong></li>
</ul>
<p><strong>释放内存时</strong></p>
<ul>
<li><strong>如果创建的 <code>DirectByteBuffer</code> 带有 cleaner，使用 DirectByteBuffer本身的cleaner释放</strong></li>
<li><strong>如果创建的 <code>DirectByteBuffer</code> 没有 cleaner，则使用 unsafe 释放内存</strong></li>
</ul>
<h3 id="池化内存的分配-1"><a href="#池化内存的分配-1" class="headerlink" title="池化内存的分配"></a>池化内存的分配</h3><p><code>PooledByteBufAllocator</code> 实现了池化内存分配策略</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>池化内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx强制Http跳转到Https访问</title>
    <url>/2020/02/03/Nginx%E5%BC%BA%E5%88%B6Http%E8%B7%B3%E8%BD%AC%E5%88%B0Https%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>本文分为两种情况：</p>
<ol>
<li>从<code>http://cip.wanxinwangluo.com/</code>跳转<code>https://cip.wanxinwangluo.com/</code></li>
<li>从<code>http://cip.wanxinwangluo.com:18182/</code>跳转<code>https://cip.wanxinwangluo.com:18182/</code></li>
</ol>
<a id="more"></a>

<h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>通过监听80端口，然后重定向到Https（默认443端口）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name cip.wanxinwangluo.com;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name cip.wanxinwangluo.com;</span><br><span class="line">    ssl_protocols TLSv1.3 TLSv1.2;</span><br><span class="line">    ssl_ciphers EECDH:+CHACHA20:+aRSA:+AES256:!NULL:!ARIA:!CAMELLIA:!SHA:!MD5;</span><br><span class="line">    server_tokens off;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/page_access main;</span><br><span class="line">    error_log /var/log/nginx/page_error;</span><br><span class="line">    ssl_certificate /usr/cert/wanxin/wanxinwangluo.com.cer;</span><br><span class="line">    ssl_certificate_key /usr/cert/wanxin/wanxinwangluo.com.key;</span><br><span class="line">   </span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>当网站只允许<code>https</code>访问时，用<code>http</code>访问时<code>nginx</code>会报出497错误码。</p>
<p>通过error_page命令将497状态码的链接重定向到<code>https://cip.wanxinwangluo.com:18182/</code>这个域名上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream libreSpeed &#123;</span><br><span class="line">    server 10.86.52.77:80;</span><br><span class="line">    server 10.86.122.208:80;</span><br><span class="line">    keepalive 64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 18182 ssl http2;</span><br><span class="line">    server_name cip.wanxinwangluo.com;</span><br><span class="line">    ssl_protocols TLSv1.3 TLSv1.2;</span><br><span class="line">    ssl_ciphers EECDH:+CHACHA20:+aRSA:+AES256:!NULL:!ARIA:!CAMELLIA:!SHA:!MD5;</span><br><span class="line">    server_tokens off;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/libreSpeed_access main;</span><br><span class="line">    error_log /var/log/nginx/libreSpeed_error;</span><br><span class="line">    ssl_certificate /usr/cert/wanxin/wanxinwangluo.com.cer;</span><br><span class="line">    ssl_certificate_key /usr/cert/wanxin/wanxinwangluo.com.key;</span><br><span class="line"></span><br><span class="line">    error_page 497 https://$host:$server_port$uri$is_args$args;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">        add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">        add_header Cache-Control no-cache;</span><br><span class="line">        add_header X-XSS-Protection "1;mode=block";</span><br><span class="line">        add_header x-frame-options SAMEORIGIN;</span><br><span class="line">        proxy_hide_header X-Powered-By;</span><br><span class="line">        proxy_hide_header "cache-control";</span><br><span class="line">        proxy_hide_header Expires;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_set_header Host  $http_host;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy true;</span><br><span class="line">        proxy_set_header Connection "";</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://libreSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus+Grafana监控环境搭建</title>
    <url>/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Prometheus是一套开源的监控&amp;报警&amp;时间序列数据库的组合。</p>
<p>Grafana是一个跨平台的开源的度量分析和可视化工具。</p>
<a id="more"></a>

<h2 id="Prometheus安装"><a href="#Prometheus安装" class="headerlink" title="Prometheus安装"></a>Prometheus安装</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:v2.22.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus.yml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="配置prometheus-yml"><a href="#配置prometheus-yml" class="headerlink" title="配置prometheus.yml"></a>配置prometheus.yml</h3><p>新建文件prometheus.yml，添加如下配置：</p>
<p>配置文件详解：<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/configuration/configuration</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">api_version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">honor_timestamps:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">localhost:9090</span></span><br></pre></td></tr></table></figure>

<h3 id="启动并测试"><a href="#启动并测试" class="headerlink" title="启动并测试"></a>启动并测试</h3><p>直接启动，然后访问9090端口查看是否成功</p>
<h2 id="Grafana安装"><a href="#Grafana安装" class="headerlink" title="Grafana安装"></a>Grafana安装</h2><p><strong>建议通过下载安装包安装</strong></p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>因为docker安装的方式配置持久化很麻烦（不同版本的目录结构不一样）</p>
<p><a href="https://grafana.com/grafana/download?platform=linux" target="_blank" rel="noopener">https://grafana.com/grafana/download?platform=linux</a></p>
<h3 id="docker-compose-yml（不推荐）"><a href="#docker-compose-yml（不推荐）" class="headerlink" title="docker-compose.yml（不推荐）"></a>docker-compose.yml（不推荐）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:7.2.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grafana-storage:/var/lib/grafana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>直接启动，然后访问3000端口查看是否成功</p>
<h3 id="配置Data-Sources"><a href="#配置Data-Sources" class="headerlink" title="配置Data Sources"></a>配置Data Sources</h3><p>访问Grafana主页，点击左侧边栏进入<strong>Configuration-&gt;Data Resources-&gt;Add data source</strong>，选择Prometheus</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_1.png" class="" title="grafana_1">

<p>输入URL，如：<a href="http://10.32.95.220:9090，点击Save">http://10.32.95.220:9090，点击Save</a> and Test</p>
<h3 id="导入Dashboards"><a href="#导入Dashboards" class="headerlink" title="导入Dashboards"></a>导入Dashboards</h3><p>可在Grafana官网选择Dashboards：<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards</a></p>
<p>这里直接在Grafana的Data Resources中，选择Prometheus，然后选择Databoards，导入：Prometheus 2.0 Stats</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_2.png" class="" title="grafana_2">

<h2 id="监控MySQL"><a href="#监控MySQL" class="headerlink" title="监控MySQL"></a>监控MySQL</h2><p>先部署mysqld-exporter采集mysql数据</p>
<h3 id="docker-compose-yml-1"><a href="#docker-compose-yml-1" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysqld-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/mysqld-exporter</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysqld-exporter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DATA_SOURCE_NAME="root:ZGp1eW9pZW5zMTU0NjQzyuwn@(10.86.52.74:3306)/"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Prometheus"><a href="#配置Prometheus" class="headerlink" title="配置Prometheus"></a>配置Prometheus</h3><p>修改prometheus的prometheus.yml，添加如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'74-mysql'</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['10.32.95.220:9104']</span></span><br></pre></td></tr></table></figure>

<p>然后映射配置文件<code>./prometheus.yml:/etc/prometheus/prometheus.yml</code></p>
<p>重启prometheus，然后访问promethues，查看<strong>Status-&gt;Targets</strong>页面，如下图：</p>
<p>注意状态必须为UP</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/prometheus_mysql.png" class="" title="prometheus_mysql">

<h3 id="配置Dashboards"><a href="#配置Dashboards" class="headerlink" title="配置Dashboards"></a>配置Dashboards</h3><p>可在Grafana官网选择Dashboards：<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards</a> 搜索</p>
<p>这里选择：<a href="https://grafana.com/grafana/dashboards/7362，" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/7362，</a></p>
<p>访问Grafana主页，点击左侧边栏进入<strong>十 -&gt; Import</strong>，输入json，然后load即可，如图：</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_3.png" class="" title="grafana_3">

<h2 id="监控Redis集群"><a href="#监控Redis集群" class="headerlink" title="监控Redis集群"></a>监控Redis集群</h2><p>先部署redis_exporter采集Redis集群数据</p>
<h3 id="docker-compose-yml-2"><a href="#docker-compose-yml-2" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>注意：这里如果Redis是集群，需要给每个节点都部署一个redis_exporter</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">oliver006/redis_exporter</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis_exporter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_ADDR=redis://10.86.52.74:6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_PASSWORD=d3l1aGpzZGhrYQ</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Prometheus-1"><a href="#配置Prometheus-1" class="headerlink" title="配置Prometheus"></a>配置Prometheus</h3><p>修改prometheus的prometheus.yml，添加如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">redis_cluster</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['10.32.95.220:9121']</span></span><br></pre></td></tr></table></figure>

<p>然后映射配置文件<code>./prometheus.yml:/etc/prometheus/prometheus.yml</code></p>
<p>重启prometheus，然后访问promethues，查看<strong>Status-&gt;Targets</strong>页面，如下图：</p>
<p>注意状态必须为UP</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/prometheus_2.png" class="" title="prometheus_2">

<h3 id="配置Dashboards-1"><a href="#配置Dashboards-1" class="headerlink" title="配置Dashboards"></a>配置Dashboards</h3><p>可在Grafana官网选择Dashboards：<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards</a> 搜索</p>
<p>这里选择：<a href="https://grafana.com/grafana/dashboards/11835，" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/11835，</a></p>
<p>访问Grafana主页，点击左侧边栏进入<strong>十 -&gt; Import</strong>，输入json，然后load即可，如图：</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_4.png" class="" title="grafana_4">

<h2 id="监控Kafka集群"><a href="#监控Kafka集群" class="headerlink" title="监控Kafka集群"></a>监控Kafka集群</h2><p>先部署mysqld-exporter采集kafka集群数据</p>
<h3 id="docker-compose-yml-3"><a href="#docker-compose-yml-3" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">danielqsj/kafka-exporter</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-exporter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--kafka.server=10.86.52.74:9092</span> <span class="string">--kafka.server=10.86.52.77:9092</span> <span class="string">--kafka.server=10.82.193.157:9092</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Prometheus-2"><a href="#配置Prometheus-2" class="headerlink" title="配置Prometheus"></a>配置Prometheus</h3><p>修改prometheus的prometheus.yml，添加如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">kafka_cluster</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['10.32.95.220:9308']</span></span><br></pre></td></tr></table></figure>

<p>然后映射配置文件<code>./prometheus.yml:/etc/prometheus/prometheus.yml</code></p>
<p>重启prometheus，然后访问promethues，查看<strong>Status-&gt;Targets</strong>页面，如下图：</p>
<p>注意状态必须为UP</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/prometheus_3.png" class="" title="prometheus_3">

<h3 id="配置Dashboards-2"><a href="#配置Dashboards-2" class="headerlink" title="配置Dashboards"></a>配置Dashboards</h3><p>可在Grafana官网选择Dashboards：<a href="https://grafana.com/grafana/dashboards搜索" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards搜索</a></p>
<p>这里选择：<a href="https://grafana.com/grafana/dashboards/7589，" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/7589，</a></p>
<p>访问Grafana主页，点击左侧边栏进入<strong>十 -&gt; Import</strong>，输入json，然后load即可，如图：</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_5.png" class="" title="grafana_5">

<h2 id="监控ES集群"><a href="#监控ES集群" class="headerlink" title="监控ES集群"></a>监控ES集群</h2><p>先部署elasticsearch_exporter采集ES集群数据</p>
<h3 id="docker-compose-yml-4"><a href="#docker-compose-yml-4" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch_exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">justwatch/elasticsearch_exporter:1.1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch_exporter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'--es.uri=http://10.86.52.77:9200'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"10.32.95.220:9114:9114"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Prometheus-3"><a href="#配置Prometheus-3" class="headerlink" title="配置Prometheus"></a>配置Prometheus</h3><p>修改prometheus的prometheus.yml，添加如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">es_cluster</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['10.32.95.220:9114']</span></span><br></pre></td></tr></table></figure>

<p>然后映射配置文件<code>./prometheus.yml:/etc/prometheus/prometheus.yml</code></p>
<p>重启prometheus，然后访问promethues，查看<strong>Status-&gt;Targets</strong>页面，<code>es_cluster</code>状态必须为UP。</p>
<h3 id="配置Dashboards-3"><a href="#配置Dashboards-3" class="headerlink" title="配置Dashboards"></a>配置Dashboards</h3><p>配置文件：<a href="https://github.com/justwatchcom/elasticsearch_exporter/edit/master/examples/grafana/dashboard.json" target="_blank" rel="noopener">https://github.com/justwatchcom/elasticsearch_exporter/edit/master/examples/grafana/dashboard.json</a></p>
<p>访问Grafana主页，点击左侧边栏进入<strong>十 -&gt; Import</strong>，输入json，然后load即可，如图：</p>
<img src="/2020/10/19/Prometheus-Grafana%E7%9B%91%E6%8E%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/grafana_6.png" class="" title="grafana_6">



]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft协议</title>
    <url>/2020/09/07/Raft%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Paxos算法不容易实现，Raft算法是对Paxos算法的简化和改进。</p>
<p>Raft算法将一致性问题分解为两个的子问题，<strong>Leader选举（Leader election）和日志复制（Log Replication）</strong>。</p>
<p>Raft协议的节点有三种状态：<strong>Leader</strong>、<strong>Follower</strong>、<strong>Candidate</strong>。</p>
<p>Leader：所有对系统的修改都会先经过leader。每个修改操作都会写一条日志，然后将日志复制到所有Follower节点，多数Follower节点响应时才提交日志，然后通知Follower节点提交日志，这个过程叫做<strong>Log Replication</strong>。</p>
<p>Follower：所有节点都以follower的状态开始，如果没收到Leader的心跳则会变成Candidate状态。</p>
<p>Candidate：发起投票，如果得到多数节点的选票则成为Leader，这个过程叫做<strong>Leader election</strong>。等待超时会重新发起投票，竞选失败（收到了Leader的心跳）则会变成Follower状态。</p>
<p><a href="https://raft.github.io/" target="_blank" rel="noopener">Raft官网</a></p>
<p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">Raft论文</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft动画演示</a></p>
<a id="more"></a>

<h2 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h2><h3 id="何时选举"><a href="#何时选举" class="headerlink" title="何时选举"></a>何时选举</h3><p>集群开始时，所有服务器都是follower，当服务器在指定的时间之内没有收到leader或者candidate的消息时会发起选举。这个指定的时间被称为<strong>选举超时（election timeout）</strong>，并且是一个<strong>150~300ms</strong>之间的随机数（<strong>为了避免选举冲突</strong>）。这里，leader的消息是指心跳消息，以<strong>心跳超时（heartbeat timeout）</strong>指定的时间间隔发送，candidate的消息是指投票消息。要求（heartbeat timeout）&lt;&lt; min(election timeout)，避免Follower发起无谓的投票。</p>
<h3 id="投票过程"><a href="#投票过程" class="headerlink" title="投票过程"></a>投票过程</h3><ol>
<li><p>Follower在选举超时时间内没有收到来自Leader的请求后会将当前维护的Term值加1</p>
</li>
<li><p>将自身状态变成Candidate</p>
</li>
<li><p>投票给自己</p>
</li>
<li><p>向集群的其他节点发送投票请求（RequestVote）</p>
</li>
<li><p>可能会有如下几种可能：</p>
<ol>
<li><strong>收到多数节点的选票，节点状态从Candidate变为Leader，并立刻向其他服务器发送心跳消息，之后按照心跳间隔发送心跳消息</strong>。收到投票消息的节点，会立刻重置自己的选举超时时间，它在这个Term下没有投票过，才能为其投票，其他Candidate节点已经在这个Term下已经投票给自己，所以不能为其投票。</li>
<li><strong>收到了Leader节点的心跳消息并且这个Leader节点的Term不小于自己的Term，状态转为follower，否则丢弃消息</strong>。</li>
<li><strong>没有节点赢得选举，可能是由于网络超时或者服务器原因没有leader被选举，这种情况比较简单，超时之后重试</strong>。有一种情况被称为split votes，比如一个有三个服务器的集群中所有服务器同时发起选举，那么就不可能有leader被选举出来，此时如果超时之后重试很可能所有服务器又同时发起选举，这样永远不可能有leader被选举出来。raft处理这种情况是采用上文提到过的随机 <strong>election timeout</strong>，随机超时保证了split votes发生的几率很小。</li>
</ol>
</li>
</ol>
<h3 id="何时同意"><a href="#何时同意" class="headerlink" title="何时同意"></a>何时同意</h3><p>如果发起的投票请求包含的term大于等于当前term，并且日志信息不新于candidate的日志信息（保证选出最新log的server为leader），那么会同意。</p>
<p><strong>比较日志是否新于Candidate</strong>：比较两个log中最后的entry的index和term，更大term的更加新，如果term一样，那么index更大的更加新。</p>
<h3 id="Term更新"><a href="#Term更新" class="headerlink" title="Term更新"></a>Term更新</h3><p>所有请求和响应的接收方在接收到更大的term时都必须更新自己的term，这保证了投票最终能够选出一个leader。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>流程如下：</p>
<ol>
<li>客户端发起请求（SET 5）给Leader</li>
<li>Leader接收到请求后，写入到本地日志中，Leader上这条记录的状态是uncommitted</li>
<li>Leader通过心跳发送AppendEntries消息将日志复制给其他节点</li>
<li>其他节点收到AppendEntries消息后，会写入日志（状态是uncommitted），如果写入成功则给Leader发出响应</li>
<li>Leader接收到大部分节点写入成功的响应后，会将Leader上这条记录更新为Committed状态，并且值更新为5。</li>
<li>Leader通知其他节点提交日志</li>
<li>其他节点收到提交日志的消息后，将日志状态更新为Committed状态，并且值更新为5。</li>
<li>此时集群状态完全一致</li>
</ol>
<h3 id="AppendEntries消息"><a href="#AppendEntries消息" class="headerlink" title="AppendEntries消息"></a>AppendEntries消息</h3><p><strong>Leader发送AppendEntries消息时，需要携带日志信息Log1和前一个日志Log2的term和index。</strong></p>
<ol>
<li>如果在follower节点的日志中找到Log2，那么follower的日志中这条log之后的信息全部丢弃，然后写入Leader发来的Log1。</li>
<li>如果没有找到Log2，follower将拒绝此消息，那么leader端对应follower的nextIndex会减一然后再对此follower进行AppendEntries操作（既发送Log2和前一个日志Log3的term和index）。如果再次失败那么再进行自减并执行AppendEntries操作。循环直到成功。</li>
</ol>
<h3 id="Append-Log并行化"><a href="#Append-Log并行化" class="headerlink" title="Append Log并行化"></a>Append Log并行化</h3><p>日志复制中的步骤2、步骤3可以并行执行，为什么？</p>
<ol>
<li>如果Leader没有Crash，那么和顺序的处理结果一致。</li>
<li>如果Leader Crash了，那么如果大于n/2+1的follower收到了这个消息并Append成功，那么这个Raft Log就一定会被Commit，新选举出来的Leader会响应客户端；否则这个Raft Log就不会被Commit，客户端就会超时/错误/或重试后的结果（看实现方式）。</li>
</ol>
<h2 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h2><p><strong>在发生网络分区的时候，Raft一样能保持一致性</strong>。</p>
<p>假设发生了网络分区：节点A和B在一个网络分区，节点C、D和E在另一个网络分区，如下图所示，且节点B和节点C分别是两个网络分区中的Leader节点：</p>
<img src="/2020/09/07/Raft%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA_1.png" class="" title="网络分区_1">

<p>客户端给节点B发送请求（SET 3），由于网络分区的原因，这个值不能被另一个网络分区中的Leader即节点C拿到，它最多只能被两个节点（节点B和C）感知到，所以它的状态是uncomitted（红色）。</p>
<img src="/2020/09/07/Raft%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA_2.png" class="" title="网络分区_2">

<p>此时另一个客户端给节点C发送请求（SET 8），由于可以被同一个分区下总计三个节点（节点C、D和E）感知到，3个节点已经符合大多数节点的条件。所以，这个值的状态就是committed。</p>
<img src="/2020/09/07/Raft%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA_3.png" class="" title="网络分区_3">

<p>然后修复网络分区，节点B能感知到C节点这个Leader的存在，它就会从Leader状态退回到Follower状态，并且节点A和B会回滚之前没有提交的日志（SET 3产生的uncommitted日志）。同时，节点A和B会从新的Leader节点即C节点获取最新的日志（SET 8产生的日志），从而将它们的值更新为8。如此以来，整个集群的5个节点数据完全一致了。</p>
<img src="/2020/09/07/Raft%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA_4.png" class="" title="网络分区_4">

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>相比Paxos更容易理解和工程化实现</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>Raft有一个很强的假设是主（leader）和备（follower）都按顺序投票，存在并发瓶颈，可参考<a href="https://www.zhihu.com/question/52337912" target="_blank" rel="noopener">OceanBase的一致性协议为什么选择 paxos而不是raft?</a>，不过也可以参考TiDB使用<strong>multi raft</strong>，或者是PolarFS使用的ParallelRaft。<ol>
<li><a href="https://zhuanlan.zhihu.com/p/33047950" target="_blank" rel="noopener">Elasticell-Multi-Raft实现</a></li>
</ol>
</li>
<li>网络分区会导致脑裂，可能会导致stale read，可以通过ReadIndex Read和Lease Read的方法来解决。<ol>
<li><a href="https://pingcap.com/blog-cn/lease-read/" target="_blank" rel="noopener">TiDB如何确认 leader 在处理这次 read 的时候一定是 leader</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Raft</tag>
        <tag>一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>RedissonLock源码分析</title>
    <url>/2020/10/28/RedissonLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>RLock是Redisson中一种<strong>可重入的</strong>分布式锁，RLock是一个接口，同时继承了<code>java.util.concurrent.locks.Lock</code>接口。</p>
<p>RedissonLock是RLock接口的默认实现，是一种<strong>非公平的</strong>，<strong>可重入的</strong>分布式锁。并且内部实现了一个<strong>监控锁的看门狗</strong>，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期，防止业务执行较长导致锁被自动释放。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改<a href="https://github.com/redisson/redisson/wiki/2.-配置方法#lockwatchdogtimeout监控锁的看门狗超时单位毫秒" target="_blank" rel="noopener">Config.lockWatchdogTimeout</a>来另行指定。</p>
<a id="more"></a>

<p>Redisson版本：3.13.3</p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>RLock继承了<code>java.util.concurrent.locks.Lock</code>接口，使用方式和Lock一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock l = redissonClient.getLock(<span class="string">"name"</span>);</span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RedissonLock源码分析"><a href="#RedissonLock源码分析" class="headerlink" title="RedissonLock源码分析"></a>RedissonLock源码分析</h2><p>RedissonLock使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"good"</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 减库存</span></span><br><span class="line">        NUM--;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"减库存成功，NUM="</span> + NUM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redissonClient-getLock-“good”"><a href="#redissonClient-getLock-“good”" class="headerlink" title="redissonClient.getLock(“good”)"></a>redissonClient.getLock(“good”)</h3><p>getLock默认初始化了一个RedissonLock实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns Lock instance by name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Implements a &lt;b&gt;non-fair&lt;/b&gt; locking so doesn't guarantees an acquire order by threads.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * To increase reliability during failover, all operations wait for propagation to all Redis slaves.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name - name of object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Lock object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RLock <span class="title">getLock</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(connectionManager.getCommandExecutor(), name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RedissonLock构造方法"><a href="#RedissonLock构造方法" class="headerlink" title="RedissonLock构造方法"></a>RedissonLock构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">    <span class="keyword">this</span>.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/10/28/RedissonLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" class="" title="构造方法">

<p>id是一个<strong>UUID</strong>，用于<strong>保证自己持有的锁不会被其他线程解锁</strong>，因为用的同一个commandExecutor对象，所以这里<strong>不会重复生成UUID</strong>。</p>
<img src="/2020/10/28/RedissonLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" class="" title="UUID">

<p>internalLockLeaseTime是<strong>锁的超时时间</strong>，默认是30s。</p>
<img src="/2020/10/28/RedissonLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" class="" title="超时时间">

<h3 id="lock方法"><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h3><p><strong>加锁</strong></p>
<p>leaseTime表示锁的超时时间，对应Redis中key的过期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(leaseTime, unit, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    	<span class="comment">// 尝试加锁，加锁失败则返回锁的ttl</span></span><br><span class="line">        Long ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">        <span class="comment">// lock acquired </span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123; <span class="comment">// ttl为空表示加锁成功</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 订阅锁释放事件</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">            commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commandExecutor.syncSubscription(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，加锁失败则返回锁的ttl</span></span><br><span class="line">                ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123; <span class="comment">// ttl为空表示加锁成功</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 通过信号量来阻塞线程，每次阻塞时间为锁的剩余过期时间</span></span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        future.getNow().getLatch().acquire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        future.getNow().getLatch().acquireUninterruptibly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 取消订阅</span></span><br><span class="line">            unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>尝试加锁，如果加锁失败则返回锁还有多少毫秒过期，加锁成功则返回空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.get(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                                         commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                                         TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123; <span class="comment">// 加锁成功，则启动看门狗用于续锁</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                          <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                          <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                          <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                          <span class="string">"return nil; "</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                          <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                          <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                          <span class="string">"return nil; "</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                          Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lua脚本-加锁"><a href="#lua脚本-加锁" class="headerlink" title="lua脚本 加锁"></a>lua脚本 加锁</h4><p>这里使用了lua脚本来保证加锁操作的原子性</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">'hincrby'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    redis.call(<span class="string">'pexpire'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">'hincrby'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    redis.call(<span class="string">'pexpire'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">'pttl'</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<img src="/2020/10/28/RedissonLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png" class="" title="lua脚本">

<ol>
<li>如果锁不存在，则创建锁（Hash结构）。然后使用<code>hincrby</code>命令（如果key不存在，value则为0），相当于往这个Hash中添加：Key为”uuid:线程id“，value为”1“（key使用uuid+线程id是为了保证不被其他线程解锁，value则表示锁的重入次数）。然后设置锁Hash的过期时间，返回null。</li>
<li>如果锁已存在并且value存在于Hash中，说明是自己加的锁，则将锁的重入次数+1，然后设置锁的过期时间，返回null。</li>
<li>锁存在，但不是自己创建的，则返回锁还有多少毫秒过期。</li>
</ol>
<h4 id="Watch-Dog-续锁"><a href="#Watch-Dog-续锁" class="headerlink" title="Watch Dog 续锁"></a>Watch Dog 续锁</h4><p>设置定时任务每隔1/3的过期时间进行续锁，解锁时也会取消续锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    ExpirationEntry entry = <span class="keyword">new</span> ExpirationEntry();</span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="keyword">null</span>) &#123; <span class="comment">// 已经启动过，则无需启动</span></span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long threadId = ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断自己是不是还持有锁，如果持有锁则重新设置过期时间，返回1，没有持有锁则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                          <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                          <span class="string">"return 1; "</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="string">"return 0;"</span>,</span><br><span class="line">                          Collections.singletonList(getName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时任务-netty时间轮"><a href="#定时任务-netty时间轮" class="headerlink" title="定时任务-netty时间轮"></a>定时任务-netty时间轮</h4><p><a href="https://zhuanlan.zhihu.com/p/32906730" target="_blank" rel="noopener">netty的时间轮算法的解读</a></p>
<ul>
<li>时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型（调度任务全部都绑定到同一个的调度器）。</li>
<li>时间轮调度器的时间精度可能不是很高，取决于时间段“指针”单元的最小粒度大小。</li>
<li>串行执行，所有的任务是依次执行，容易出现调度超时和任务堆集的情况。</li>
<li>无法再宕机之后恢复任务重新调度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveConnectionManager</span> <span class="keyword">implements</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimer timer;</span><br><span class="line">    <span class="comment">// timer = new HashedWheelTimer(new DefaultThreadFactory("redisson-timer"), minTimeout, TimeUnit.MILLISECONDS, 1024, false);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="subscribe方法"><a href="#subscribe方法" class="headerlink" title="subscribe方法"></a>subscribe方法</h3><p>订阅锁释放事件，设置监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;RedissonLockEntry&gt; <span class="title">subscribe</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pubSub.subscribe(getEntryName(), getChannelName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// entryName:e23eb663-8186-4efa-8cb5-bc817533c903:good</span></span><br><span class="line"><span class="comment">// channelName:redisson_lock__channel:&#123;good&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;E&gt; <span class="title">subscribe</span><span class="params">(String entryName, String channelName)</span> </span>&#123;</span><br><span class="line">    AtomicReference&lt;Runnable&gt; listenerHolder = <span class="keyword">new</span> AtomicReference&lt;Runnable&gt;();</span><br><span class="line">    AsyncSemaphore semaphore = service.getSemaphore(<span class="keyword">new</span> ChannelName(channelName));</span><br><span class="line">    RPromise&lt;E&gt; newPromise = <span class="keyword">new</span> RedissonPromise&lt;E&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> semaphore.remove(listenerHolder.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable listener = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            E entry = entries.get(entryName);</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.acquire();</span><br><span class="line">                semaphore.release();</span><br><span class="line">                entry.getPromise().onComplete(<span class="keyword">new</span> TransferListener&lt;E&gt;(newPromise));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            E value = createEntry(newPromise);</span><br><span class="line">            value.acquire();</span><br><span class="line"></span><br><span class="line">            E oldValue = entries.putIfAbsent(entryName, value);</span><br><span class="line">            <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldValue.acquire();</span><br><span class="line">                semaphore.release();</span><br><span class="line">                oldValue.getPromise().onComplete(<span class="keyword">new</span> TransferListener&lt;E&gt;(newPromise));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RedisPubSubListener&lt;Object&gt; listener = createListener(channelName, value);</span><br><span class="line">            service.subscribe(LongCodec.INSTANCE, channelName, semaphore, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    semaphore.acquire(listener);</span><br><span class="line">    listenerHolder.set(listener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newPromise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span><br><span class="line">        <span class="comment">// 锁释放，唤醒监听器</span></span><br><span class="line">        Runnable runnableToExecute = value.getListeners().poll();</span><br><span class="line">        <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runnableToExecute.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放信号量，被阻塞线程会被唤醒</span></span><br><span class="line">        value.getLatch().release();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span><br><span class="line">            <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            runnableToExecute.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value.getLatch().release(value.getLatch().getQueueLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a>tryLock方法</h3><p>尝试加锁，设置最大等待时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryLock(waitTime, -<span class="number">1</span>, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123; <span class="comment">// 等待超时了，设置获取锁失败</span></span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 订阅锁释放事件</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">    <span class="comment">// 如果返回false，说明等待超时了，锁可能自动释放，但没发布锁释放事件</span></span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unsubscribe(subscribeFuture, threadId); <span class="comment">// 取消订阅</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待超时了，设置获取锁失败</span></span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新计算锁的剩余时间</span></span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123; <span class="comment">// 等待超时了，设置获取锁失败</span></span><br><span class="line">            acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//不超时的情况下，循环等待锁释放</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123; <span class="comment">// ttl为空表示加锁成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123; <span class="comment">// 等待超时了，设置获取锁失败</span></span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiting for message</span></span><br><span class="line">            currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                <span class="comment">// 通过信号量来阻塞线程，每次阻塞时间为锁的剩余过期时间</span></span><br><span class="line">                subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123; <span class="comment">// 等待超时了，设置获取锁失败</span></span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后，取消订阅</span></span><br><span class="line">        unsubscribe(subscribeFuture, threadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        return get(tryLockAsync(waitTime, leaseTime, unit));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unLock方法"><a href="#unLock方法" class="headerlink" title="unLock方法"></a>unLock方法</h3><p>解锁，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line"></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        cancelExpirationRenewal(threadId); <span class="comment">// 取消看门狗续锁任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123; <span class="comment">// 返回为空，则抛出IllegalMonitorStateException异常</span></span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                                                                                  + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">            result.tryFailure(cause); <span class="comment">// 设置解锁失败</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                          <span class="string">"return nil;"</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">                          <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                          <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                          <span class="string">"return 0; "</span> +</span><br><span class="line">                          <span class="string">"else "</span> +</span><br><span class="line">                          <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                          <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                          <span class="string">"return 1; "</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="string">"return nil;"</span>,</span><br><span class="line">                          Arrays.asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lua脚本-解锁"><a href="#lua脚本-解锁" class="headerlink" title="lua脚本 解锁"></a>lua脚本 解锁</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">'hincrby'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">'pexpire'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">'del'</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    redis.call(<span class="string">'publish'</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>; // 这行貌似有点多余</span><br></pre></td></tr></table></figure>

<ol>
<li>如果锁不存在，或者不是自己的锁，则返回空。</li>
<li>如果锁的重入次数大于1，则重新设置锁的过期时间，返回0。</li>
<li>如果锁的重入次数等于1（不可能小于1），则删除锁，并且发布锁释放事件，返回1。</li>
</ol>
<h3 id="引出思考"><a href="#引出思考" class="headerlink" title="引出思考"></a>引出思考</h3><ol>
<li>为啥不先使用JVM的锁尝试加锁，加锁成功后再操作Redis，减少网络IO次数。</li>
<li>重入次数感觉没必要存入Redis，直接用ReentrantLock代替或者本地变量代替即可。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redisson</tag>
        <tag>分布式锁</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10搭建开发环境</title>
    <url>/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a>Java开发环境</h2><p>安装包：<strong>jdk-8u231-windows-x64.exe</strong></p>
<a id="more"></a>

<h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>直接双击安装包即可，推荐安装默认目录：<code>C:\Program Files\Java</code></p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>右键点击 “此电脑”的“属性” ——》选择 “高级系统设置” 选项 ——》选择 “环境变量”</p>
<h4 id="新建JAVA-HOME系统变量"><a href="#新建JAVA-HOME系统变量" class="headerlink" title="新建JAVA_HOME系统变量"></a>新建JAVA_HOME系统变量</h4><p>变量名：<code>JAVA_HOME</code></p>
<p>变量值：<code>C:\Program Files\Java\jdk1.8.0_231</code></p>
<h4 id="编辑Path系统变量"><a href="#编辑Path系统变量" class="headerlink" title="编辑Path系统变量"></a>编辑Path系统变量</h4><p>分别添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<h4 id="新建CLASSPATH系统变量"><a href="#新建CLASSPATH系统变量" class="headerlink" title="新建CLASSPATH系统变量"></a>新建<strong>CLASSPATH</strong>系统变量</h4><p>变量名：<code>CLASSPATH</code></p>
<p>变量值：<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>需全部输入一遍，如输入<code>javac</code>出现<strong>javac不是内部或外部命令,也不是可运行的程序</strong>，检查Path和CLASSPATH系统变量是否正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br><span class="line">javac</span><br></pre></td></tr></table></figure>

<h2 id="Python开发环境"><a href="#Python开发环境" class="headerlink" title="Python开发环境"></a>Python开发环境</h2><p>安装包：<strong>python-3.7.4.exe</strong></p>
<h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><p>直接双击安装包，选择：</p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%AE%89%E8%A3%85python.png" class="" title="安装python">

<p>选择<code>install for all users</code></p>
<p>推荐默认安装路径：<code>C:\Program Files (x86)\Python37-32</code>，其他都用默认设置</p>
<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>因为已经在安装的时候添加环境变量，所以直接在命令行窗口（Ctrl + R，输入cmd）下，输入python，出现如下字样说明安装成功</p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%AA%8C%E8%AF%81python.png" class="" title="验证python">

<h3 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h3><p><strong>不推荐升级python自带的pip版本</strong></p>
<p>暂时使用第三方pip源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip -i http://pypi.douban.com/simple install selenium -- trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>永久修改</p>
<p>在user目录中创建一个pip目录,如<code>C:\Users\93197\pip</code>，新建文件<code>pip.ini</code>，写入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">global.index-url='http://pypi.douban.com/simple'</span><br><span class="line">global.timeout='6000'</span><br><span class="line">global.trusted-host='pypi.douban.com'</span><br></pre></td></tr></table></figure>

<p><strong>验证pip源</strong></p>
<p>安装requests库，<code>pip install requests</code>，安装完后可以卸载<code>pip uninstall requests</code></p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%AA%8C%E8%AF%81pip%E6%BA%90.png" class="" title="验证pip源">

<p>查看下载地址是否为设置的源地址</p>
<h2 id="NodeJS开发环境"><a href="#NodeJS开发环境" class="headerlink" title="NodeJS开发环境"></a>NodeJS开发环境</h2><p>安装包：<strong>node-v12.16.1-x64.msi</strong></p>
<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>直接双击安装包，推荐安装默认目录：<code>C:\Program Files\nodejs\</code>，一直下一步即可。</p>
<h3 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h3><p>一般系统会自动加入环境变量，分别输入<code>node -v</code>和<code>npm -v</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;node -v</span><br><span class="line">v12.16.1</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;npm -v</span><br><span class="line">6.13.4</span><br></pre></td></tr></table></figure>

<h3 id="设置npm源"><a href="#设置npm源" class="headerlink" title="设置npm源"></a>设置npm源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry "https://registry.npm.taobao.org"</span><br></pre></td></tr></table></figure>

<h3 id="编辑Path系统变量-1"><a href="#编辑Path系统变量-1" class="headerlink" title="编辑Path系统变量"></a>编辑Path系统变量</h3><p>添加<code>D:\Repository\nodejs\node_global</code></p>
<h3 id="修改npm全局模块目录和缓存目录"><a href="#修改npm全局模块目录和缓存目录" class="headerlink" title="修改npm全局模块目录和缓存目录"></a>修改npm全局模块目录和缓存目录</h3><p>全局模块目录：<code>D:\Repository\nodejs\node_global</code></p>
<p>缓存目录：<code>D:\Repository\nodejs\node_cache</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置全局模块目录</span></span><br><span class="line">npm config set prefix "D:\Repository\nodejs\node_global"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置缓存目录</span></span><br><span class="line">npm config set cache "D:\Repository\nodejs\node_cache"</span><br></pre></td></tr></table></figure>

<h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看基本配置 </span></span><br><span class="line">npm config list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有配置</span></span><br><span class="line">npm config list -l</span><br></pre></td></tr></table></figure>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>安装包：<strong>Git-2.26.2-64-bit.exe</strong></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>直接双击，推荐默认安装目录</p>
<h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "jaceding"</span><br><span class="line">git config --global user.email "931977674@qq.com"</span><br></pre></td></tr></table></figure>

<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p><strong>安装maven之前需安装jdk</strong></p>
<p>安装包：<strong>apache-maven-3.6.3.zip</strong></p>
<p>解压目录：<strong>D:\Common\apache-maven-3.6.3</strong></p>
<h3 id="环境变量配置-1"><a href="#环境变量配置-1" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><h4 id="新建MAVEN-HOME系统变量"><a href="#新建MAVEN-HOME系统变量" class="headerlink" title="新建MAVEN_HOME系统变量"></a>新建MAVEN_HOME系统变量</h4><p>变量名：<code>MAVEN_HOME</code></p>
<p>变量值：<code>D:\Common\apache-maven-3.6.3</code></p>
<h4 id="编辑Path系统变量-2"><a href="#编辑Path系统变量-2" class="headerlink" title="编辑Path系统变量"></a>编辑Path系统变量</h4><p>添加：<code>%MAVEN_HOME%\bin\</code></p>
<h4 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h4><p>输入<code>mvn -v</code>，出现如下字样说明成功</p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%AA%8C%E8%AF%81pip%E6%BA%90.png" class="" title="验证pip源">

<h4 id="修改源和仓库地址"><a href="#修改源和仓库地址" class="headerlink" title="修改源和仓库地址"></a>修改源和仓库地址</h4><p>修改<code>D:\Common\apache-maven-3.6.3\conf</code>目录下的<code>settings.xml</code></p>
<p><strong>修改源地址</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>修改本地仓库位置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\Repository\Maven<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hadoop3"><a href="#Hadoop3" class="headerlink" title="Hadoop3"></a>Hadoop3</h2><h3 id="下载和解压"><a href="#下载和解压" class="headerlink" title="下载和解压"></a>下载和解压</h3><p>官网下载二进制文件：<a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz" target="_blank" rel="noopener">hadoop-3.2.1.tar.gz</a></p>
<p>必须使用管理员解压：hadoop-3.2.1.tar.gz（可以先找到解压软件的位置，然后以管理员身份运行，然后解压）</p>
<p>这里解压至<code>D:\ITProgram\hadoop-3.2.1</code></p>
<h3 id="环境变量配置-2"><a href="#环境变量配置-2" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><h4 id="新建HADOOP-HOME系统变量"><a href="#新建HADOOP-HOME系统变量" class="headerlink" title="新建HADOOP_HOME系统变量"></a>新建HADOOP_HOME系统变量</h4><p>变量名：<code>HADOOP_HOME</code></p>
<p>变量值：<code>D:\ITProgram\hadoop-3.2.1</code></p>
<h4 id="编辑Path系统变量-3"><a href="#编辑Path系统变量-3" class="headerlink" title="编辑Path系统变量"></a>编辑Path系统变量</h4><p>分别添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">HADOOP_HOME%\bin</span></span><br><span class="line"><span class="meta">%</span><span class="bash">HADOOP_HOME%\sbin</span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>找到<code>D:\ITProgram\hadoop-3.2.1\etc\hadoop\hadoop-env.cmd</code>文件</p>
<p>将<code>set JAVA_HOME=%JAVA_HOME%</code>修改为<code>set JAVA_HOME=C:\PROGRA~1\Java\jdk1.8.0_231</code></p>
<p>上面需要将JAVA_HOME修改为实际的jdk安装路径，并且如果jdk安装路径中包含空格，需要使用<code>~1</code>代替</p>
<p>例如，<code>C:\Program Files\Java\jdk1.8.0_231</code>改为<code>C:\PROGRA~1\Java\jdk1.8.0_231</code></p>
<h3 id="验证-4"><a href="#验证-4" class="headerlink" title="验证"></a>验证</h3><p>命令行窗口输入：<code>hadoop version</code>，出现如下字样说明成功</p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/hadoop%E9%AA%8C%E8%AF%81.png" class="" title="hadoop验证">

<h3 id="添加winutils"><a href="#添加winutils" class="headerlink" title="添加winutils"></a>添加winutils</h3><p>下载地址：<a href="https://github.com/cdarlint/winutils" target="_blank" rel="noopener">https://github.com/cdarlint/winutils</a></p>
<p>将winutils对应版本bin目录下的文件复制到hadoop\bin目录下</p>
<p>把winutils对应版本的<code>hadoop.dll</code>和<code>winutils.exe</code>放到c:\windows\system32目录下</p>
<p>命令行窗口输入：<code>winutils</code>，出现如下字样说明成功</p>
<img src="/2020/06/29/Win10%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/winutils%E9%AA%8C%E8%AF%81.png" class="" title="winutils验证">

<p><strong>如果不行重启IDEA或者重启电脑试试</strong></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>Win10</tag>
        <tag>NodeJs</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-依赖注入</title>
    <url>/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>常用的三种注入方式：</p>
<ul>
<li>field注入</li>
<li>setter注入</li>
<li>构造器注入</li>
</ul>
<a id="more"></a>

<h2 id="field注入"><a href="#field注入" class="headerlink" title="field注入"></a>field注入</h2><p>直接在需要注入的字段上加上<code>@Autowired</code>或者<code>@Resource</code></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p><strong>@Autowired为Spring提供的注解</strong>，按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"filed1Service"</span>)</span><br><span class="line"><span class="keyword">private</span> Filed1Service filed1Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"filed1Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filed1Service</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>通过反射进行注入，完成自动装配</strong></p>
<p>后置处理器：<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>关键：<code>AutowiredFieldElement</code>的<code>inject</code>方法</p>
<p>参考资料：</p>
<ol>
<li><a href="https://juejin.im/post/6844903957135884295" target="_blank" rel="noopener">@Autowired注解的实现原理</a></li>
</ol>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p><strong>@Resource默认按照ByName自动注入</strong>，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Filed1Service filed1Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"filed1Service"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFiled1Service</span><span class="params">(Filed1Service filed1Service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filed1Service = filed1Service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Resource装配顺序"><a href="#Resource装配顺序" class="headerlink" title="@Resource装配顺序"></a><strong>@Resource装配顺序</strong></h4><ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li>
<li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>通过反射进行注入，完成自动装配</strong></p>
<p>后置处理器：<strong>CommonAnnotationBeanPostProcessor</strong></p>
<p>关键：<code>ResourceElement</code>的<code>getResourceToInject</code>方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong></p>
<ol>
<li>注入方式简单</li>
<li>整体代码简洁明了</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，无法复用该实现类。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NullPointException的存在。</li>
<li>使用field注入可能会导致循环依赖，不过Spring能解决。</li>
</ol>
<h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>直接在需要注入的字段的setter方法上加上<code>@Autowired</code>或者<code>@Resource</code></p>
<p> 在Spring3.x刚推出的时候，推荐使用注入的就是这种，不过现在基本看不到过这种注解方式，写起来麻烦，当初推荐Spring也有他的道理</p>
<blockquote>
<p>The Spring team generally advocates setter injection, because large numbers of constructor arguments can get unwieldy, especially when properties are optional. Setter methods also make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is a compelling use case.</p>
<p>Some purists favor constructor-based injection. Supplying all object dependencies means that the object is always returned to client (calling) code in a totally initialized state. The disadvantage is that the object becomes less amenable to reconfiguration and re-injection.</p>
</blockquote>
<p>简单的翻译一下就是：<strong>构造器注入参数太多了，显得很笨重，另外setter的方式能用让类在之后重新配置或者重新注入</strong>。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong></p>
<ol>
<li>相比构造器注入，当注入参数太多或存在非必须注入的参数时，不会显得太笨重</li>
<li>允许在类构造完成后重新注入</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>代码臃肿</li>
<li>使用Setter注入可能会导致循环依赖，不过Spring能解决。</li>
</ol>
<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><p>先来看看Spring在文档里怎么说：</p>
<blockquote>
<p>The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state.</p>
</blockquote>
<p>简单的翻译一下：构造器注入的方式能够保证注入的组件不可变，并且确保需要的依赖不为空。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong></p>
<ol>
<li>依赖不可变 components as immutable objects ，即注入对象为final</li>
<li>依赖不可为空required dependencies are not null，省去对注入参数的检查。当要实例化FooController的时候，由于只有带参数的构造函数，spring注入时需要传入所需的参数，所以有两种情况：1) 有该类型的参数传入 =&gt; ok; 2) 无该类型参数传入，报错</li>
<li>提升了代码的可复用性：非IOC容器环境可使用new实例化该类的对象。</li>
<li>避免循环依赖：如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>当注入参数较多时，代码臃肿。（对于这个问题，也要好好想一想是不是违反了类的单一性职责原则，从而导致有这么多的依赖要注入。）</li>
</ol>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><h3 id="field注入-1"><a href="#field注入-1" class="headerlink" title="field注入"></a>field注入</h3><p>使用<code>FiledController</code>、<code>Filed1Service</code>、<code>Filed2Service</code>模拟循环依赖，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiledController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"filed1Service"</span>)</span><br><span class="line">    <span class="keyword">private</span> Filed1Service filed1Service;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filed2Service filed2Service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/field1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFiled1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filed1Service.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/field2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFiled2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filed2Service.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"filed1Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filed1Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filed2Service filed2Service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + filed2Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filed2Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filed1Service filed1Service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + filed1Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动程序发现一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Filed_1.png" class="" title="Filed_1">

<p><strong>访问接口后一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Filed_2.png" class="Filed_2.png.png">

<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Filed_3.png" class="Filed_3.png.png">

<p><strong>说明Spring可以解决field属性注入导致的循环依赖</strong></p>
<p>但是如果在Filed1Service、Filed2Service上加上@Scope(“prototype”)后（让单例变成多例，两个类必须都加上），则会启动失败，提示存在循环依赖</p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Filed_4.png" class="Filed_4.png.png">

<h3 id="setter注入-1"><a href="#setter注入-1" class="headerlink" title="setter注入"></a>setter注入</h3><p>使用<code>SetterController</code>、<code>Setter1Service</code>、<code>Setter2Service</code>模拟循环依赖，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetterController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Setter1Service setter1Service;</span><br><span class="line">    <span class="keyword">private</span> Setter2Service setter2Service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetter1Service</span><span class="params">(Setter1Service setter1Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setter1Service = setter1Service;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetter2Service</span><span class="params">(Setter2Service setter2Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setter2Service = setter2Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/setter1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFiled1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setter1Service.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/setter2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFiled2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setter2Service.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Setter1Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Setter2Service setter2Service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetter2Service</span><span class="params">(Setter2Service setter2Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setter2Service = setter2Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + setter2Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Setter2Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Setter1Service setter1Service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetter1Service</span><span class="params">(Setter1Service setter1Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setter1Service = setter1Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + setter1Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动程序发现一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Setter_1.png" class="" title="Setter_1">

<p><strong>访问接口后一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Setter_2.png" class="Setter_2.png.png">

<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Setter_3.png" class="Setter_3.png.png">

<p><strong>说明Spring也可以解决Setter注入导致的循环依赖</strong></p>
<p>但是如果在Filed1Service、Filed2Service上加上@Scope(“prototype”)后（让单例变成多例，两个类必须都加上），则会启动失败，提示存在循环依赖：</p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Setter_4.png" class="Setter_4.png.png">

<h3 id="构造器注入-1"><a href="#构造器注入-1" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>使用<code>ConstructorController</code>、<code>Constructor1Service</code>、<code>Constructor2Service</code>模拟循环依赖，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor1Service constructor1Service;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor2Service constructor2Service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorController</span><span class="params">(Constructor1Service constructor1Service, Constructor2Service constructor2Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor1Service = constructor1Service;</span><br><span class="line">        <span class="keyword">this</span>.constructor2Service = constructor2Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/constructor1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConstructor1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructor1Service.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/constructor2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConstructor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructor2Service.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor1Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor2Service constructor2Service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constructor1Service</span><span class="params">(Constructor2Service constructor2Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor2Service = constructor2Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + constructor2Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor2Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor1Service constructor1Service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constructor2Service</span><span class="params">(Constructor1Service constructor1Service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor1Service = constructor1Service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">" call "</span> + constructor1Service.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动项目报错</strong>，如下：</p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Constructor_1.png" class="" title="Constructor_1">

<p>解决：在出现循环依赖中的类上<strong>使用@Lazy注解</strong>（加一个就行），如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Constructor1Service</span><span class="params">(@Lazy Constructor2Service constructor2Service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.constructor2Service = constructor2Service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再启动项目后一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Constructor_2.png" class="" title="Constructor_2">

<p><strong>访问接口后一切正常</strong></p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Constructor_3.png" class="Constructor_3.png.png">

<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Constructor_4.png" class="Constructor_4.png.png">

<p>在Constructor1Service、Constructor2Service上加上@Scope(“prototype”)后（让单例变成多例，两个类必须都加上），依然可以成功启动，访问接口正常。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Spring能够解决field注入和setter注入导致的循环依赖，无法解决构造器解决的循环依赖。</li>
<li>使用构造器发生循环依赖，可以使用@Lazy注解解决。</li>
</ol>
<h2 id="Spring如何解决循环依赖"><a href="#Spring如何解决循环依赖" class="headerlink" title="Spring如何解决循环依赖"></a>Spring如何解决循环依赖</h2><p>Spring是先将Bean对象实例化（依赖无参构造函数），然后再设置对象属性。</p>
<p>Spring的循环依赖的理论依据是基于<strong>Java的引用传递</strong>，当我们获取到对象的引用时，<strong>对象的field属性是可以延后设置的</strong>（但是构造器必须是在获取引用之前）。</p>
<p>以上面的<code>Filed1Service</code>、<code>Filed2Service</code>举例，大致步骤如下：</p>
<ol>
<li>创建Filed1Service: Filed1Service filed1Service=new Filed1Service ()</li>
<li>属性注入:发现需要Filed2Service</li>
<li>创建Filed2Service：Filed2Service filed2Service=new Filed2Service()</li>
<li>属性注入: 发现需要Filed1Service,此时Filed1Service 已经创建了.只是还没经过各种后置处理器处理,所以Filed1Service 是可以完成属性注入的，只是一个半成品</li>
<li>之后回到第2步，就可以给A赋值了，循环依赖到此解决</li>
</ol>
<p>参考资料：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/84267654" target="_blank" rel="noopener">Spring 如何解决循环依赖？</a></li>
<li><a href="https://www.jianshu.com/p/8bb67ca11831" target="_blank" rel="noopener">Spring 如何解决循环依赖的问题</a></li>
</ol>
<h2 id="lazy注解如何解决循环依赖"><a href="#lazy注解如何解决循环依赖" class="headerlink" title="@lazy注解如何解决循环依赖"></a>@lazy注解如何解决循环依赖</h2><p>以上面的<code>Constructor1Service</code>、<code>Constructor2Service</code>举例，大致步骤如下:</p>
<ol>
<li>创建<code>Constructor1Service</code>，通过带参构造器创建</li>
<li>发现构造器中需要<code>Constructor2Service</code>，查询字段<code>constructor2Service</code>的所有注解，如果有@lazy注解,那么就不直接创建<code>Constructor2Service</code>了，而是使用动态代理创建一个代理类<code>Constructor2ServiceProxy</code></li>
<li>此时<code>Constructor1Service</code>跟<code>Constructor2Service</code>就不是相互依赖了,变成了<code>Constructor1Service</code>依赖一个代理类<code>Constructor2ServiceProxy</code>，<code>Constructor2Service</code>依赖<code>Constructor1Service</code></li>
</ol>
<p>可以通过打印类的名字验证这一点：</p>
<img src="/2020/08/09/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Constructor_5.png" class="" title="Constructor_5.png">

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
        <tag>循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群搭建</title>
    <url>/2020/10/17/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Zookeeper版本：3.4.14</p>
<a id="more"></a>

<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>三台节点docker-compose.yml分别如下</p>
<p>192.168.3.100:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>192.168.3.101</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>192.168.3.102</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.102</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=192.168.3.100:2888:3888</span> <span class="string">server.2=192.168.3.101:2888:3888</span> <span class="string">server.3=192.168.3.102:2888:3888</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>然后分别启动即可</p>
<h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure>

<img src="/2020/10/17/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/leader.png" class="" title="leader">

<img src="/2020/10/17/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/follower1.png" class="" title="follower1">

<img src="/2020/10/17/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/follower2.png" class="" title="follower2">]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性协议</title>
    <url>/2020/09/18/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><p>一个分布式系统最多只能同时满足<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>和<strong>分区容错性（Partition tolerance）</strong>这三项中的两项。</p>
<a id="more"></a>

<img src="/2020/09/18/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/CAP.jpg" class="" title="CAP">

<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性是指多个数据副本之间能够保持一致的特性（强一致性）。</p>
<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，分为不同的一致性。</p>
<ol>
<li><strong>强一致性：</strong>要求更新过的数据能被后续的访问都能看到，则是强一致性。</li>
<li><strong>弱一致性：</strong>能容忍后续的部分或者全部访问不到，则是弱一致性。</li>
<li><strong>最终一致性</strong>：经过一段时间后要求能访问到更新后的数据，则是最终一致性。</li>
</ol>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>可用性是指系统提供的服务一直处于可用状态，每次请求都能获取到非错的响应。</p>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>分区容错性是指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</p>
<h3 id="论证"><a href="#论证" class="headerlink" title="论证"></a>论证</h3><p>假设存在有一个分布式系统：有两个节点N1、N2，N1 和 N2 分别连接数据库D1 和 D2。</p>
<p>如果客户端向节点 N1 请求更新数据，N1 更新完数据后需要向 N2 进行同步操作，如果此时正好发生网络分区，也就是说 N1 和 N2 网络不通。在满足分区容错性的前提下，是否能满足一致性和可用性呢？这里有两种选择：</p>
<ol>
<li>牺牲数据一致性，保证系统可用性，响应更新成功给客户端。</li>
<li>牺牲系统可用性，保证数据一致性，阻塞等待网络连通或返回错误信息给客户端。</li>
</ol>
<p><strong>在分布式系统中，通常分区容错性必须得保证，只能在一致性和可用性做出权衡。</strong></p>
<h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><h4 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h4><p>如果不要求分区容错性，则强一致性和可用性是可以保证的。</p>
<p>但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p>
<h4 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h4><p>如果不要求可用性，相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p>
<h4 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h4><p>如果要求高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p>
<h3 id="WARO-机制"><a href="#WARO-机制" class="headerlink" title="WARO 机制"></a>WARO 机制</h3><p>WARO（Write All Read one）是一种简单的副本控制协议，当 Client 请求向某副本写数据时（更新数据），只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</p>
<p><strong>假设有 N 个副本，N-1 个都宕机了，剩下的那个副本仍能提供读服务；但是只要有一个副本宕机了，写服务就不会成功。</strong></p>
<p>WARO 机制牺牲了更新服务的可用性，最大程度地增强了读服务的可用性。</p>
<h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a>Quorum 机制</h3><p>Quorum机制是 “抽屉原理” 的一个应用。</p>
<p>假设有 N 个副本。为了能够执行写请求，必须要确保写操作被 W（W 小于 N）个副本确认。所以你需要将写请求发送到这 W 个副本。如果要执行读请求，那么至少需要从 R 个副本得到所读取的信息。这里的 W 对应的数字称为 Write Quorum，R 对应的数字称为 Read Quorum。这是一个典型的 Quorum 配置。</p>
<p>这里的关键点在于，W、R、N之间的关联。Quorum 系统要求，任意你要发送写请求的 W 个服务器，必须与任意接收读请求的 R 个服务器有重叠。这意味着，<strong>W+R &gt; N</strong> ，这样任意 W 个服务器至少与任意 R个服务器有一个重合。</p>
<h3 id="N个9"><a href="#N个9" class="headerlink" title="N个9"></a>N个9</h3><p>系统的可靠性中有个衡量标准：N个9，表示一年中，系统可以正常使用的时间与总时间之比。</p>
<ul>
<li><strong>3个9</strong>：( 1 - 99.9% ) * 365 * 24 = 8.76小时，表示系统一年内最多不可用时间为 8.76 小时。</li>
<li><strong>4个9</strong>：( 1 - 99.99% ) * 365 * 24 = 0.876小时 = 52.6分钟，表示系统一年内最多不可用时间为 52.6 分钟。</li>
<li><strong>5个9</strong>：( 1 - 99.999% ) * 365 * 24 * 60 = 5.26分钟，表示系统一年内最多不可用时间为 5.26 分钟。</li>
</ul>
<h2 id="Base-理论"><a href="#Base-理论" class="headerlink" title="Base 理论"></a>Base 理论</h2><p>BASE 理论是<strong>基本可用（Basically Available），软状态（Soft State）和最终一致性（Eventually Consistent）</strong>三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中 AP 的一个扩展，其核心思想是：即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。例如：</p>
<ul>
<li>响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，但由于出现故障，查询结果的响应时间增加到 1 ~ 2 秒。</li>
<li>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>软状态是指允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达成一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达成一致，而不需要实时保证数据的强一致性。</p>
<p>最终一致性是一种特殊的弱一致性，经过一段时间后达成一致，这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<p>在实际工程实践中，最终一致性大致分为5种：</p>
<ol>
<li><p>因果一致性（Causal consistency）：</p>
<p>如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值，即不能发生丢失更新情况。而与节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p>
</li>
<li><p>读己之所写（Read your writes）</p>
<p>节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不是旧值。这也算一种因果一致性。</p>
</li>
<li><p>会话一致性（Session consistency）</p>
<p>将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
</li>
<li><p>单调读一致性（Monotonic read consistency）</p>
<p>如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p>
</li>
<li><p>单调写一致性（Monotonic write consistency）</p>
<p>一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p>
</li>
</ol>
<p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总体来说 BASE 理论面向的是大型高可用、可扩展的分布式系统。不同于传统 ACID 的强一致性模型，BASE 理论提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID 和 BASE 理论往往又会结合使用。</p>
<h2 id="FLP"><a href="#FLP" class="headerlink" title="FLP"></a>FLP</h2><p><strong>FLP 不可能定理</strong>是分布式系统领域中最重要的定理之一，它给出了一个非常重要的结论：</p>
<p><strong>在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法</strong>。</p>
<p>这个定理告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。</p>
<h2 id="2PC-和-3PC"><a href="#2PC-和-3PC" class="headerlink" title="2PC 和 3PC"></a>2PC 和 3PC</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在分布式系统中，每个节点虽然知道自己进行事务操作的结果，却无法获取其他节点的操作结果。因此，当一个事务操作需要跨域多个分布式节点的时候，为了保持事务处理的 ACID 特性，引入了一个称为 “协调者” 的组件来调度所有分布式节点的执行逻辑（比如：半数节点执行成功则提交），这些被调度的分布式节点被称为 “参与者”。</p>
<p>协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。基于这个思想，衍生出了二阶段提交协议（2 Phase Commitment Protocol，2PC）和三阶段提交协议（3 Phase Commitment Protocol，3PC）。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>为了使分布式系统的所有节点在进行事务过程中能够保持原子性和一致性而设计的算法。通常，2PC也被认为是一种一致性协议，用来保证分布式系统中的数据一致性。</p>
<p>大概思路：每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。</p>
<p>二阶段提交的两个阶段：</p>
<ul>
<li>第一阶段：<strong>提交事务请求（也叫投票阶段，各参与者投票表明是否要继续执行接下来的事务提交操作）</strong></li>
<li>第二阶段：<strong>执行事务提交（也叫提交阶段，根据参与者的反馈情况决定最终是否可以进行事务提交操作）</strong></li>
</ul>
<h4 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h4><p>投票阶段流程如下：</p>
<ol>
<li><p><strong>事务询问</strong></p>
<p>协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p><strong>执行事务</strong></p>
<p>各参与者节点执行事务操作，并将 undo 和 redo 信息记入事务日志中。</p>
</li>
<li><p><strong>各参与者向协调者反馈事务询问的响应</strong></p>
<p>如果参与者成功执行了事务，则反馈给协调者 Yes 响应，表示事务可以执行，如果参与者没有执行成功，则反馈 No 响应，表示事务不可以执行。</p>
</li>
</ol>
<h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><p>根据参与者的反馈情况决定最终是否可以进行事务提交操作，有两种可能：</p>
<h5 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h5><p>如果所有参与者的反馈都是Yes，那么就会执行事务提交。执行事务提交流程如下：</p>
<ol>
<li><p><strong>发送提交请求</strong></p>
<p>协调者向所有参与者发送 commit 请求。</p>
</li>
<li><p><strong>事务提交</strong></p>
<p>参与者接收到 commit 请求后，会正式执行事务提交操作，并在完成提交后释放整个事务执行期间占用的事务资源。</p>
</li>
<li><p><strong>反馈事务提交结果</strong></p>
<p>参与者完成提交事务之后，向协调者发送 Ack 消息。</p>
</li>
<li><p><strong>完成事务</strong></p>
<p>协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</p>
</li>
</ol>
<h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>如果任何一个参与者的反馈是No，或者在等待超时之后，协调者没有收到所有参与者的响应，那么就会中断事务。中断事务流程如下：</p>
<ol>
<li><p><strong>发送回滚请求</strong></p>
<p>协调者向所有参与者发送 Rollback 请求。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p>参与者接收到 Rollback 请求后，会利用其在一阶段中记录的 undo 信息来执行事务回滚操作，并在完成回滚后释放整个事务执行期间占用的事务资源。</p>
</li>
<li><p><strong>反馈事务回滚结果</strong></p>
<p>参与者完成事务回滚之后，向协调者发送 Ack 消息。</p>
</li>
<li><p><strong>完成中断事务</strong></p>
<p>协调者接收到所有参与者反馈的 Ack 消息后，完成中断事务。</p>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><strong>原理简单，实现方便。</strong></li>
</ol>
<p>缺点：</p>
<ol>
<li><p><strong>同步阻塞</strong></p>
<p>在二阶段提交的过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p>
</li>
<li><p><strong>单点问题</strong></p>
<p>一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，参与者将会一直处在锁定事务资源的状态中，而无法继续完成事务操作。所有参与者必须等待协调者重新上线后才能工作。</p>
</li>
<li><p><strong>数据不一致</strong></p>
<p>在提交阶段中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这会导致只有部分参与者接受到了commit 请求。这样整个分布式系统便出现了数据不一致性的现象。</p>
</li>
<li><p><strong>容错性不好</strong></p>
<p>如果在二阶段提交的提交阶段，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。</p>
</li>
</ol>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>二阶段提交存在诸多缺点，因此研究者在二阶段提交协议的基础上进行了改进，提出了三阶段提交协议。</p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ol>
<li>引入超时机制（2PC只有协调者有超时机制）</li>
<li>将 2PC 的投票阶段一分为二，这样 3PC 就有 CanCommit、PreCommit、DoCommit 阶段</li>
</ol>
<p>引入 CanCommit 阶段，主要是进一步降低阻塞范围，因为在执行事务后，就会占用事务资源。2PC 没有CanCommit 阶段，那么就一定会占用事务资源（占用事务资源意味着可能导致阻塞）。换句话说，如果在占用事务资源之前，就能先判断事务是否执行成功，那么这样可以避免一些不必要的阻塞，这个和 Java 中的双重锁定有着异曲同工之妙。</p>
<h4 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a>CanCommit</h4><p>CanCommit 流程如下：</p>
<ol>
<li><p><strong>事务询问</strong></p>
<p>协调者向所有参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待个参与者响应。</p>
</li>
<li><p><strong>各参与者向协调者反馈事务询问的响应</strong></p>
<p>参与者在接收到协调者的 CanCommit 请求后，如果认为自身能够顺利执行事务，则响应 Yes 并进入预备状态，否则响应 No。</p>
</li>
</ol>
<h4 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a>PreCommit</h4><p>根据参与者的反馈情况决定最终是否可以进行 PreCommit 操作，有两种可能：</p>
<h5 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h5><p>如果阶段一所有参与者的反馈都是 Yes，那么就会执行事务预提交。执行事务预提交流程如下：</p>
<ol>
<li><p><strong>发送预提交请求</strong></p>
<p>协调者向所有参与者发送 PreCommit 请求，并进入 Prepared 阶段。</p>
</li>
<li><p><strong>事务预提交</strong></p>
<p>各参与者接收到 PreCommit 请求后，执行事务操作，并将 undo 和 redo 信息记入事务日志中。</p>
</li>
<li><p><strong>各参与者向协调者反馈事务执行的响应</strong></p>
<p>如果参与者成功执行了事务操作，那么就会反馈给协调者 Ack 响应，同时等待最终的指令：提交（commit）或中止（abort）。</p>
</li>
</ol>
<h5 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h5><p>如果阶段一任何一个参与者的反馈是 No，或者在等待超时之后，协调者没有收到所有参与者的响应，就会执行中断事务。中断事务流程如下：</p>
<ol>
<li><p><strong>发送中断请求</strong></p>
<p>协调者向所有参与者发送 Abort 请求。</p>
</li>
<li><p><strong>中断事务</strong></p>
<p>参与者收到协调者的 Abort 请求，或者在等待超时之后，参与者没有收到所有协调者的响应，就会执行中断操作。 </p>
</li>
</ol>
<h4 id="DoCommit"><a href="#DoCommit" class="headerlink" title="DoCommit"></a>DoCommit</h4><h5 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h5><p>如果协调者处于正常状态，并且它接收到了所有参与者的 Ack 响应，那么就会执行提交。执行提交流程如下：</p>
<ol>
<li><p><strong>发送提交请求</strong></p>
<p>协调者会从 “预提交” 状态转换为 “提交” 状态，并向所有参与者发送 doCommit 请求。</p>
</li>
<li><p><strong>事务提交</strong></p>
<p>参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交后释放整个事务执行期间占用的事务资源。</p>
</li>
<li><p><strong>反馈事务提交结果</strong></p>
<p>参与者完成事务提交之后，会向协调者发送 Ack 消息。</p>
</li>
<li><p><strong>完成事务</strong></p>
<p>协调者在收到所有参与者的 Ack 后，完成事务。</p>
</li>
</ol>
<h5 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h5><p>如果协调者处于正常状态，有任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，参与者没有收到所有协调者的响应，就会中断事务。中断事务流程如下：</p>
<ol>
<li><p><strong>发送中断请求</strong></p>
<p>协调者向所有参与者发送 Abort 请求。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p>参与者在收到协调者的 Abort 请求后，会利用其阶段二中记录的 undo 信息来执行事务回滚操作，并在完成回滚后释放整个事务执行期间占用的事务资源。</p>
</li>
<li><p><strong>反馈事务回滚结果</strong></p>
<p>参与者在完成回滚后，向协调者发送 Ack 消息。</p>
</li>
<li><p><strong>中断事务</strong></p>
<p>协调者在收到所有参与者反馈的 Ack 消息后，中断事务。</p>
</li>
</ol>
<h4 id="协议补充"><a href="#协议补充" class="headerlink" title="协议补充"></a>协议补充</h4><p>一旦进入阶段三，参与者等待协调者最终的指令，协调者发生了故障或者发生了网络故障，参与者在等待超时后最终会提交事务。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><p><strong>降低了参与者的阻塞范围，并且能够在单点故障后继续达成一致。</strong></p>
<p>进入阶段三后，即使没有收到协调者最终的指令，参与者最终也会提交事务。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p><strong>可能会数据不一致</strong></p>
<p>参与者在接收到PreCommit消息后，如果出现网络分区， 某个参与者无法和协调者进行通信，这个参与者最终会进行事务的提交（其他参与者可能会回滚）。</p>
</li>
</ol>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos 算法是 Leslie Lamport 1990年提出的一种基于消息传递且具有高度容错特性的<strong>共识</strong>算法。</p>
<p>需要注意的是，<strong>一致性</strong>和<strong>共识</strong>并不是一个概念，一致性往往指分布式系统中多个副本对外呈现的数据的状态，共识则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。因此，一致性描述的是结果，共识则是一种手段。从某种程度上来说，共识算法可以看作是实现强一致性的一种方法。</p>
<h3 id="算法角色"><a href="#算法角色" class="headerlink" title="算法角色"></a>算法角色</h3><p>Paxos 有三种角色：<strong>提议者（Proposer），决策者（Acceptor），和学习者（Learner）</strong>：</p>
<ul>
<li><strong>Proposer</strong>：<ul>
<li>提案发起者</li>
<li>处理客户端的请求</li>
</ul>
</li>
<li><strong>Acceptor</strong>：<ul>
<li>参与决策，回应 Proposer 的提案</li>
<li>对 Accept 的提案，进程状态进行持久化</li>
</ul>
</li>
<li><strong>Learner</strong>：<ul>
<li>不参与决策，从 Proposer / Acceptor 学习最新达成一致的提案（Value）。</li>
</ul>
</li>
</ul>
<p><strong>在具体的实现中，一个进程可能不止充当一种角色。</strong></p>
<h3 id="安全性和活性"><a href="#安全性和活性" class="headerlink" title="安全性和活性"></a>安全性和活性</h3><p>一个分布式算法有两个最重要的属性：<strong>安全性（Safety）</strong>和<strong>活性（Liveness）</strong>。</p>
<ul>
<li><strong>安全性</strong><ol>
<li>只有被提出的提案才能被选定</li>
<li>只能一个值被选定</li>
<li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个</li>
</ol>
</li>
<li><strong>活性</strong><ol>
<li>最终有一个提案会被选定</li>
</ol>
</li>
</ul>
<h3 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h3><h4 id="Proposer-生成提案"><a href="#Proposer-生成提案" class="headerlink" title="Proposer 生成提案"></a>Proposer 生成提案</h4><ul>
<li>Proposer 选择一个新的提案编号 N，然后向某个 Acceptor 集合（该集合数量必须大于半数）的成员发送请求，要求该集合中的 Acceptor 做出如下回应：<ul>
<li>保证不再批准任何编号小于 N 的提案。</li>
<li>如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 批准过的编号小于 N 但为最大编号的那个提案。</li>
</ul>
</li>
<li>如果 Proposer 收到了半数以上的 Acceptor 的响应结果，那么它就可以产生编号为 N，Value 为 W 的提案，这里的 W 是 Prepare 请求中所有响应中编号最大的提案的值。或者如果半数以上的 Acceptor 没有批准过任何提案，即 Prepare 请求中不包含任何提案，那么此时 W 值就可以由 Proposer 任意选择。</li>
</ul>
<h4 id="Acceptor-批准提案"><a href="#Acceptor-批准提案" class="headerlink" title="Acceptor 批准提案"></a>Acceptor 批准提案</h4><p>Acceptor可能会收到来自Propose的两种请求：Prepare 请求和 Accept 请求，对这两种请求做出响应的条件如下：</p>
<ul>
<li>Prepare 请求：Acceptor 可以在任何时候响应一个 Prepare 请求（前提是这个 Prepare 中的提案编号大于他批准过的所有提案编号）。</li>
<li>Accept请求： Acceptor 只要尚未响应过任何编号大于M的 Prepare 请求，那么它就可以响应这个编号为 M 的Accept 请求。</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>Basic Paxos 算法伪代码如下：</p>


<p>Basic Paxos 将决议分为两个阶段：<strong>Prepare 阶段</strong>、<strong>Accept 阶段</strong>：</p>
<h5 id="Prepare-阶段"><a href="#Prepare-阶段" class="headerlink" title="Prepare 阶段"></a>Prepare 阶段</h5><ol>
<li>Proposer 生成一个<strong>全局唯一且递增</strong>的提案编号M，然后向所有 Acceptor 发送编号为M的 <strong>Prepare 请求</strong>。（这里只携带提案编号即可）</li>
<li>如果一个 Acceptor 收到提案编号为 M 的 Prepare 请求，且 M 大于已批准过的最大编号的提案，那么它就会将已批准过的最大编号的提案 [M1，V1] 作为响应反馈给 Proposer，同时承诺不会再批准任何编号小于M的提案。</li>
</ol>
<h5 id="Accept-阶段"><a href="#Accept-阶段" class="headerlink" title="Accept 阶段"></a>Accept 阶段</h5><ol>
<li>如果 Proposer 收到半数以上 Acceptor 对其发出的 Prepare 请求的响应，那么它会发送一个针对 [M，V] 提案的 <strong>Accept 请求</strong>给 Acceptor。（这个提案的值 V 就是收到的响应中编号最大的提案的值V1，如果响应中不包含任何提案，那么 V 就是任意值）</li>
<li>如果一个 Acceptor 收到针对 [M，V] 提案的Accept请求，只要该 Acceptor 尚未对编号大于 M 的 Prepare 请求做出响应，它就可以接收并持久化这个提案 [M，V]。</li>
</ol>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p><strong>对于不会批准的请求，直接忽略，减少RPC次数</strong>。</p>
<h4 id="提案的获取"><a href="#提案的获取" class="headerlink" title="提案的获取"></a>提案的获取</h4><ul>
<li>方案一：一旦一个 Acceptor 批准了一个提案，就将该提案发送给所有的 Leaner。<ul>
<li>优点：实现简单</li>
<li>缺点：通讯次数太多。这样的做法虽然可以让 Learner 尽快获取被选定的提案，但是却需要让每个Acceptor跟所有的Learner逐个进行通信，通信的次数至少为二者数量的乘积。</li>
</ul>
</li>
<li>方案二：让所有的 Acceptor 将它们对提案的批准情况，统一发送给一个特定的Learner（称为“主Learner”），在不考虑拜占庭将军问题的前提下，假定Learner之间可以通过消息通讯来感知提案的选定情况。所以，当主Learner被通知一个提案已经被选定时，它会负责通知其他Learner。<ul>
<li>优点：通讯次数减少（通常为Accepter和Learner数量的总和）</li>
<li>缺点：主Learner存在单点问题，并且延迟更高。</li>
</ul>
</li>
<li>方案三：因为方案二主 Learner 存在单点问题，所以让 Acceptor 发送给一个特定的 Learner 集合，该集合中的每个 Learner 都可以在一个提案被选定后通知其他 Learner。集合中 Learner 数量越多，就越可靠，但通讯也更复杂。<ul>
<li>优点：通讯次数相对方案一少，相对方案二也更可靠。</li>
<li>缺点：通讯次数相对方案二多了，实现复杂。</li>
</ul>
</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>存在一种极端情况，有两个 Proposer 依次提出一系列编号递增的提案，但是最终都无法被选定，陷入死循环。</p>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h3><p>Basic Paxos 只能对一个值形成决议，决议的形成至少需要两次网络来回，在高并发情况下可能需要更多的网络来回，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos搞不定了。因此Basic Paxos几乎只是用来做理论研究，并不直接应用在实际工程中。</p>
<p>Multi-Paxos 基于 Basic Paxos 做了两点改进：</p>
<ol>
<li>针对每一个要确定的值，运行一次 Basic Paxos 算法实例（Instance），形成决议。每一个 Paxos 实例使用唯一的Instance ID标识。</li>
<li>在所有 Proposers 中选举一个 Leader，由 Leader 唯一地提交 Proposal 给 Acceptors 进行表决。这样没有Proposer 竞争，解决了活锁问题。在系统中仅有一个 Leader 进行 Value 提交的情况下，Prepare 阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li>
</ol>
<p>Multi-Paxos 首先需要选举Leader，Leader的确定也是一次决议的形成，所以可执行一次Basic Paxos实例来选举出一个Leader。选出Leader之后只能由Leader提交Proposal，在Leader宕机之后服务临时不可用，需要重新选举Leader继续服务。在系统中仅有一个Leader进行Proposal提交的情况下，Prepare阶段可以跳过。</p>
<p>Multi-Paxos通过改变Prepare阶段的作用范围至后面Leader提交的所有实例，从而使得Leader的连续提交只需要执行一次Prepare阶段，后续只需要执行Accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个Instance ID标识，Instance ID由Leader本地递增生成即可。</p>
<p>Multi-Paxos允许有多个自认为是Leader的节点并发提交Proposal而不影响其安全性，这样的场景即退化为Basic Paxos。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>二阶段提交主要解决了分布式事务的原子性问题，但是存在一些难以解决的例如同步阻塞，单点问题导致无期限等待，数据不一致等问题。</li>
<li>三阶段提交在二阶段提交的基础上，引入CanCommit，并给参与者加上超时机制，减小阻塞的范围，避免无期限等待，但仍然没解决数据不一致问题。</li>
<li>Paxos 算法引入“过半”理念，并支持分布式节点角色之间的转换，避免了分布式节点的单点问题，既解决了无期限等待，也解决了“脑裂”问题。</li>
</ul>
<ol>
<li>如果 Proposer 收到半数以上 Acceptor 对其发出的 Accept 请求的响应，标志着本次 Accept 成功，决议形成。</li>
<li>将形成的决议发送给所有 Learner。 </li>
</ol>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ol>
<li><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos made simple</a></li>
</ol>
<h2 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h2><p><strong>Zookeeper Atomic Broadcast（Zookeeper 原子消息广播协议，简称ZAB）协议</strong>是为分布式协调服务 Zookeeper <strong>专门设计</strong>的一种支持<strong>崩溃恢复</strong>的原子广播协议。</p>
<p>基于 ZAB 协议，Zookeeper 实现了一种<strong>主备模式</strong>的系统架构来保持集群中各副本之间<strong>数据的一致性</strong>。这里的主备模型是指：Zookeeper 使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用 ZAB 的原子广播协议，将服务器的状态变更以事务 Proposal 的形式广播到所有的副本进程上去。</p>
<p>ZAB 的核心是定义那些会改变 Zookeeper 服务器数据状态的事务请求的处理方式，即：</p>
<blockquote>
<p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader 服务器，而余下的服务器被称为 Follower 服务器。Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 会等待所有 Follower 服务器的反馈，一旦超过半数 Follower 服务器进行了正确的反馈后，那么 Leader 会再次向所有的 Follower 服务器分发 commit 消息，要求其将前一个 Proposal 进行提交。</p>
</blockquote>
<h3 id="角色、节点状态"><a href="#角色、节点状态" class="headerlink" title="角色、节点状态"></a>角色、节点状态</h3><p>ZAB 协议中有三种角色：<strong>Leader 领导者、Follower 跟随者、Observer 观察者</strong>：</p>
<ul>
<li><strong>Leader</strong>：集群中<strong>唯一</strong>的写请求处理者，能够发起投票（投票也是为了进行写请求）</li>
<li><strong>Follower</strong>：能够接收客户端的读请求，如果是写请求则要转发给 Leader 。在选举过程中会<strong>参与投票</strong>，<strong>有选举权和被选举权</strong> 。</li>
<li><strong>Observer</strong>：就是没有<strong>选举权和被选举权</strong>的 Follower，可以忽略。</li>
</ul>
<p>ZAB 协议中节点有三种状态：<strong>Following、Looking、Leading</strong>：</p>
<ul>
<li><strong>Following</strong>：当前节点是跟随者，服从 Leader 节点的命令。</li>
<li><strong>Looking</strong>：当前节点是 Leader，负责协调事务。</li>
<li><strong>Leading</strong>：节点处于选举状态，正在寻找 Leader。</li>
</ul>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>ZAB 协议中有两种模式：</p>
<ul>
<li><p>崩溃恢复模式</p>
<p>当整个服务启动过程中，或者当 Leader 服务器出现网络中断、崩溃退出或重启等异常情况时，ZAB 协议就会<strong>进入崩溃恢复模式</strong>并通过选举产生新的 Leader 服务器。</p>
<p>当选举产生新的 Leader 服务器，同时集群中已有过半的节点和该 Leader 服务器完成数据同步后，ZAB 协议就会<strong>退出崩溃恢复模式</strong>。 </p>
</li>
<li><p>消息广播模式</p>
<p>当集群中已有过半的节点和 Leader 服务器完成数据同步后，就可以<strong>进入消息广播模式</strong>。</p>
</li>
</ul>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>当集群中已有过半的节点和 Leader 服务器完成数据同步后，就可以<strong>进入消息广播模式</strong>。</p>
<p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交的过程。不同之处在于：</p>
<ul>
<li><p>移除了中断逻辑</p>
<p>在 ZAB 协议的二阶段提交过程中，移除了中断逻辑，所有的 Follower 服务器要么正常反馈要么抛弃 Leader 服务器。崩溃或网络超时的 Follower 可以直接抛弃 Leader，并在数据同步阶段与集群达成一致，这种做法提高了集群的性能。</p>
</li>
<li><p>过半的 Follower 服务器反馈 Ack 之后就可以提交事务</p>
<p>二阶段提交的要求协调者必须等到所有的参与者全部反馈 Ack 确认消息后，再发送 Commit 消息。但 ZAB 协议中只需要过半的 Follower 服务器反馈 Ack 之后就可以提交事务。</p>
</li>
</ul>
<p>消息广播模式具体的步骤如下：</p>
<ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader 服务器将客户端的请求转化为事务 Proposal，同时为每个 Proposal 分配一个全局的ID，即 <strong>zxid</strong>。</li>
<li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</li>
<li>Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 Ack 响应消息。</li>
<li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息。</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。</li>
</ol>
<p>只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/ BASE 实现<strong>最终一致性</strong>的一个体现。</p>
<p>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 <strong>FIFO 消息队列</strong>进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。由于协议是 *<em>通过 TCP *</em>来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。</p>
<p>ZAB 协议中定义了一个全局单调递增的事务ID：<strong>zxid</strong> ，用于避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况。它是一个 64 位 long 型，其中高32位表示 epoch 年代，低32位表示事务 id。epoch 可以理解为当前集群所处的年代，每次 Leader 变更之后都会在 epoch 的基础上加1。而低32位可以简单理解为递增的事务 id，Leader 在产生新的 Proposal 事务时，都会对其加1。</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>当整个服务启动过程中，或者当 Leader 服务器出现网络中断、崩溃退出或重启等异常情况时，ZAB 协议就会<strong>进入崩溃恢复模式</strong>并通过选举产生新的 Leader 服务器。</p>
<p>ZAB 协议崩溃恢复需要满足以下两个条件：</p>
<ul>
<li>ZAB 协议需要确保已经被 Leader 提交的事务最终被所有服务器都提交。</li>
<li>ZAB 协议需要确保丢弃那些只在 Leader 服务器上被提出的事务。</li>
</ul>
<h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>为了实现上面这两个条件，需要选举算法能够<strong>保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 zxid 最大）的事务</strong>，这样就可以保证这个新选举出来的 Leader 一定具有所有已经提交的提案。同时也避免了 Leader 服务器检查 Proposal 的提交和丢弃工作。</p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>当选举产生新的 Leader 服务器之后，在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</p>
<p>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过啦并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</p>
<h3 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h3><ul>
<li><strong>选举（Leader Election）</strong>：选出 Leader。</li>
<li><strong>发现（Descovery）</strong>：Leader 会维护一个 Follower 的可用列表，将来客户端可以和其中的 Follower 节点进行通信。</li>
<li><strong>同步（Synchronization）</strong>：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。</li>
<li><strong>广播（Broadcast）</strong>：Leader 可以接受客户端新的 Proposal 请求，将新的 Proposal 请求广播给所有的 Follower。</li>
</ul>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="协议介绍-1"><a href="#协议介绍-1" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>由于论文非常详细，直接查看论文即可。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>相比Paxos更容易理解和工程化实现</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>Raft有一个很强的假设是主（leader）和备（follower）都按顺序投票，存在并发瓶颈，可参考 <a href="https://www.zhihu.com/question/52337912" target="_blank" rel="noopener">OceanBase 的一致性协议为什么选择 paxos 而不是 raft?</a>，不过也可以参考 TiDB 使用 multi raft，或者是 PolarFS 使用的ParallelRaft。<ol>
<li><a href="https://zhuanlan.zhihu.com/p/33047950" target="_blank" rel="noopener">Elasticell-Multi-Raft实现</a></li>
</ol>
</li>
<li>网络分区会导致脑裂，可能会导致stale read，可以通过ReadIndex Read和Lease Read的方法来解决。<ol>
<li><a href="https://pingcap.com/blog-cn/lease-read/" target="_blank" rel="noopener">TiDB如何确认 leader 在处理这次 read 的时候一定是 leader</a></li>
</ol>
</li>
</ol>
<h3 id="相关资料-1"><a href="#相关资料-1" class="headerlink" title="相关资料"></a>相关资料</h3><ol>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">中文论文翻译</a></li>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画演示</a></li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Raft</tag>
        <tag>一致性</tag>
        <tag>CAP</tag>
        <tag>WARO</tag>
        <tag>Quorum</tag>
        <tag>Base</tag>
        <tag>FLP</tag>
        <tag>2PC</tag>
        <tag>3PC</tag>
        <tag>Paxos</tag>
        <tag>ZAB</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算及原码、反码、补码</title>
    <url>/2017/09/12/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>程序中的所有数在计算机内存中都是以二进制的形式储存的，<strong>位运算就是直接对整数在内存中的二进制位进行操作</strong>。</p>
<p>位运算是更底层一些的操作，<strong>位运算通常相比其他运算有着更高的效率</strong>。</p>
<a id="more"></a>
<p><strong>运算符号</strong></p>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">C\C++</th>
<th align="center">Java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按位与（AND）</td>
<td align="center">a &amp; b</td>
<td align="center">a &amp; b</td>
</tr>
<tr>
<td align="center">按位或</td>
<td align="center">a | b</td>
<td align="center">a | b</td>
</tr>
<tr>
<td align="center">按位异或</td>
<td align="center">a ^ b</td>
<td align="center">a ^ b</td>
</tr>
<tr>
<td align="center">按位取反</td>
<td align="center">~ a</td>
<td align="center">~ a</td>
</tr>
<tr>
<td align="center">左移</td>
<td align="center">a &lt;&lt; b</td>
<td align="center">a &lt;&lt; b</td>
</tr>
<tr>
<td align="center">右移</td>
<td align="center">a &gt;&gt; b</td>
<td align="center">a &gt;&gt; b</td>
</tr>
<tr>
<td align="center">无符号右移</td>
<td align="center">无</td>
<td align="center">a &gt;&gt;&gt; b</td>
</tr>
</tbody></table>
<h4 id="按位与（AND）"><a href="#按位与（AND）" class="headerlink" title="按位与（AND）"></a>按位与（AND）</h4><p>按位与处理两个长度相同的二进制数，两个相应的二进位都为1，该位的结果值才为1，否则为0。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">0101</span>（十进制<span class="number">5</span>）</span><br><span class="line">AND <span class="number">0011</span>（十进制<span class="number">3</span>）</span><br><span class="line">  = <span class="number">0001</span>（十进制<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<h4 id="按位或（OR）"><a href="#按位或（OR）" class="headerlink" title="按位或（OR）"></a>按位或（OR）</h4><p>按位或处理两个长度相同的二进制数，两个相应的二进位中只要有一个为1，该位的结果值为1。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">   <span class="number">0101</span>（十进制<span class="number">5</span>）</span><br><span class="line">OR <span class="number">0011</span>（十进制<span class="number">3</span>）</span><br><span class="line"> = <span class="number">0111</span>（十进制<span class="number">7</span>）</span><br></pre></td></tr></table></figure>

<h4 id="按位异或（XOR）"><a href="#按位异或（XOR）" class="headerlink" title="按位异或（XOR）"></a>按位异或（XOR）</h4><p>按位异或运算，对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作。<br>操作的结果是如果某位不同则该位为1，否则该位为0。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">0101</span>（十进制<span class="number">5</span>）</span><br><span class="line">XOR <span class="number">0011</span>（十进制<span class="number">3</span>）</span><br><span class="line">  = <span class="number">0110</span>（十进制<span class="number">6</span>）</span><br></pre></td></tr></table></figure>

<h4 id="取反（NOT）"><a href="#取反（NOT）" class="headerlink" title="取反（NOT）"></a>取反（NOT）</h4><p>取反是一元运算符，对一个二进制数的每一位执行逻辑反操作。使数字1成为0，0成为1。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">NOT <span class="number">0111</span>（十进制<span class="number">7</span>）</span><br><span class="line">  = <span class="number">1000</span>（十进制<span class="number">8</span>）</span><br></pre></td></tr></table></figure>

<h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>左操作数按位左移右操作数指定的位数，移位后空缺的部分全部填0。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">0001</span>（十进制<span class="number">1</span>）</span><br><span class="line">&lt;&lt;     <span class="number">3</span>（左移<span class="number">3</span>位）</span><br><span class="line">  = <span class="number">1000</span>（十进制<span class="number">8</span>）</span><br></pre></td></tr></table></figure>

<h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><p>左操作数按位右移右操作数指定的位数，左边的用原有标志位补充，右边超出的部分舍弃。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">1010</span>（十进制<span class="number">10</span>）</span><br><span class="line">&gt;&gt;      <span class="number">2</span>（右移<span class="number">2</span>位）</span><br><span class="line">   = <span class="number">0010</span>（十进制<span class="number">2</span>）</span><br></pre></td></tr></table></figure>

<h5 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h5><p>相比 C、C++、JAVA中有一个特有的无符号右移操作符“&gt;&gt;&gt;”，此操作将忽略操作数的符号 同样的还有&gt;&gt;&gt;=。</p>
<p>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，左边部分总是以0填充，右边超出的部分舍弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> c = a &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">a -<span class="number">8</span>         <span class="number">11111111111111111111111111111000</span></span><br><span class="line">b -<span class="number">1</span>         <span class="number">11111111111111111111111111111111</span></span><br><span class="line">c <span class="number">536870911</span>     <span class="number">11111111111111111111111111111</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：</p>
<p><strong>计算机中所有数都是以补码形式存储的</strong>（正数的补码是本身）。</p>
<p>原码：10进制转换成2进制是原码</p>
<p>反码： 正数的反码是本身，负数的反码是负数的原码0变为1,1变为0 （负数求反码时候的符号位不参与变换）</p>
<p>补码： 正数的补码是本身，负数的补码就是负数的反码加一</p>
<p>总结： 正数的原码，反码 ，补码三值合一， 负数的原码，反码，补码不同。</p>
<p><strong>-8</strong><br>原码 1000 0000 0000 0000 0000 0000 0000 1000<br>​反码 1111 1111 1111 1111 1111 1111 1111 0111<br>补码 1111 1111 1111 1111 1111 1111 1111 1000</p>
<p><strong>带符号右移</strong>（左边的用原有标志位补充，右边超出的部分舍弃），即</p>
<p>1111 1111 1111 1111 1111 1111 1111 1000  变成：<br>1111 1111 1111 1111 1111 1111 1111 1111</p>
<p>补码 1111 1111 1111 1111 1111 1111 1111 1111<br>反码 1111 1111 1111 1111 1111 1111 1111 1110<br>原码 1000 0000 0000 0000 0000 0000 0000 0001 转化为十进制也就是 -1</p>
<p><strong>无符号右移</strong>（左边部分总是以0填充，右边超出的部分舍弃），即</p>
<p>1111 1111 1111 1111 1111 1111 1111 1000  变成：<br>0001 1111 1111 1111 1111 1111 1111 1111</p>
<p>补码 0001 1111 1111 1111 1111 1111 1111 1111 （正数的原码，反码 ，补码三值合一）<br>反码 0001 1111 1111 1111 1111 1111 1111 1111 （正数的原码，反码 ，补码三值合一）<br>原码 0001 1111 1111 1111 1111 1111 1111 1111 转化为十进制也就是 53687091</p>
<h4 id="扩展为什么1字节表示的范围是-128-127"><a href="#扩展为什么1字节表示的范围是-128-127" class="headerlink" title="扩展为什么1字节表示的范围是[-128,127]"></a>扩展为什么1字节表示的范围是[-128,127]</h4><p>一个字节8位，即可表示2^8 =256，有符号数那就可以表示2^7 =128个正数、2^7 =128个负数了，但是1000 0000和0000 0000其实都是0,所以理论上它只能表示[-127, 127]。<br>如果计算机用原码或者反码，会多占用一个表达（+0、-0都会有各自的原码和反码）。但计算机中使用的是补码，+0、和-0的补码都是0000 0000,所以1000 0000可以用来多表达一个数，用来表示-128最合理。<br>还可以从另外一个角度来理解： -127 的补码是1000 0001.再减去1 就是1000 0000 。那-127-1=-128。<br>总结：补码不仅解决了符号的表示的问题，还统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>原码</tag>
        <tag>反码</tag>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2020/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p><strong>JVM中提供的synchronized和Lock锁都是JVM级别的，也就是说synchronized和Lock只在同一Java进程内有效，当我们需要实现多个JVM进程之前的线程互斥时，我们就需要使用分布式锁了。</strong></p>
<p>注意：相比单机锁，分布式锁并不能提高性能，甚至由于网络IO，会降低系统的性能。</p>
<p><strong>分布式锁特性</strong>：</p>
<ul>
<li>互斥性：保证只有一个线程持有同一把锁。</li>
<li>避免死锁：锁不会被永久持有，即使服务奔溃了，也要保证锁在一定期间内会被安全释放。</li>
<li>高可用性：除非整个分布式系统瘫痪，只要有服务存活，都允许获取和释放锁。</li>
<li>安全性：谁上的锁由谁释放，不能被其他线程解锁。</li>
</ul>
<a id="more"></a>

<h2 id="有了分布式锁，是否还需要JVM锁？"><a href="#有了分布式锁，是否还需要JVM锁？" class="headerlink" title="有了分布式锁，是否还需要JVM锁？"></a>有了分布式锁，是否还需要JVM锁？</h2><p><strong>需要，因为一般分布式锁存在网路IO，相比JVM锁性能更低</strong>。</p>
<p>在高并发环境，可以先尝试获取单机锁，如果单机锁获取失败则无需尝试获取分布式锁，避免多余的网络IO降低系统性能。如果获取单机锁成功，再尝试获取分布式锁。</p>
<h2 id="常见的分布式锁方案"><a href="#常见的分布式锁方案" class="headerlink" title="常见的分布式锁方案"></a>常见的分布式锁方案</h2><ol>
<li>MySQL（性能较低，本文不过多描述）</li>
<li>Redis</li>
<li>Zookeeper</li>
<li>Etcd</li>
</ol>
<p>根据获取分布式锁失败后的操作，可以将上述方案进行简单分类：</p>
<ul>
<li><strong>类CAS自旋式获取分布式锁</strong>：MySQL、Redis</li>
<li><strong>Event事件通知后再尝试获取分布式锁</strong>：Zookeeper、Etcd</li>
</ul>
<p>JVM的锁获取失败，为了避免线程上下文切换，一般会进行CAS自旋，自旋到一定次数依然获取失败后线程才进入休眠状态。但分布式锁由于有网络IO，所以类CAS自旋式获取分布式锁的方式并不能提高性能，还会频繁的网络请求，Event事件一般基于长连接，开销也不小，但相对来说还是基于Event事件的方式更好些。</p>
<p><strong>无论采用哪种方式，我们应该保证一个JVM，同时只有一个线程去尝试获取同一把分布式锁</strong>（获取分布式锁前需先获取JVM锁）。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET key value PX NX</span><br></pre></td></tr></table></figure>

<p><strong>SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX]</strong></p>
<ul>
<li><code>EX</code> <em>seconds</em> – Set the specified expire time, in seconds.</li>
<li><code>PX</code> <em>milliseconds</em> – Set the specified expire time, in milliseconds.</li>
<li><code>NX</code> – Only set the key if it does not already exist.</li>
<li><code>XX</code> – Only set the key if it already exist.</li>
<li><code>KEEPTTL</code> – Retain the time to live associated with the key.</li>
</ul>
<p>NX可以保证只有一个线程能够获取到同一把锁（也就是只有一个线程能够SET成功）</p>
<p>PN可以保证不会出现死锁（一段时间后，锁会自动过期）</p>
<h3 id="发布订阅-超时后获取"><a href="#发布订阅-超时后获取" class="headerlink" title="发布订阅+超时后获取"></a>发布订阅+超时后获取</h3><p>上面分析过，采用类CAS自旋获取分布式锁的方式会导致频繁的网络请求。所以这里可以进行一定的优化。</p>
<p>采用发布订阅的方式，释放锁时，发布锁释放消息，收到消息的JVM进程再尝试获取锁。或者一段时间（可以设置相对较长）没有收到消息，再尝试获取分布式锁（超时时间的作用是防止客户端没有发布消息）。</p>
<h3 id="守护线程续租"><a href="#守护线程续租" class="headerlink" title="守护线程续租"></a>守护线程续租</h3><p>当业务执行的时间大于锁超时时间，无法保证只有一个线程获取同一把锁。</p>
<p>所以在获取到锁后，在锁超时之前应该给锁进行续租（设置超时时间）。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁时，为了防止锁被错误的释放，应该在加上UUID进行标识。可以使用UUID+线程ID的方式来进行标识，这样就不用重复生成UUID了。所以解锁的操作就是<code>delete if exist and value = 锁标识</code>，但是Redis没有这个原子命令，所以我们需要借助Lua脚本，例如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'get'</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    	<span class="keyword">return</span> redis.call(<span class="string">'del'</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="高可用-Trade-off"><a href="#高可用-Trade-off" class="headerlink" title="高可用 Trade off"></a>高可用 Trade off</h3><p><strong>因为Redis集群的主从复制是异步的，当发生主备切换时，可能导致多个线程获取到同一把锁</strong>。</p>
<p>这个时候要对业务进行trade off，如果可以接受极少数情况下多个线程获取到同一把锁，那可以使用集群。否者就需要：</p>
<ol>
<li>Redis单点，使用安全级别更高的服务器部署Redis单点服务</li>
<li>多个Redis集群，使用RedLock算法</li>
</ol>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>创建临时节点，谁创建成功谁获取到锁。</p>
<h3 id="Watch监控"><a href="#Watch监控" class="headerlink" title="Watch监控"></a>Watch监控</h3><p>获取失败后，监控该节点的事件，收到事件后，再尝试获取锁。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>断开连接后临时节点会被自动删除。</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/gOYWLg3xYt4OhS46woN_Lg" target="_blank" rel="noopener">Redis锁从面试连环炮聊到神仙打架</a></li>
<li><a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Redis官网-分布式锁</a></li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>批量杀进程</title>
    <url>/2020/03/12/%E6%89%B9%E9%87%8F%E6%9D%80%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="按关键字批量杀进程"><a href="#按关键字批量杀进程" class="headerlink" title="按关键字批量杀进程"></a>按关键字批量杀进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep "downloader-jar" | grep -v grep | awk '&#123;print "kill -9 " $2&#125;'|sh</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="按占用的端口杀进程"><a href="#按占用的端口杀进程" class="headerlink" title="按占用的端口杀进程"></a>按占用的端口杀进程</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 $(netstat -nlp | grep :18080 | awk '&#123;print $7&#125;' | awk -F"/" '&#123; print $1 &#125;')</span><br></pre></td></tr></table></figure>

<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据端口号查找对应的进程号 </span></span><br><span class="line">netstat -ano | findstr "18080"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制关闭进程</span></span><br><span class="line">taskkill /f /t /PID 9432</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat 用来查看系统当前系统网络状态信息，包括端口，连接情况等，常用方式如下：</p>
<ul>
<li>-t : 指明显示TCP端口</li>
<li>-u : 指明显示UDP端口</li>
<li>-l : 仅显示监听套接字(LISTEN状态的套接字)</li>
<li>-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序</li>
<li>-n : 不进行DNS解析</li>
<li>-a 显示所有连接的端口</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nlp</span><br><span class="line">netstat -an | grep 18080</span><br></pre></td></tr></table></figure>

<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>lsof 的作用是列出当前系统打开文件，通过<code>-i</code>参数也能查看端口的连接情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:18080</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>按时间查询日志</title>
    <url>/2020/03/12/%E6%8C%89%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>查询日志时，经常需要指定条件查询。</p>
<a id="more"></a>

<ul>
<li><p>查询某个时间点到现在的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意：这个时间点必须有日志才行。日期格式为：yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">sed -n '/2020-03-12 16:10:12/,$p' app.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时间点可以没有日志，日期格式：yyyy-MM-dd<span class="string">'T'</span>HH:mm:ss.SSS</span></span><br><span class="line">docker logs --since '2020-03-12T16:10:12.000' app</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个时间段的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意：起始时间点必须有日志，截止时间点可以没有日志</span></span><br><span class="line">sed -n '/2020-03-12 16:10:12/,/2020-03-12 16:35:00/p' app.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 起始时间点和截止时间点都可以没有日志</span></span><br><span class="line">docker logs --since '2020-03-12T16:10:12.000' --until='2020-03-12T16:35:00.000' app</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库和缓存双写问题</title>
    <url>/2020/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>缓存的目的是为了减少数据库的压力，但只要用了缓存，就肯定会有不一致，2个数据源之间是没有事务的，没法保证绝对的强一致。</p>
<p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。</p>
<p>常见的四种方案：</p>
<ol>
<li>先更新缓存，在更新数据库</li>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ol>
<p>微软和Facebook采用的更新策略是第四种：</p>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">cache-aside</a></p>
<p><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></p>
<a id="more"></a>

<h2 id="先更新缓存，在更新数据库"><a href="#先更新缓存，在更新数据库" class="headerlink" title="先更新缓存，在更新数据库"></a>先更新缓存，在更新数据库</h2><p>问题：如果更新缓存后，数据库回滚了，那缓存如何处理？</p>
<p>解决思路：数据发生了回滚，即出现异常，这里做一个异常回调，删除对应的缓存。</p>
<p>总结：不推荐，代码的侵入性太大，首先你要记下来redis之前的值，回滚的时候再写回去，如果是insert，你得做一次delete，如果是update，你需要update回去，如果delete你得insert，并且如果回调中发生了异常怎么办，非常麻烦。</p>
<h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><p>问题一（线程安全角度），同时有请求A和请求B进行更新操作，可能会出现：</p>
<ol>
<li>线程A更新了数据库</li>
<li>线程B更新了数据库</li>
<li>线程B更新了缓存</li>
<li>线程A更新了缓存</li>
</ol>
<p>请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据。</p>
<p>解决思路：加锁，比如修改id为1的学生姓名，更新数据库之前，先对id=1的资源加锁，更新完数据库和缓存后，再释放锁。</p>
<p>总结：不推荐，加锁降低了系统的并发度，也使得系统更复杂。</p>
<p>问题二（业务场景角度），主要有两点：</p>
<ol>
<li>如果写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>
<li>如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>
</ol>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><p>这种方案同样会导致不一致，请求A进行更新操作，请求B进行查询操作，可能会出现：</p>
<ol>
<li>请求A进行更新操作，先删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p><strong>在删除缓存之后，更新数据库之前，如果有其他线程进行查询操作</strong>，就可能就会导致不一致的情形出现。如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>解决思路：<strong>延迟双删</strong>策略，伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是</p>
<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒，再次淘汰缓存。这么做，可以将1秒内所造成的缓存脏数据，再次删除</li>
</ol>
<p><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>针对上面的情形，应该自行评估项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<p>那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p><strong>第二次删除,如果删除失败怎么办？</strong></p>
<p>采用重试机制，详见方案4。</p>
<h2 id="先更新数据库，再删缓存"><a href="#先更新数据库，再删缓存" class="headerlink" title="先更新数据库，再删缓存"></a>先更新数据库，再删缓存</h2><p>这种方案同样会导致不一致，请求A进行查询操作，请求B进行更新操作，可能会出现：</p>
<ol>
<li><p>缓存不存在或刚好失效</p>
</li>
<li><p>请求A查询数据库，得一个旧值</p>
</li>
<li><p>请求B将新值写入数据库</p>
</li>
<li><p>请求B删除缓存</p>
</li>
<li><p>请求A将查到的旧值写入缓存 </p>
</li>
</ol>
<p><strong>在查询数据库之后，写入缓存之前，如果有其他线程进行更新操作</strong>，就可能就会导致不一致的情形出现。</p>
<p>仔细对比一下方案3和方案4发生数据不一致的场景：</p>
<p>方案3：<strong>在删除缓存之后，更新数据库之前，如果有其他线程进行查询操作</strong></p>
<p>方案4：<strong>在查询数据库之后，写入缓存之前，如果有其他线程进行更新操作</strong></p>
<p>但是方案4和方案3对比有一个先天优势，一般数据库都是写入速度比读写速度慢（当然也有写比读快的数据库，例如HBase），所以方案4发生不一致的可能性就更低。</p>
<p><strong>如何解决上述的并发问题？</strong></p>
<p>可以<strong>异步延迟双删+失败重试</strong>策略，保证读请求完成以后，再进行删除操作（即步骤4在步骤5之前发生）。</p>
<p>方案一，例如结合MQ，流程如下：</p>
<ol>
<li>更新数据库数据</li>
<li>缓存因为种种问题删除失败</li>
<li>将需要删除的key发送至消息队列</li>
<li>自己消费消息，获得需要删除的key</li>
<li>继续重试删除操作，直到成功</li>
</ol>
<p>该方案有一个缺点：<strong>对业务线代码造成大量的侵入</strong>。</p>
<p>方案二，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p>流程如下图所示：</p>
<ol>
<li>更新数据库数据</li>
<li>数据库会将操作信息写入binlog日志当中</li>
<li>订阅程序提取出所需要的数据以及key</li>
<li>另起一段非业务代码，获得该信息</li>
<li>尝试删除缓存操作，发现删除失败</li>
<li>将这些信息发送至消息队列重新从消息队列中获得该数据，重试操作</li>
<li>重新从消息队列中获得该数据，重试操作</li>
</ol>
<p>备注：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MySQL</tag>
        <tag>一致性</tag>
        <tag>缓存</tag>
        <tag>双写</tag>
      </tags>
  </entry>
  <entry>
    <title>时间轮算法</title>
    <url>/2021/03/16/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基于优先队列插入、删除延迟任务的时间复杂为O(logn)；</p>
<p>基于时间轮算法插入、删除延迟任务的时间复杂度是 O(1) 。</p>
<a id="more"></a>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>在 Java 中线程分为两类：</p>
<ul>
<li><strong>用户线程（User Thread）</strong> </li>
<li><strong>守护线程（Daemon Thread）</strong> </li>
</ul>
<p>通常默认创建的线程就是用户线程，通过 <code>Thread.setDaemon(true)</code> 可以将线程设置为守护线程。</p>
<p>当所有的用户线程都退出时，守护线程也会自动退出。例如：jvm 的垃圾回收线程就是一个守护线程，当所有用户线程都执行完毕后，垃圾回收线程就没用了，也就自己关闭了。</p>
<h3 id="Hook-线程"><a href="#Hook-线程" class="headerlink" title="Hook 线程"></a>Hook 线程</h3><p>当 jvm 进程退出的时候，或者受到了系统的中断信号，hook线程就会启动，一个线程可以注入多个钩子。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main thread start"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hook thread..."</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(<span class="string">"main thread end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">main thread start</span><br><span class="line">main thread end</span><br><span class="line">hook thread...</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：如果是通过 <code>kill -9 pid</code>这种方式强制杀死的进程，那进程是不会去执行 Hook 线程的。</p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>延迟1秒执行 task1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"task1 in "</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"start in "</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先队列，本质上是一个基于数组的小顶堆，顶堆是下一个需要执行的任务</span></span><br><span class="line"><span class="comment">     * The timer task queue.  This data structure is shared with the timer</span></span><br><span class="line"><span class="comment">     * thread.  The timer produces tasks, via its various schedule calls,</span></span><br><span class="line"><span class="comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span></span><br><span class="line"><span class="comment">     * and removing them from the queue when they're obsolete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行延迟任务的线程</span></span><br><span class="line"><span class="comment">     * The timer thread. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new timer whose associated thread has the specified name.</span></span><br><span class="line"><span class="comment">     * The associated thread does &lt;i&gt;not&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#setDaemon run as a daemon&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the associated thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> name&#125; is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.start(); <span class="comment">// 构造时默认启动执行线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timer 的核心就是一个优先队列和一个执行任务的线程。由于优先队列是基于堆实现的，根据堆的特性可知添加任务和删除任务的时间复杂度是：O(log n)。</p>
<h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>执行延迟任务的线程逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main timer loop.  (See class comment.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimerTask task;</span><br><span class="line">            <span class="keyword">boolean</span> taskFired;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    queue.wait(); <span class="comment">// 如果队列为空则一直等待，添加任务时则会通知</span></span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                task = queue.getMin();</span><br><span class="line">                <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    currentTime = System.currentTimeMillis();</span><br><span class="line">                    executionTime = task.nextExecutionTime;</span><br><span class="line">                    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                            queue.removeMin(); <span class="comment">// 不是周期性任务则直接移除</span></span><br><span class="line">                            task.state = TimerTask.EXECUTED;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                            <span class="comment">// 是周期性任务则修改当前任务时间为下次执行的时间</span></span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                                task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                : executionTime + task.period);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></span><br><span class="line">                    queue.wait(executionTime - currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行流程大致如下：</p>
<p><strong>TimerThread 不断地拿排着的第一个任务的执行时间和当前时间做对比。如果时间到了先看看这个任务是不是周期性执行的任务，如果是则修改当前任务时间为下次执行的时间，如果不是周期性任务则将任务从优先队列中移除，最后执行任务，如果时间还未到则调用 wait() 等待</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><strong>优先队列的插入和删除的时间复杂度是O(logn)</strong>，当数据量大的时候，频繁的入堆出堆性能有待考虑。</li>
<li><strong>单线程执行</strong>，那么如果任务执行的时间较长则会影响下一个任务的执行时间。</li>
<li><strong>没有捕获异常</strong>，一个任务出错的时候会导致之后的任务都无法执行。</li>
</ol>
<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>JDK1.5 引入了 <code>ScheduledThreadPoolExecutor</code>，它是一个具有更多功能的 Timer 的替代品，<strong>允许多个执行线程</strong>。如果只设置一个执行线程和 Timer 没啥差别，不过它对异常进行了处理。</p>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePool = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePool);</span><br><span class="line">        scheduledExecutorService.schedule(() -&gt; System.out.println(<span class="string">"task1"</span>), <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心属性-1"><a href="#核心属性-1" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ScheduledThreadPoolExecutor&#125; with the</span></span><br><span class="line"><span class="comment">     * given core pool size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，实现了 ScheduledExecutorService接口。其中：</p>
<p>DelayedWorkQueue 继承了阻塞队列，实现了优先队列，也是利用数组实现的小顶堆。</p>
<p>ScheduledFutureTask 继承自 FutureTask 重写了 run 方法，实现了周期性任务的需求。</p>
<h3 id="运行原理-1"><a href="#运行原理-1" class="headerlink" title="运行原理"></a>运行原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">            cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!periodic) <span class="comment">// 如果不是周期性任务，直接运行</span></span><br><span class="line">            ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">            setNextRunTime(); <span class="comment">// 重设下一次执行任务时间</span></span><br><span class="line">            reExecutePeriodic(outerTask); <span class="comment">// 重新入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ScheduledFutureTask.super.run(); 父类FutureTask中的run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">// 捕获异常</span></span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>ScheduledThreadPoolExecutor 是用来代替 Timer 的， 运行流程和 Timer 差不多，也是维护一个优先队列然后通过重写 task 的 run 方法来实现周期性任务，主要差别在于<strong>能多线程运行任务，不会单线程阻塞</strong>，由于优先队列都是使用小顶堆来实现，所以<strong>添加和删除的时间复杂度都是O(logn)</strong>。</p>
<p>运行时有捕获异常，所以<strong>一个任务出错也不会影响之后的任务</strong>。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>Java 中还有个延迟队列 <code>DelayQueue</code>，加入延迟队列的元素都必须实现 Delayed 接口。延迟队列内部是利用 PriorityQueue 实现的，所以还是利用优先队列。Delayed 接口继承了Comparable 因此优先队列是通过 delay 来排序的。</p>
<h3 id="核心属性-2"><a href="#核心属性-2" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123; <span class="comment">// 元素必须实现Delayed接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;(); <span class="comment">// 优先队列</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element with an expired delay is available on this queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 如果队列为空则等待元素插入</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) </span><br><span class="line">                    <span class="keyword">return</span> q.poll(); <span class="comment">// 小于等于0则说明时间到了，直接出队</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>) <span class="comment">// leader是减少不必要的等待，没抢到当leader线程都await()</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// 等待时间到达</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread) <span class="comment">// 执行完了重置leader</span></span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal(); <span class="comment">// 唤醒想当leader的线程</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>DelayQueue 通过优先队列来获取最早需要执行的任务，而优先队列是一个基于数组实现的小顶堆，其添加和删除任务的时间复杂度为 O(logn)。</p>
<h2 id="时间轮算法"><a href="#时间轮算法" class="headerlink" title="时间轮算法"></a>时间轮算法</h2><p>Timer 、ScheduledThreadPool和DelayQueue 添加和删除任务的时间复杂度为 O(logn)。而时间轮算法插入删除的时间复杂度是 O(1) ，因此在Netty、ZooKeeper等高性能中间件中都存在时间轮算法的踪影。</p>
<h3 id="Kafka-时间轮"><a href="#Kafka-时间轮" class="headerlink" title="Kafka 时间轮"></a>Kafka 时间轮</h3><p>Kafka中存在一些定时任务，如DelayedFetch、DelayedProduce、DelayedHeartbeat等，在Kafka中，定时任务的添加、轮转、执行、消亡等是通过时间轮来实现的。</p>
<p>JDK中Timer和DelayQueue的插入和删除操作的平均时间复杂度为O（nlogn）并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O（1）。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、ZooKeeper等组件中都存在时间轮的踪影。</p>
<img src="/2021/03/16/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE_1.jpg" class="" title="时间轮">

<p>Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务（TimerTask）。</p>
<p>时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickMs）。时间轮的时间格个数是固定的，可用wheelSize来表示，那么整个时间轮的总体时间跨度（interval）可以通过公式 tickMs×wheelSize计算得出。时间轮还有一个表盘指针（currentTime），用来表示时间轮当前所处的时间，currentTime是tickMs的整数倍。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList中的所有任务。</p>
<p>TimingWheel中的每个双向环形链表TimerTaskList都会有一个哨兵节点（sentinel），引入哨兵节点可以简化边界条件。哨兵节点也称为哑元节点（dummy node），它是一个附加的链表节点，该节点作为第一个节点，它的值域中并不存储任何东西，只是为了操作的方便而引入的。如果一个链表有哨兵节点，那么线性表的第一个元素应该是链表的第二个节点。</p>
<img src="/2021/03/16/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE_2.jpg" class="" title="时间轮">

<p>如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。</p>
<p>像现实中的钟表一样，“一格一格”地走，这样就需要有一个线程一直不停的执行，而大多数情况下，时间轮中的bucket大部分是空的，指针的“推进”就没有实质作用。为了减少 <strong>空推进</strong>，Kafka引入了DelayQueue。Kafka中的定时器借了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList（非哨兵节点）都加入DelayQueue。DelayQueue会根据TimerTaskList对应的超时时间expiration来排序，最短expiration的TimerTaskList会被排在DelayQueue的队头。<strong>Kafka 中的 TimingWheel 专门用来执行插入和删除 TimerTaskEntry的操作，而 DelayQueue 专门负责时间推进的任务。</strong></p>
<h3 id="Netty-时间轮"><a href="#Netty-时间轮" class="headerlink" title="Netty 时间轮"></a>Netty 时间轮</h3><img src="/2021/03/16/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/Netty%E6%97%B6%E9%97%B4%E8%BD%AE.jpg" class="" title="时间轮">

<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashedWheelTimer wheelTimer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line">        wheelTimer.newTimeout(timeout -&gt; log.info(<span class="string">"task1"</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        log.info(<span class="string">"start "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间轮状态"><a href="#时间轮状态" class="headerlink" title="时间轮状态"></a>时间轮状态</h4><p>时间轮有以下三种状态：</p>
<ul>
<li>WORKER_STATE_INIT：初始化状态，此时时间轮内的工作线程还没有开启</li>
<li>WORKER_STATE_STARTED：运行状态，时间轮内的工作线程已经开启</li>
<li>WORKER_STATE_SHUTDOWN：终止状态，时间轮停止工作</li>
</ul>
<img src="/2021/03/16/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%8A%B6%E6%80%81.jpg" class="" title="时间轮状态">

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是经过合并的源码</span></span><br><span class="line">    <span class="keyword">this</span>(Executors.defaultThreadFactory(), <span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="number">512</span>, <span class="keyword">true</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new timer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory        a &#123;<span class="doctag">@link</span> ThreadFactory&#125; that creates a</span></span><br><span class="line"><span class="comment"> *                             background &#123;<span class="doctag">@link</span> Thread&#125; which is dedicated to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> TimerTask&#125; execution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tickDuration         the duration between tick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit                 the time unit of the &#123;<span class="doctag">@code</span> tickDuration&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticksPerWheel        the size of the wheel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leakDetection        &#123;<span class="doctag">@code</span> true&#125; if leak detection should be enabled always,</span></span><br><span class="line"><span class="comment"> *                             if false it will only be enabled if the worker thread is   </span></span><br><span class="line"><span class="comment"> *                             not a daemon thread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  maxPendingTimeouts  The maximum number of pending timeouts after which call to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@code</span> newTimeout&#125; will result in</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> java.util.concurrent.RejectedExecutionException&#125;</span></span><br><span class="line"><span class="comment"> *                             being thrown. No maximum pending timeouts limit is assumed </span></span><br><span class="line"><span class="comment"> *                             if this value is 0 or negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, </span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> ticksPerWheel, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    ObjectUtil.checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</span><br><span class="line">    ObjectUtil.checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize ticksPerWheel to power of two and initialize the wheel.</span></span><br><span class="line">    <span class="comment">// 和HashMap类似，时间轮大小为大于等于 ticksPerWheel 的第一个 2 的幂，方便后续通过位运算代替模运算</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel);</span><br><span class="line">    mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert tickDuration to nanos.</span></span><br><span class="line">    <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent overflow.时间轮内的时钟拨动频率太大则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">            <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">            tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间轮内的时钟拨动频率最小为1毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">        <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建工作线程</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker);</span><br><span class="line">    <span class="comment">// 检测内存是否泄漏</span></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 初始化最大等待任务数，0或负数表示不限制最大等待任务数</span></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line">    <span class="comment">// 如果创建的时间轮实例大于 64，打印日志，并且这个日志只会打印一次</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">        WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        reportTooManyInstances();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中的 <code>tickDuration</code> 参数非常重要，应该根据业务的范围设置合理的参数。如果时间轮的拨动频率过大，则可能导致任务触发时间不准确。如果时间轮的拨动频率较小，时间轮转动频繁，任务少的情况下加载不到任务，属于一直空转的状态，会占用 CPU 线程资源。</p>
<p>为了防止时间轮占用过多的 CPU 资源，当创建的时间轮示例数大于 64 时会以日志的方式提示。</p>
<p>构造函数中只是初始化了轮线程，并没有开启，当第一次往时间轮内添加任务时，线程才会开启。</p>
<h4 id="往时间轮中添加任务"><a href="#往时间轮中添加任务" class="headerlink" title="往时间轮中添加任务"></a>往时间轮中添加任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    <span class="comment">// 等待的任务数+1 pendingTimeoutsCount是AtomicLong的实例，表示等待的任务数</span></span><br><span class="line">    <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">    <span class="comment">// 如果时间轮内等待的任务数大于最大值，则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">        pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                                             + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                                             + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启时间轮内的线程</span></span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">    <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">    <span class="comment">// 计算当前添加任务的执行时间</span></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guard against overflow.</span></span><br><span class="line">    <span class="comment">// 防止deadline溢出</span></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        deadline = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将任务加入队列</span></span><br><span class="line">    HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line">    timeouts.add(timeout);</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务会先保存在队列中，当时间轮的时钟拨动时才会判断是否将队列中的任务加载进时间轮。</p>
<h4 id="开启时间轮内的线程"><a href="#开启时间轮内的线程" class="headerlink" title="开启时间轮内的线程"></a>开启时间轮内的线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts the background thread explicitly.  The background thread will</span></span><br><span class="line"><span class="comment"> * start automatically on demand even if you did not call this method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this timer has been</span></span><br><span class="line"><span class="comment"> *                               &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">            <span class="comment">// 通过CAS保证只能由一个线程开启时间轮内的线程</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until the startTime is initialized by the worker.</span></span><br><span class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// CountDownLatch startTimeInitialized = new CountDownLatch(1);</span></span><br><span class="line">            <span class="comment">// startTimeInitialized 是一个CountDownLatch</span></span><br><span class="line">            <span class="comment">// 用于保证工作线程的 startTime 属性初始化</span></span><br><span class="line">            startTimeInitialized.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">            <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过 CAS 加锁的方式保证线程安全，避免多次启动。</p>
<p>执行线程启动后， <code>start()</code> 方法会被阻塞，等执行线程的 <code>startTime</code> 属性初始化完成后才被唤醒。为什么只有等 <code>startTime</code> 初始化后才能继续执行呢？因为上面的 <code>newTimeout</code> 方法在执行线程启动后，需要计算当前添加进来任务的执行时间（任务在何时执行），而这个执行时间是根据 <code>startTime</code> 计算的。</p>
<h4 id="时间轮调度"><a href="#时间轮调度" class="headerlink" title="时间轮调度"></a>时间轮调度</h4><p>workerThread.start() 执行后会调用内部 Worker 的 run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the startTime.</span></span><br><span class="line">    startTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized.</span></span><br><span class="line">        startTime = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">    <span class="comment">// 唤醒调用 HashedWheelTimer#start() 方法被阻塞的线程</span></span><br><span class="line">    startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 拨动时钟</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line">        <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过与运算计算任务的索引</span></span><br><span class="line">            <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line">            <span class="comment">// 处理过期任务</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">            HashedWheelBucket bucket =</span><br><span class="line">                    wheel[idx];</span><br><span class="line">            <span class="comment">// 将任务加载进时间轮</span></span><br><span class="line">            transferTimeoutsToBuckets();</span><br><span class="line">            <span class="comment">// 执行当前时间轮槽内的任务</span></span><br><span class="line">            bucket.expireTimeouts(deadline);</span><br><span class="line">            tick++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断时间轮状态是否是运行状态</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></span><br><span class="line">    <span class="comment">// 运行到这说明时间轮已关闭</span></span><br><span class="line">    <span class="comment">// 将还未执行的任务以列表的形式保存到 unprocessedTimeouts 集合中，在 stop 方法中返回出去</span></span><br><span class="line">    <span class="comment">// 还未执行的任务可能会在两个地方，一：时间轮数组内，二：队列中</span></span><br><span class="line">    <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">        bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">            unprocessedTimeouts.add(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理过期任务</span></span><br><span class="line">    processCancelledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间轮每拨动一次 <code>tick</code> 就会 +1，根据这个值与(时间轮数组长度 - 1)进行 <code>&amp;</code> 运算，可以定位时间轮数组内的槽。因为 <code>tick</code> 值一直在增加，所以时间轮数组看起来就像一个不断循环的圆。执行步骤大致如下：</p>
<ol>
<li>先初始化 <code>startTime</code> 值，因为后面任务执行的时间是根据 <code>startTime</code> 计算的</li>
<li>拨动时钟，如果时间未到，则 <code>sleep</code> 一会儿</li>
<li>处理过期的任务</li>
<li>将任务加载进时间轮</li>
<li>执行当前时钟对应时间轮内的任务</li>
<li>时间轮关闭，将所有未执行的任务封装到 <code>unprocessedTimeouts</code> 集合中，在 <code>stop</code> 方法中返回出去</li>
<li>处理过期的任务</li>
</ol>
<h4 id="拨动时钟"><a href="#拨动时钟" class="headerlink" title="拨动时钟"></a>拨动时钟</h4><p>如果时间轮设置的 <code>tickDuration</code> 为 100ms 拨动一次，当时钟拨动一次后，应该计算下一次时钟拨动的时间，如果还没到就 <code>sleep</code> 一会儿，等到拨动时间再醒来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * calculate goal nanoTime from startTime and current tick number,</span></span><br><span class="line"><span class="comment"> * then wait until that goal has been reached.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</span></span><br><span class="line"><span class="comment"> * current time otherwise (with Long.MIN_VALUE changed by +1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算时钟下次拨动的相对时间</span></span><br><span class="line">    <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间的相对时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line">        <span class="comment">// 计算距离下次拨动时钟的时间，+ 999999的目的是为了保证足够的 sleep 时间</span></span><br><span class="line">        <span class="comment">// 例如：当 deadline - currentTime = 2000002 时，不加 999999 就会只休眠2ms,</span></span><br><span class="line">        <span class="comment">// 而 2ms 其实还未达到 deadline 的时间点，加 999999 则会多休眠1ms</span></span><br><span class="line">        <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> currentTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">        <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">        <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">        <span class="comment">// 这里是为了兼容 Windows 平台，因为 Windows 平台的调度最小单位为 10ms，</span></span><br><span class="line">        <span class="comment">// 如果不是 10ms 的倍数，可能会引起 sleep 时间不准确</span></span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">            sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">                sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// sleep 到下次时钟拨动</span></span><br><span class="line">            Thread.sleep(sleepTimeMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) </span><br><span class="line">                                            == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果时间不到就 <code>sleep</code> 等待一会儿，为了使任务时钟准确，可以从上面的代码中看出 Netty 做了一些优化，比如 <code>sleepTimeMs</code> 的计算，Windows 平台的处理等。</p>
<h4 id="将任务从队列加载进时间轮"><a href="#将任务从队列加载进时间轮" class="headerlink" title="将任务从队列加载进时间轮"></a>将任务从队列加载进时间轮</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></span><br><span class="line">    <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">    <span class="comment">// 一次最多只处理队列中的 100000 个任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// all processed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">            <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">            <span class="comment">// 过滤已经取消了的任务</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前任务到执行还需要经过几次时钟拨动</span></span><br><span class="line">        <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line">        <span class="comment">// 计算当前任务到执行还需要经过几圈时钟拨动</span></span><br><span class="line">        timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line">        <span class="comment">// 有的任务可能在队列里很长时间，时间过期了也没有被调度，将这种情况的任务放在当前轮次内执行</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); </span><br><span class="line">        <span class="comment">// 计算任务在时间轮数组中的槽</span></span><br><span class="line">        <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">        HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">        <span class="comment">// 将任务放到时间轮的数组中，多个任务可能定位时间轮的同一个槽，这些任务通过以链表的形式链接</span></span><br><span class="line">        bucket.addTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line">    timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = tail = timeout;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.next = timeout;</span><br><span class="line">        timeout.prev = tail;</span><br><span class="line">        tail = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务刚加进来不会立即到时间轮中去，而是暂时保存到一个队列中，当时间轮时钟拨动时，会将任务从队列中加载进时间轮内。</p>
<p>时间轮每次最大处理 100000 个任务，因为任务的执行时间是用户自定义的，所以需要计算任务到执行需要经过多少次时钟拨动，并计算时间轮拨动的圈数。接着将任务加载进时间轮对应的槽内，可能有多个任务经过 hash 计算后定位到同一个槽，这些任务会以<strong>双向链表</strong>的结构保存，有点类似 HashMap 处理碰撞的情况。</p>
<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p>执行当前时间轮槽内的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all timeouts</span></span><br><span class="line">    <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashedWheelTimeout next = timeout.next;</span><br><span class="line">        <span class="comment">// 任务执行的圈数 &gt; 0，表示任务还需要经过 remainingRounds 圈时钟循环才能执行</span></span><br><span class="line">        <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从链表中移除当前任务，并返回链表中下一个任务</span></span><br><span class="line">            next = remove(timeout);</span><br><span class="line">            <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                timeout.expire();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                        <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">            <span class="comment">// 移除取消的任务</span></span><br><span class="line">            next = remove(timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 圈数-1</span></span><br><span class="line">            timeout.remainingRounds --;</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS 将任务状态设置为已过期，防止任务重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run(<span class="keyword">this</span>); <span class="comment">// 运行任务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// 捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() + '.', <span class="title">t</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间轮槽内的任务以链表形式存储，这些任务执行的时间可能会不一样，有的在当前时钟执行，有的在下一圈或者下两圈对应的时钟执行。当任务在当前时钟执行时，需要将这个任务从链表中删除，重新维护链表关系。</p>
<h4 id="终止时间轮"><a href="#终止时间轮" class="headerlink" title="终止时间轮"></a>终止时间轮</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止时间轮的线程不能是时间轮的执行线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                HashedWheelTimer<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                        ".stop() cannot be called from " +</span><br><span class="line">                        TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 将时间轮的状态修改为关闭状态</span></span><br><span class="line">    <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">        <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">        <span class="comment">// 到这里说明修改失败，之前时间轮的状态可能为 WORKER_STATE_INIT 或 WORKER_STATE_SHUTDOWN</span></span><br><span class="line">        <span class="comment">// 为 WORKER_STATE_INIT 表示时间轮没有任务，因此不用返回未处理的任务，但是需要将时间轮实例 -1</span></span><br><span class="line">        <span class="comment">// 为 WORKER_STATE_SHUTDOWN 表示是 CAS 操作失败，什么都不用做，因为 CAS 成功的线程会处理</span></span><br><span class="line">        <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS 操作失败，或者时间轮没有处理过任务，返回空的任务列表</span></span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">            <span class="comment">// 中断时间轮工作线程</span></span><br><span class="line">            workerThread.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 终止时间轮的线程等待时间轮工作线程 100ms，</span></span><br><span class="line">                <span class="comment">// 这个过程主要是为了时间轮工作线程处理未执行的任务</span></span><br><span class="line">                workerThread.join(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">assert</span> closed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回未处理的任务</span></span><br><span class="line">    <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间轮停止运行后会将未执行的任务返回出去，至于怎么处理这些任务，由业务方自己定义，这个流程和线程池的 <code>shutdownNow</code> 方法是类似的。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Timer、ScheduledThreadPool 和 DelayQueue 都是基于优先队列实现，其 O(logn) 的时间复杂度在任务数多的情况下频繁的入队出队对性能来说有损耗。</li>
<li>Timer 是单线程执行，会有阻塞的风险，并且对异常没有做处理。</li>
<li>ScheduledThreadPool 则可以使用多线程执行任务，并且线程池对异常做了处理。</li>
<li>DelayQueue 本质上就是一个具有优先级的阻塞队列。</li>
<li>时间轮更适合任务数很大的延时场景，它的任务插入和删除时间复杂度都为O(1)。</li>
<li>对于延迟超过时间轮所能表示的范围，Netty是通过增加一个字段-轮数，而Kafka是使用多层次时间轮。</li>
<li>Netty 的时间轮实现会有空推进的问题，而 Kafka则借助 DelayQueue 来避免空推进的问题。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DelayQueue</tag>
        <tag>Netty</tag>
        <tag>时间轮</tag>
        <tag>Timer</tag>
        <tag>ScheduledThreadPoolExecutor</tag>
        <tag>Kafka</tag>
        <tag>TimingWheel</tag>
        <tag>HashedWheelTimer</tag>
      </tags>
  </entry>
  <entry>
    <title>服务治理-限流篇</title>
    <url>/2020/06/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E9%99%90%E6%B5%81%E7%AF%87/</url>
    <content><![CDATA[<p>从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者Redis的集群限流）和单机限流。从算法实现角度来看，限流算法可分为漏桶算法、令牌桶算法和滑动时间窗口算法。下面主要分析这3种限流算法和分布式限流实现方案。</p>
<a id="more"></a>

<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>把请求比作是水，水来了都先放进桶里，并以恒定速度出水（处理请求），当水流量过大会导致桶溢出，即拒绝服务。请求的最大处理速度也就是水从漏桶流出的速度。</p>
<img src="/2020/06/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E9%99%90%E6%B5%81%E7%AF%87/%E6%BC%8F%E6%A1%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="漏桶示意图">

<p>基于漏桶（桶+恒定处理速率），可以起到对请求整流效果。漏桶算法可基于线程池来实现，线程池使用固定容量的阻塞队列+固定个数的处理线程来实现；最简单且最常见的漏桶思想的实现就是基于SynchronousQueue的线程池，其相当于一个空桶+固定处理线程 : )。</p>
<p>注意：原生的漏桶算法以恒定速度出水（处理请求），但是实际场景中请求的处理耗时可能不相等，为了实现恒定速率，一般都是限定同时处理请求的最大线程数。</p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>
<p>很多场景中，需要允许某种程度的突发请求，请求的最大速度也就是所有桶大小。这时候漏桶算法就不合适了，令牌桶算法更为适合。</p>
<p>为什么令牌桶可以允许某种程度的突发请求呢？举个例子，桶的大小为500，漏桶出水速度为100/s，令牌桶的速度为100/s。采用漏桶算法处理速度是100/s，采用令牌桶如果桶是满的，处理速度就是500/s，甚至600/s。</p>
<img src="/2020/06/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E9%99%90%E6%B5%81%E7%AF%87/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="令牌桶示意图">

<p>令牌桶算法的一个实现方案是：起一个Timer线程以固定频率往桶中放令牌，桶满时令牌溢出，业务线程在获取令牌时直接从桶中获取即可。该方案容易理解，但是需要一个Timer线程，资源占用较重。</p>
<p>令牌桶算法还有一种实现方案不需要用Timer线程，这个经典实现就是<code>Guava</code>中的<code>RateLimiter</code>，大致原理如下</p>
<ol>
<li><code>startTick</code>记录RateLimiter初始化时的时间戳（单位ns），后续<code>nowMicros</code>(当前时间点)都是取<code>(System.nanoTime()-startTick)/1000</code>；</li>
<li><code>nextFreeTicketMicros</code>记录下次可获取令牌的开始时间点，在RateLimiter初始化和获取到令牌之后会进行更新；</li>
<li>如果<code>nowMicros</code>大于等于<code>nextFreeTicketMicros</code>，表示可以获取令牌；如果<code>nowMicros</code>大于<code>nextFreeTicketMicros</code>，会计算二者差值并除以放一个令牌的周期，然后赋值给<code>storedPermits</code>字段（表示当前桶中令牌数，注意不能超过桶容量）；</li>
<li>然后<code>storedPermits</code>减去当前需要令牌数，如果此时要获取令牌数大于<code>storedPermits</code>，那么会将<code>nextFreeTicketMicros</code>再往后推进<code>(要获取令牌 - storedPermits) * 放一个令牌的周期</code> 的时间。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解CAS</title>
    <url>/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/</url>
    <content><![CDATA[<p><strong>CAS (Compare-And-Swap)  是一种无锁的非阻塞算法的实现</strong>。CAS 包含了 3 个操作数：1. 需要读写的内存值 V，2. 进行比较的值 A 3. 拟写入的新值 B。当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</p>
<p>CAS也是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</p>
<p>Java中 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</p>
<p>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的。</p>
<a id="more"></a>
<p>它们都是通过Unsafe这个类实现的原子操作，例如AtomicInteger部分代码（java8）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>下面演示了如何使用Unsafe实现CAS操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_UnSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test_UnSafe t = <span class="keyword">new</span> Test_UnSafe();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = Test_UnSafe.class.getDeclaredField("i");</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getAndAddInt实现"><a href="#getAndAddInt实现" class="headerlink" title="getAndAddInt实现"></a>getAndAddInt实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，如果cas操作失败，则会重新读取数据，并再次进行cas操作。</p>
<h2 id="jdk8u-unsafe-cpp"><a href="#jdk8u-unsafe-cpp" class="headerlink" title="jdk8u: unsafe.cpp"></a>jdk8u: unsafe.cpp</h2><p>下面是Unsafe类中compareAndSwapInt的实现，可以看到它是通过Atomic类的cmpxchg方法实现的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h3 id="linux-x86实现"><a href="#linux-x86实现" class="headerlink" title="linux_x86实现"></a>linux_x86实现</h3><p>下面是linux_x86实现的cmpxchg方法实现：</p>
<p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdk8u: os.hpp is_MP()</strong>：是否是多核处理器（ Multi Processor）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdk8u: atomic_linux_x86.inline.hpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>

<p>最终实现：</p>
<p>cmpxchg = cas修改变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure>

<h2 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h2><p>汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure>

<p>lock指令<strong>传统方式是锁总线实现</strong>，但硬件层级有相应的优化方案。</p>
<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/Intel%E6%89%8B%E5%86%8C%E5%85%B3%E4%BA%8Elock%E5%89%8D%E7%BC%80%E7%9A%84%E8%A7%A3%E9%87%8A.png" class="" title="Intel手册关于lock前缀的解释">

<p>文档中说的对于Lock指令区分两种实现方法</p>
<p>对于早期的CPU，总是采用的是锁总线的方式。具体方法是，一旦遇到了Lock指令，就由仲裁器选择一个核心独占总线。其余的CPU核心不能再通过总线与内存通讯。从而达到“原子性”的目的。</p>
<p>具体做法是，某一个核心触发总线的“Lock#”那根线，让总线仲裁器工作，把总线完全分给某个核心。</p>
<p>这种方式的确能解决问题，但是非常不高效。为了个原子性结果搞得其他CPU都不能干活了。因此从Intel P6 CPU开始就做了一个优化，改用Ringbus + MESI协议，也就是文档里说的cache conherence机制。这种技术被Intel称为“Cache Locking”。</p>
<p>根据文档原文：如果是P6后的CPU，并且数据已经被CPU缓存了，并且是要写回到主存的，则可以用cache locking处理问题。<strong>否则还是得锁总线</strong>。因此，lock到底用锁总线，还是用cache locking，完全是看当时的情况。当然能用后者的就肯定用后者。</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>假设”线程1”正在进行CAS操作，它读取到的指是A，假设再它通过CAS操作把这个值改成B之前，其他线程把A改成C，最终又改成A。然后”线程1“进行CAS依然可以成功，但是这个A已经被修改过了，在某些场景下可能会发生问题。</p>
<p><strong>解决办法：版本号机制（Java中的AtomicStampedReference），但一般基础类型简单值不需要版本号。</strong></p>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><ol>
<li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf" target="_blank" rel="noopener">8.1.4 Effects of a LOCK Operation on Internal Processor Caches</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CAS</tag>
        <tag>Unsafe</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解AQS</title>
    <url>/2020/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS/</url>
    <content><![CDATA[<p>所谓<code>AQS</code>，指的是<code>AbstractQueuedSynchronizer</code>，它<strong>提供了一种实现阻塞锁</strong>和<strong>一系列依赖FIFO等待队列的同步器的框架</strong>，<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>AQS 核心思想：<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中</strong>。</p>
<blockquote>
<p>CLH，是 Craig、Landin 和 Hagersten 三位作者的缩写，CLH是一种基于链表的高性能、公平的自旋锁。申请加锁的线程通过前驱节点的变量进行自旋。在前置节点解锁后，当前节点会结束自旋，并进行加锁。具体内容可以查看<a href="ftp://ftp.cs.washington.edu/tr/1993/02/UW-CSE-93-02-02.pdf">《Building FIFO and Priority-Queuing Spin Locks from Atomic Swap》</a>论文。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<img src="/2020/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="" title="AQS原理图">

<p><strong>AQS维护了一个volatile语义的共享资源变量state和一个FIFO线程等待队列</strong>。</p>
<h2 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h2><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h3 id="Exclusive（独占）"><a href="#Exclusive（独占）" class="headerlink" title="Exclusive（独占）"></a><strong>Exclusive</strong>（独占）</h3><p><strong>只有一个线程能执行</strong>，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以ReentrantLock 对这两种锁的定义做介绍：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<h3 id="Share（共享）"><a href="#Share（共享）" class="headerlink" title="Share（共享）"></a>Share（共享）</h3><p><strong>多个线程可同时执行</strong>，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock。ReentrantReadWriteLock可以看成是组合式，因为 ReentrantReadWriteLock允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>AQS的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。<strong>AQS 类中的其他方法都是 final</strong> ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>Node主要包含<code>thread</code> + <code>waitStatus</code> + <code>pre</code> + <code>next</code> 四个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表明节点在独占模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这四个常量都是给waitStatus用的</span></span><br><span class="line">    <span class="comment">// 表示 此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表示 后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表示 线程正在等待触发条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 表示 下一个acquireShared应无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">     *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">     *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">     *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">     *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">     *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">     *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">     *               on failure, block.</span></span><br><span class="line"><span class="comment">     *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">     *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">     *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">     *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">     *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">     *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">     *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">     *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">     *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">     *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">     *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">     *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">     *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">     *               since intervened.</span></span><br><span class="line"><span class="comment">     *   0:          None of the above</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">     * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">     * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">     * values, just for sign.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">     * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">     * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该节点对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接下一个等待条件触发的节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点是否处于Shared状态下</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步状态 AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<h2 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h2><p>以独占方式获取资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()至少执行一次tryAcquire()，<strong>若tryAcquire()返回true，则acquire()直接返回，否则进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。</strong></p>
<p><strong>selfInterrupt()作用</strong>：用户线程第一次获取锁失败之后，进入CLH队列，此时用户可能会中断该线程，所以线程从CLH队列被唤醒之后，要先检查一下之前有没有被中断过，如果中断过了，此时再中断线程。</p>
<h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>获取指定量的资源，tryAcquire方法是模板方法，默认抛出UnsupportedOperationException异常，需要由子类即自定义同步器来实现。</p>
<h3 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3><p><strong>为当前线程以指定模式创建节点，并将其添加到等待队列的尾部</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 创建独占模式节点</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试将节点快速插入（CAS）等待队列，若失败则执行常规插入(enq方法)</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将节点的前驱节点指向尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS 将尾节点修改为 node 节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS失败，则执行常规插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p><strong>常规插入</strong>，和快速插入有以下两点不同：</p>
<ol>
<li>常规插入是自旋过程（for(;;)），能够保证节点插入成功</li>
<li>比快速插入多包含了1种情况：尾节点为空时（当前等待队列为空），需要初始化队列，再插入node节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速插入和常规插入均依赖CAS操作</strong>，其实现依赖于Unsafe类，Unsafe类中的cas操作均是native方法，<strong>由计算机CPU的<code>cmpxchg</code>指令来保证其原子性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS head field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS tail field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h3><p><strong>基于CAS自旋不断尝试获取资源</strong>，如果前驱节点不是头结点，线程会被阻塞（park）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识是否获取资源失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前线程是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前继节点为头结点，说明排队马上排到自己了，可以尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取资源成功，将当前节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC（以方便虚拟机回收掉该前继节点）</span></span><br><span class="line">                <span class="comment">// 标识获取资源成功</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回是否被中断过标识</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 运行到这，说明前驱节点不是头结点或者尝试获取资源失败</span></span><br><span class="line">            <span class="comment">// 通过shouldParkAfterFailedAcquire方法判断是否需要阻塞该节点持有的线程</span></span><br><span class="line">            <span class="comment">// 若shouldParkAfterFailedAcquire函数返回true，则继续执行parkAndCheckInterrupt方法</span></span><br><span class="line">            <span class="comment">// 将该线程阻塞并检查是否被中断过（阻塞期间），若返回true，则将interrupted标志置于true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终获取资源失败，则当前节点放弃获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 头结点的thread为空，表示正在运行的线程</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shouldParkAfterFailedAcquire方法"><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h4><p><strong>判断是否需要阻塞该节点持有的线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前继节点的waitStatus值</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// SIGNAL    = -1;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus = -1，表示前驱节点完成资源的释放或者中断后，会通知当前节点，不用自旋</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  <span class="comment">// CANCELLED =  1;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus &gt; 0，表示前驱节点处于放弃状态（CANCELLED）</span></span><br><span class="line">        <span class="comment">// 继续往前遍历，直到当前节点的前继节点的ws值为0或负数</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果前驱节点的ws值 &lt; -1 </span></span><br><span class="line">        <span class="comment">// 将前驱节点的ws值设置为Node.SIGNAL</span></span><br><span class="line">        <span class="comment">// 保证下次自旋(acquireQueued方法中的自旋)时，shouldParkAfterFailedAcquire直接返回true</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parkAndCheckInterrupt方法"><a href="#parkAndCheckInterrupt方法" class="headerlink" title="parkAndCheckInterrupt方法"></a>parkAndCheckInterrupt方法</h4><p><strong>调用LockSupport类的park()方法阻塞当前线程，并当前线程是否已经中断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    <span class="comment">// 如果被唤醒，查看⾃己是不不是被中断的</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.interrupted()：获取当前线程的中断状态，并且重置中断状态</p>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>AQS使用了<strong>LockSupport</strong>类阻塞和唤醒线程，为什么不使用<strong>Object的wait/notify</strong>呢？</p>
<p>相比Object的wait/notify，LockSupport有两大优势：</p>
<ol>
<li><strong>LockSupport不需要在同步代码块里 。所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦</strong>。</li>
<li><strong>unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序</strong>。</li>
</ol>
<h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h4><p>当failed为true时（表示获取资源失败），执行cancelAcquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找出waitStatus不为1的前驱节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)   <span class="comment">// CANCELLED =  1</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    <span class="comment">// 把当前node的状态设置为CANCELLED，当下一个node排队结束时，自己就会被处理掉</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="comment">// 如果我们是尾节点，将前驱节点（waitStatus不为1）设置为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点从队列中移除</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 如果前驱节点不是头节点，判断前驱节点的waitStatus是否等于Node.SIGNAL（-1）</span></span><br><span class="line">        <span class="comment">// 如果前驱节点的waitStatus不为-1，则设置为-1</span></span><br><span class="line">        <span class="comment">// 如果前驱节点的waitStatus为-1，或者被成功设置为-1</span></span><br><span class="line">        <span class="comment">//    把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，或者前驱节点的waitStatus不为-1，设置-1失败了</span></span><br><span class="line">            <span class="comment">// 则唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果node节点的后继节点为null，或者waitStatus为1，则从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>首先线程通过tryAcquire(arg)尝试获取共享资源，若获取成功则直接返回，若不成功，则将该线程以独占模式添加到等待队列尾部，tryAcquire(arg)由继承AQS的自定义同步器来具体实现；</li>
<li>当前线程加入等待队列后，会通过acquireQueued方法基于CAS自旋不断尝试获取资源，直至获取到资源；</li>
<li>自旋获取资源时，如果前驱节点不是头结点或获取资源失败，会阻塞线程（前驱节点释放资源时会被唤醒）</li>
<li>若在自旋过程中，线程被中断过，acquireQueued方法会标记此次中断，并返回true；</li>
<li>若acquireQueued方法获取到资源后，返回true，则执行线程自我中断操作selfInterrupt()。</li>
</ol>
<h2 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h2><p><strong>以独占方式释放资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// tryRelease也是有继承AQS的自定义同步器来具体实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒头结点的后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryRelease方法"><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h3><p><strong>释放指定量的资源</strong>，tryRelease方法是模板方法，默认抛出UnsupportedOperationException异常，需要由子类即自定义同步器来实现。</p>
<h3 id="unparkSuccessor方法"><a href="#unparkSuccessor方法" class="headerlink" title="unparkSuccessor方法"></a>unparkSuccessor方法</h3><p><strong>唤醒后继节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果node节点的后继节点为null，或者waitStatus为1，则从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么唤醒后继节点中，是从后向前遍历？"><a href="#为什么唤醒后继节点中，是从后向前遍历？" class="headerlink" title="为什么唤醒后继节点中，是从后向前遍历？"></a><strong>为什么唤醒后继节点中，是从后向前遍历？</strong></h4><p>因为cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node。并发情况下从前向后遍历的话，可能就死循环了，所以这时只有prev是稳定的。</p>
<p>唤醒后继节点的线程后，被唤醒的线程在<code>parkAndCheckInterrupt</code>方法，返回线程在park过程中是否被用户中断过，然后到<code>acquireQueued</code>方法中，如果该节点的前驱节点是头节点，则尝试获取资源，成功获取资源后，将是否被中断标识返回<code>acquire</code>方法，如果被中断过，那此时中断。如果被唤醒的线程所在节点的前继节点不是头结点，经过shouldParkAfterFailedAcquire的调整（<strong>清除无效（waitState=CANCELLED）的节点</strong>），也会移动到等待队列的前面，直到其前继节点为头结点。</p>
<h2 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h2><p><strong>以共享方式获取资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment"> * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 负数表示获取失败</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doAcquireShared方法"><a href="#doAcquireShared方法" class="headerlink" title="doAcquireShared方法"></a>doAcquireShared方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将线程以共享模式添加到等待队列的尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 标识是否获取资源失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前线程是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点是头结点，则尝试获取资源</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果获取资源成功，且有剩余资源，将自己设为头结点并唤醒后续的阻塞线程</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted) <span class="comment">// 如果中断标志位为真，则线程执行自我了断</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    <span class="comment">// 表示获取资源成功</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 运行到这，说明前驱节点不是头结点或者尝试获取资源失败</span></span><br><span class="line">            <span class="comment">// 通过shouldParkAfterFailedAcquire方法判断是否需要阻塞该节点持有的线程</span></span><br><span class="line">            <span class="comment">// 若shouldParkAfterFailedAcquire函数返回true，则继续执行parkAndCheckInterrupt方法</span></span><br><span class="line">            <span class="comment">// 将该线程阻塞并检查是否被中断过（阻塞期间），若返回true，则将interrupted标志置于true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终获取资源失败，则当前节点放弃获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，doAcquireShared与独占模式下的acquireQueued大同小异，主要有3点不同：</p>
<ol>
<li>doAcquireShared以指定模式创建节点，并将其添加到等待队列的尾部的操作放在了方法体内部；</li>
<li>doAcquireShared将线程的自我中断操作放在了方法体内部；</li>
<li>当线程获取到资源后，doAcquireShared会将当前线程所在的节点设为头结点，若资源有剩余则唤醒后续节点，比acquireQueued多了个唤醒后续节点的操作。</li>
</ol>
<h3 id="setHeadAndPropagate方法"><a href="#setHeadAndPropagate方法" class="headerlink" title="setHeadAndPropagate方法"></a>setHeadAndPropagate方法</h3><p><strong>将自己设为头结点并唤醒后续的阻塞线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment"> * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment"> * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); <span class="comment">// 将自己设置为头节点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果资源还有剩余，则唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doReleaseShared方法"><a href="#doReleaseShared方法" class="headerlink" title="doReleaseShared方法"></a>doReleaseShared方法</h3><p><strong>向后继节点发出信号并确保传播</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 若head节点状态为SIGNAL，则自旋CAS状态设置为0之后才能唤醒head结点的后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// SIGNAL = -1</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// SIGNAL = -1</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若head节点状态为0，则自旋CAS将节点状态设置为PROPAGATE</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// PROPAGATE = -3</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head指针在自旋期间未发生移动的话，跳出自旋</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Node-PROPAGATE的作用"><a href="#Node-PROPAGATE的作用" class="headerlink" title="Node.PROPAGATE的作用"></a>Node.PROPAGATE的作用</h4><p>学习AQS的过程中，发现Propagate这个状态并没有被显示地使用。</p>
<p>具体可参考：<a href="https://www.zhihu.com/question/295925198" target="_blank" rel="noopener">https://www.zhihu.com/question/295925198</a></p>
<img src="/2020/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS/AQS_acquireShared.png" class="" title="AQS_acquireShared.png">

<h2 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h2><p><strong>以共享方式释放资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整个获取/释放资源的过程是通过传播完成的</strong>，如最开始有10个资源，线程A、B、C分别需要5、4、3个资源。</p>
<ol>
<li>A线程获取到5个资源，其发现资源还剩余5个，则唤醒B线程；</li>
<li>B线程获取到4个资源，其发现资源还剩余1个，唤醒C线程；</li>
<li>C线程尝试取3个资源，但发现只有1个资源，继续阻塞；</li>
<li>A线程释放1个资源，其发现资源还剩余2个，故唤醒C线程；</li>
<li>C线程尝试取3个资源，但发现只有2个资源，继续阻塞；</li>
<li>B线程释放2个资源，其发现资源还剩余4个，唤醒C线程；</li>
<li>C线程获取3个资源，其发现资源还剩1个，继续唤醒后继线程…</li>
</ol>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition是一个接口，AQS中实现了Condition接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition关联的锁。</p>
<p>Condition对象由Lock对象(调用Lock的newCondition()方法)创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>可参考：<code>LinkedBlockingQueue</code>源码</p>
<h3 id="关键成员变量-1"><a href="#关键成员变量-1" class="headerlink" title="关键成员变量"></a>关键成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"><span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出<strong>条件队列也是一个Node节点组成的双向链表</strong></p>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><p>调用await方法的线程肯定是持有锁的线程，即同步队列的头节点（因为调用Condition之前，必须获取到资源）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前线程被中断，抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 将当前线程添加到Condition条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放当前线程持有的锁，并返回锁之前持有的状态值</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不在同步队列中，则挂起该线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 被唤醒的时机有2个：</span></span><br><span class="line">        <span class="comment">// 1. 当前线程被中断</span></span><br><span class="line">        <span class="comment">// 2. 当前线程被signal</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前线程被唤醒，检查该线程是否在挂起期间被中断过，若被中断过，跳出while循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入AQS的CLH同步队列，重新获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE) <span class="comment">// THROW_IE：说明在被signal之前中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 清除已取消的节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT) <span class="comment">// REINTERRUPT：说明在被signal之后中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addConditionWaiter方法"><a href="#addConditionWaiter方法" class="headerlink" title="addConditionWaiter方法"></a>addConditionWaiter方法</h4><p><strong>将当前线程添加进Condition条件队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter; <span class="comment">// 条件队列尾节点</span></span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果尾节点线程已取消，则执行unlinkCancelledWaiters清除已取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程封装为Node节点，状态为Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;  <span class="comment">// 如果尾节点为null，证明条件队列为空，则将头节点指针指向当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node; <span class="comment">// 当前节点作为尾节点的后继节点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// 辅助节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fullyRelease方法"><a href="#fullyRelease方法" class="headerlink" title="fullyRelease方法"></a>fullyRelease方法</h4><p>完全释放当前线程持有的锁，并返回锁之前持有的状态值</p>
<p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment"> * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();<span class="comment">// 获取当前线程持有锁的状态值</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">// 释放锁成功，返回锁之前持有的状态值</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 若最终失败，将当前节点的状态修改为Node.CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列</strong>，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 node.waitStatus = Node.CANCELLED，这个已经入队的节点之后会被后继的节点清除。</p>
<h4 id="checkInterruptWhileWaiting方法"><a href="#checkInterruptWhileWaiting方法" class="headerlink" title="checkInterruptWhileWaiting方法"></a>checkInterruptWhileWaiting方法</h4><p><strong>检查线程是否在挂起期间被中断过</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查线程挂起期间的中断状态：</span></span><br><span class="line"><span class="comment">// 1.若在被signal之前中断，则返回THROW_IE -1</span></span><br><span class="line"><span class="comment">// 2.若在被signal之后中断，则返回REINTERRUPT 1</span></span><br><span class="line"><span class="comment">// 3.若没有被中断，则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果线程在被signal之前cancell，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在被signal后节点的等待状态会被改为0，所以如果cas失败，则说明还没被signal</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><p><strong>唤醒在条件等待队列中等待时间最长的节点(</strong>首节点)，在唤醒节点之前，会将节点移动到AQS的CLH同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment"> * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment"> * owning lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment"> *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前线程不是持有该condition的锁，抛IllegalMonitorStateException异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal方法"><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h4><p><strong>将头节点转移到AQS的CLH同步队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment"> * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment"> * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 头节点指针往后移动一个节点</span></span><br><span class="line">        <span class="comment">// 若当前头结点的后继节点为null，则尾节点置为null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将之前头节点的后继节点置为null，便于GC</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点未成功转移到AQS的CLH同步队列且头节点不为null，继续自旋</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于将条件队列节点转移到AQS的CLH同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果CAS失败，说明节点在signal之前被取消了，返回false</span></span><br><span class="line">    <span class="comment">// 设置入队节点的等待状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 设置成功则AQS的CLH同步队列尾部.</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">// 获取入队节点的前继节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 1. 如果前继节点取消，则直接唤醒当前节点线程</span></span><br><span class="line">    <span class="comment">// 2. 如果为非取消节点则将前继节点设置为SIGNAL（等前驱节点唤醒自己）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程被唤醒后，则会进入<code>checkInterruptWhileWaiting</code>方法</p>
<h3 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a>signalAll方法</h3><p><strong>唤醒在条件等待队列中所有的节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment"> * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment"> *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前线程不是持有该condition的锁，抛IllegalMonitorStateException异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignalAll方法"><a href="#doSignalAll方法" class="headerlink" title="doSignalAll方法"></a>doSignalAll方法</h4><p><strong>将所有节点转移到AQS的CLH同步队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将节点转移到AQS的CLH同步队列</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="await方法-指定超时时间"><a href="#await方法-指定超时时间" class="headerlink" title="await方法-指定超时时间"></a>await方法-指定超时时间</h3><p>和await方法很类似，主要是挂起线程改成挂起线程加上超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements timed condition wait.</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment"> *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment"> *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractQueuedLongSynchronizer"><a href="#AbstractQueuedLongSynchronizer" class="headerlink" title="AbstractQueuedLongSynchronizer"></a>AbstractQueuedLongSynchronizer</h2><p><code>AbstractQueuedLongSynchronizer</code>具有与<code>AbstractQueuedSynchronizer</code>完全相同的结构，属性和方法，但所有与状态相关的参数和结果都定义为long而不是int 。 在创建同步器（如多级锁和需要64位状态的障碍）时，此类可能很有用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>AbstractQueuedSynchronizer</tag>
        <tag>AbstractQueuedLongSynchronizer</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解CountDownLatch</title>
    <url>/2020/08/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CountDownLatch/</url>
    <content><![CDATA[<p><strong>CountDownLatch基于AQS的共享模式，用来控制一个或者多个线程等待多个线程</strong>。</p>
<p>CountDownLatch使用一个计数器进行实现。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p>
<a id="more"></a>

<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nCpu = <span class="number">4</span>, queueCapacity = nCpu + <span class="number">1</span>;</span><br><span class="line">    ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(nCpu,</span><br><span class="line">            nCpu,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(queueCapacity),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch cdOrder = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch cdAnswer = <span class="keyword">new</span> CountDownLatch(nCpu);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCpu; i++) &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"正在等待裁判发布口令"</span>);</span><br><span class="line">                cdOrder.await();</span><br><span class="line">                System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"起跑了"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"到达终点"</span>);</span><br><span class="line">                cdAnswer.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">        System.out.println(<span class="string">"裁判"</span> + Thread.currentThread().getName() + <span class="string">"即将发布口令"</span>);</span><br><span class="line">        cdOrder.countDown();</span><br><span class="line">        System.out.println(<span class="string">"裁判"</span> + Thread.currentThread().getName() + <span class="string">"已发送口令，正在等待所有选手到达终点"</span>);</span><br><span class="line">        cdAnswer.await();</span><br><span class="line">        System.out.println(<span class="string">"所有选手都到达终点"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-1</span>正在等待裁判发布口令</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-2</span>正在等待裁判发布口令</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-3</span>正在等待裁判发布口令</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-4</span>正在等待裁判发布口令</span><br><span class="line">裁判main即将发布口令</span><br><span class="line">裁判main已发送口令，正在等待所有选手到达终点</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-3</span>起跑了</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-4</span>起跑了</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-1</span>起跑了</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-2</span>起跑了</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-2</span>到达终点</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-4</span>到达终点</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-3</span>到达终点</span><br><span class="line">选手pool<span class="number">-1</span>-thread<span class="number">-1</span>到达终点</span><br><span class="line">所有选手都到达终点</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count); <span class="comment">// 用的是AQS中的state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写了AQS中的方法：尝试获取共享资源</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当状态为0，则该线程获取到该共享锁</span></span><br><span class="line">        <span class="comment">// 刚开始肯定state被设置成count,所以肯定获取失败，只有当所有线程释放了锁（countDown）才能获取到</span></span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写了AQS中的方法：尝试释放共享资源</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 减少count，当检测到状态值为0时，通知同步队列中被挂起的线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p>调用了AQS中的<code>doAcquireSharedInterruptibly</code>，<code>doAcquireSharedInterruptibly</code>和<code>doAcquireShared</code>很相似，主要区别是<code>doAcquireSharedInterruptibly</code>响应中断（抛出InterruptedException异常），而<code>doAcquireShared</code>不响应中断（记录中断，最后再<code>selfInterrupt()</code>）。</p>
<p><strong>只要共享锁状态值不为0，则请求共享锁的线程均会添加到同步队列中，阻塞挂起，等待被通知。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写了AQS中的方法：尝试获取共享资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态为0，则该线程获取到该共享锁</span></span><br><span class="line">    <span class="comment">// 刚开始肯定state被设置成count,所以肯定获取失败，只有当所有线程释放了锁（countDown）才能获取到</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这些被阻塞挂起的线程啥时候会被唤醒继续执行呢？答案就在<code>countDown</code>方法中</p>
<h2 id="countDown方法"><a href="#countDown方法" class="headerlink" title="countDown方法"></a>countDown方法</h2><p><strong>释放一个资源，当检测到状态值为0时，通知同步队列中被挂起的线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrements the count of the latch, releasing all waiting threads if</span></span><br><span class="line"><span class="comment"> * the count reaches zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current count is greater than zero then it is decremented.</span></span><br><span class="line"><span class="comment"> * If the new count is zero then all waiting threads are re-enabled for</span></span><br><span class="line"><span class="comment"> * thread scheduling purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current count equals zero then nothing happens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>); <span class="comment">// 释放一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">// doReleaseShared会唤醒同步队列中阻塞挂起的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写了AQS中的方法：尝试释放共享资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// CAS减少count</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 当检测到状态值为0时，通知同步队列中被挂起的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒后的线程会进行获取锁的操作。当状态值归零后，由于tryReleaseShared恒返回1，代表任何线程均可以获取共享锁成功。</p>
<p>也就是说：<strong>CountDownLatch是一次性的，在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解CyclicBarrier</title>
    <url>/2020/08/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CyclicBarrier/</url>
    <content><![CDATA[<p><strong>CyclicBarrier基于AQS的Condition来实现。</strong></p>
<p><strong>相比CountDownLatch，CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</strong></p>
<p>CyclicBarrier允许一组线程在到达某个栅栏点(common barrier point)互相等待，直到最后一个线程到达栅栏点，栅栏才会打开，处于阻塞状态的线程恢复继续执行。</p>
<a id="more"></a>

<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>注意下面的<code>CyclicBarrier</code>可以循环使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCyclicBarrier</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nCpu = <span class="number">4</span>, queueCapacity = nCpu + <span class="number">1</span>;</span><br><span class="line">    ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(nCpu,</span><br><span class="line">            nCpu,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(queueCapacity),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span> (Boolean.TRUE) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCpu; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"正在准备"</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                    System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"准备就绪"</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"起跑了"</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                    System.out.println(<span class="string">"选手"</span> + Thread.currentThread().getName() + <span class="string">"到达终点"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException | InterruptedException ie) &#123;</span><br><span class="line">                    ie.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">1</span>正在准备</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">3</span>正在准备</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">2</span>正在准备</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">4</span>正在准备</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">4</span>准备就绪</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">3</span>准备就绪</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">1</span>准备就绪</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">2</span>准备就绪</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">2</span>起跑了</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">4</span>起跑了</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">3</span>起跑了</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">1</span>起跑了</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">4</span>到达终点</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">2</span>到达终点</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">1</span>到达终点</span><br><span class="line">选手pool-<span class="number">1</span>-thread-<span class="number">3</span>到达终点</span><br></pre></td></tr></table></figure>

<h2 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;  <span class="comment">// 表示需要拦截的线程数</span></span><br><span class="line"><span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">// 设置了这个，代表越过栅栏之前要执行相应的操作(一代只执行一次)</span></span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation(); <span class="comment">// 当前所处的代或周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>; <span class="comment">// 是否被打破</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties; <span class="comment">// parties表示需要拦截的线程数</span></span><br><span class="line">    <span class="keyword">this</span>.count = parties;  <span class="comment">// 还没有到栅栏的线程数</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction; <span class="comment">// 代表越过栅栏之前要执行相应的操作(一代只会执行一次)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p><strong>等待其他线程达到栅栏，然后一起越过栅栏。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"> 		<span class="comment">// 若栅栏已被打破，抛出BrokenBarrierException异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 只要有1个线程被中断，则打破栅栏</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对count执行减1操作，因为已经获取了独占锁，所以不用进行cas操作</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 最后一个到达栅栏的线程，才会执行下述代码</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 若barrierAction不为null，则执行barrierAction</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 创建下一代栅栏</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 如果执行barrierAction发送异常，则打破栅栏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 只要不是最后一个线程，就执行自旋，直到栅栏被打破、线程被中断或等待超时</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await(); <span class="comment">// 不带超时机制调用condition的await方法</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos); <span class="comment">// 带超时机制调用awaitNanos方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier(); <span class="comment">//打破栅栏</span></span><br><span class="line">                    <span class="keyword">throw</span> ie; <span class="comment">// 重新抛出InterruptedException异常给外层调用的方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒后，检查栅栏是否已被打破</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span></span><br><span class="line">            <span class="comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，满足 g != generation</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            <span class="comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放独占锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nextGeneration方法"><a href="#nextGeneration方法" class="headerlink" title="nextGeneration方法"></a>nextGeneration方法</h2><p><strong>创建下一代栅栏</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment"> * Called only while holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll(); <span class="comment">// 将阻塞在trip上的线程依次唤醒</span></span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties; <span class="comment">// 更新 count 的值</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation(); <span class="comment">// 创建下一代栅栏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="breakBarrier方法"><a href="#breakBarrier方法" class="headerlink" title="breakBarrier方法"></a>breakBarrier方法</h2><p><strong>打破栅栏</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets current barrier generation as broken and wakes up everyone.</span></span><br><span class="line"><span class="comment"> * Called only while holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>; <span class="comment">// 设置状态 broken 为 true</span></span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll(); <span class="comment">// 将阻塞在trip上的线程依次唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reset方法"><a href="#reset方法" class="headerlink" title="reset方法"></a>reset方法</h2><p><strong>重置栅栏</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the barrier to its initial state.  If any parties are</span></span><br><span class="line"><span class="comment"> * currently waiting at the barrier, they will return with a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * a breakage has occurred for other reasons can be complicated to</span></span><br><span class="line"><span class="comment"> * carry out; threads need to re-synchronize in some other way,</span></span><br><span class="line"><span class="comment"> * and choose one to perform the reset.  It may be preferable to</span></span><br><span class="line"><span class="comment"> * instead create a new barrier for subsequent use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java线程池</title>
    <url>/2020/08/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>Java中开辟出了一种管理线程的概念，这个概念叫做<strong>线程池</strong>，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。</p>
<p>线程池的概念是Executor这个接口，具体实现为ThreadPoolExecutor类，JDK也提供了线程池的工具类Executors可以方便我们创建线程池（不推荐使用）。</p>
<a id="more"></a>

<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>JDK 的 Executors 类中提供了几种具有代表性的线程池，这些线程池 都是基于 ThreadPoolExecutor 的定制化实现。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p><strong>创建一个单线程的线程池</strong>，只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。</p>
<p>单工作线程最大的特点是：可保证顺序地执行各个任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：LinkedBlockingQueue没有设置大小，默认为<code>Integer.MAX_VALUE</code>，可能导致内存溢出。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p><strong>创建一个固定大小的线程池</strong>。每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。</p>
<p>FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：LinkedBlockingQueue没有设置大小，默认为<code>Integer.MAX_VALUE</code>，可能导致内存溢出。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p><strong>创建一个可缓存的线程池</strong>。</p>
<ul>
<li>如果线程池长度超过处理任务所需要的线程数，就会回收部分空闲的线程；</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程池最大为<code>Integer.MAX_VALUE</code>，容易导致内存溢出。</p>
<h3 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h3><p><strong>创建一个定长的线程池</strong>。<strong>此线程池支持定时以及周期性执行任务的需求</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程池最大为<code>Integer.MAX_VALUE</code>，但是因为DelayedWorkQueue是无界队列，所以实际上最大线程数是corePoolSize，但是也因为DelayedWorkQueue是无界队列，所以容易导致内存溢出。</p>
<h3 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h3><p><strong>创建一个单线程的线程池</strong>。<strong>此线程池支持定时以及周期性执行任务的需求</strong>。实际上调用了newScheduleThreadPool的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为newScheduleThreadPool使用了无界队列，所以也会导致内存溢出。</p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><img src="/2020/08/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B.png" class="" title="线程池流程.png">

<p>注意：如果使用的是无界队列，那最大线程数maximumPoolSize则无效。</p>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><p>ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，发现前面三个构造器最终都是调用的第四个构造器进行的初始化工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3><p><strong>核心线程池的大小</strong>，这个参数跟线程池的实现原理有非常大的关系。在<strong>创建了线程池后，默认情况下，线程池中并没有任何线程</strong>，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到阻塞队列当中。</p>
<h4 id="合理设置线程池大小"><a href="#合理设置线程池大小" class="headerlink" title="合理设置线程池大小"></a>合理设置线程池大小</h4><p>经验估计：</p>
<ol>
<li>CPU 密集型应用，线程池大小设置为 N + 1</li>
<li>IO 密集型应用，线程池大小设置为 2N </li>
</ol>
<p>精准计算：</p>
<blockquote>
<p><strong>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</strong></p>
</blockquote>
<p>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</p>
<p>下面举个例子：比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。</p>
<h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3><p>线程池最大线程数，它表示在线程池中最多能创建多少个线程</p>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>表示线程没有任务执行时最多保持多久时间会终止。<strong>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</strong>，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时keepAliveTime参数也会起作用，直到线程池中的线程数为0。</p>
<h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p><strong>参数keepAliveTime的时间单位</strong>，有7种取值，在TimeUnit类中有7种静态属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS;              <span class="comment">// 天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">// 小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">// 分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">// 秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">// 毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">// 微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>

<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p><strong>一个阻塞队列，用来存储等待执行的任务</strong>。这个参数的选择也很重要，会对线程池的运行过程产生重大影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue <span class="comment">// 一个由数组结构组成的有界阻塞队列。</span></span><br><span class="line">LinkedBlockingQueue <span class="comment">// 一个由链表结构组成的有界（但大小默认值为Interger.MAX_VALUE）阻塞队列。</span></span><br><span class="line">PriorityBlockingQueue <span class="comment">// 一个支持优先级排序的无界阻塞队列。</span></span><br><span class="line">DelayQueue <span class="comment">// 一个使用优先级队列实现的无界阻塞队列。</span></span><br><span class="line">SynchronousQueue <span class="comment">// 一个不存储元素的阻塞队列，也即单个元素的阻塞队列。</span></span><br><span class="line">LinkedTransferQueue <span class="comment">// 一个由链表结构组成的无界阻塞队列</span></span><br><span class="line">LinkedBlockingDeque <span class="comment">// 一个由链表结构组成的双向有界阻塞队列</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>使用阻塞队列最好定义队列大小</strong>，防止出现OOM。</p>
<h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p><strong>线程工厂，主要用来创建线程，可以自定义线程名字</strong>，使用示例：Executors.defaultThreadFactory()，cn.hutool.core.thread.NamedThreadFactory</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>拒绝策略，表示当拒绝处理任务时的策略，有以下四种取值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy       <span class="comment">// 默认策略，丢弃任务并抛出RejectedExecutionException异常</span></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy       <span class="comment">// 也是丢弃任务，但是不抛出异常</span></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy <span class="comment">// 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy    <span class="comment">// 由调用线程处理该任务</span></span><br></pre></td></tr></table></figure>

<h2 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来标记线程池状态和线程个数（高3位表示线程池状态，低29位表示线程个数）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 线程个数掩码，一般int是32位，32-3=29表示ctl低29用来表示线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 线程最大个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 101，后面补29个0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 000，后面补29个0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 001，后面补29个0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 010，后面补29个0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 011，后面补29个0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">// 线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 用来存放工作集</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">// 线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;   </span><br><span class="line"><span class="comment">// 是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">// 核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">// 线程池最大能容忍的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">// 线程池中当前的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"><span class="comment">// 任务拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">// 线程工厂，用来创建线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">// 用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 用来记录已经执行完毕的任务个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br></pre></td></tr></table></figure>

<h2 id="线程池状态含义"><a href="#线程池状态含义" class="headerlink" title="线程池状态含义"></a>线程池状态含义</h2><img src="/2020/08/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E5%90%AB%E4%B9%89.png" class="" title="线程池状态含义.png">

<ol>
<li><p>RUNNING：接受新任务并且处理阻塞队列里的任务；</p>
</li>
<li><p>SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务；</p>
</li>
<li><p>STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务；</p>
</li>
<li><p>TIDYING：所有任务都执行完（包含阻塞队列里面任务）当前线程池活动线程为 0，将要调用 terminated方法；</p>
</li>
<li><p>TERMINATED：终止状态，terminated方法调用完成以后的状态。</p>
</li>
</ol>
<h2 id="线程池状态转换"><a href="#线程池状态转换" class="headerlink" title="线程池状态转换"></a>线程池状态转换</h2><img src="/2020/08/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.png" class="" title="线程池状态转化.png">

<ul>
<li><p>RUNNING -&gt; SHUTDOWN：显式调用 shutdown() 方法，或者隐式调用了 finalize()，它里面调用了 shutdown() 方法。</p>
</li>
<li><p>RUNNING or SHUTDOWN -&gt; STOP：显式调用 shutdownNow() 方法时候。</p>
</li>
<li><p>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空的时候。</p>
</li>
<li><p>STOP -&gt; TIDYING：当线程池为空的时候。</p>
</li>
<li><p>TIDYING -&gt; TERMINATED：执行tryTerminate()方法，当 terminated()方法（实际上什么都没干）执行完成后。</p>
</li>
</ul>
<h2 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">        * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">        * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">        * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">        * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">        * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">        * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">        * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">        * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">        * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">        * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">        * and so reject the task.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果当前线程池线程个数是否小于corePoolSize,小于则开启新线程运行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池处于RUNNING状态，则添加任务到阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新检查</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 否者如果当前线程池线程空，则添加一个线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了，则新增线程，新增失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果线程个数超过限制则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// cas 增加线程个数</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// cas 失败则检查线程池状态，如果状态发生了改变，则跳到最外层循环，否则内层循环重新进行cas</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明CAS增加线程个数成功</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加独占锁，为了workers同步，因为可能多个线程调用了线程池的execute方法</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 重新检查线程池状态，为了避免在获取锁前调用了shutdown接口</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 添加任务</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功则启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加失败，则移除Worker</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cas 减小线程个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>在下面几种情况下会返回 false：</p>
<ol>
<li>当前线程池状态为 STOP，TIDYING，TERMINATED</li>
<li>当前线程池状态为 SHUTDOWN 并且已经有了第一个任务</li>
<li>当前线程池状态为 SHUTDOWN 并且任务队列为空</li>
</ol>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>使用了线程工厂创建线程，Worker类实现了Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker（调用runWorker前禁止中断）</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadFactory <span class="title">getThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数内首先设置 Worker 的状态为 -1，是为了避免当前 worker 在调用 runWorker 方法前被中断（当其它线程调用了线程池的 shutdownNow 时候，如果 worker 状态 &gt;= 0 则会中断该线程）。这里设置了线程的状态为 -1，所以该线程就不会被中断了。运行 runWorker 的代码时候会调用 unlock 方法，该方法把 status 变为了 0，所以这时候调用 shutdownNow 就会中断 worker 线程了。</p>
<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>如果task为空，则往阻塞队列中获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don't need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread's</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread's UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts（将Worker状态设置为0，运行中断）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，将state修改为1</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务前干一些事，其实啥也没干</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务后干一些事，其实啥也没干</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 统计当前Worker完成多少任务</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 执行清理任务</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这段代码<strong>体现了线程池的复用机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 统计整个线程池完成的任务个数,并从工作集里面删除当前woker</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试设置线程池状态为TERMINATED，如果当前是shutdonw状态并且工作队列为空</span></span><br><span class="line">    <span class="comment">// 或者当前是stop状态当前线程池里面没有活动线程则设置线程池状态为 TERMINATED</span></span><br><span class="line">    <span class="comment">// 如果设置为了 TERMINATED 状态还需要调用条件变量 termination 的 signalAll() 方法</span></span><br><span class="line">    <span class="comment">// 激活所有因为调用线程池的 awaitTermination 方法而被阻塞的线程</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程个数小于核心个数，则新增一个线程</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>如果getTask方法返回null，那么这个Worker线程则会被删除（processWorkerExit方法）</p>
<p>以下几种情况，getTask方法会返回NULL：</p>
<ol>
<li>当前线程数超过了最大线程数（可能重新调用了setMaximumPoolSize方法）</li>
<li>线程池状态为大于STOP（状态为STOP、TIDYING、TERMINATED）</li>
<li>线程池状态为SHUTDOWN，阻塞队列为空</li>
<li>等待超时</li>
</ol>
<p>注意：这里不会判断该线程是不是核心线程。线程池中的线程都是放在<code>HashSet&lt;Worker&gt; workers</code>中，只有创建前会标识它是否为核心线程，但是创建后没有存储该标识，所以删除时根据线程的执行情况删除（先获取到空的任务的线程被删除）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h2><p>调用 shutdown() 后，<strong>线程池就不会在接受新的任务了，但是工作队列里面的任务还是要执行的</strong>，该方法立刻返回的，并不等待队列任务完成在返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment"> * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment"> * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment"> * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment"> * to do that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置当前线程池状态为SHUTDOWN，如果已经是SHUTDOWN则直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 设置中断标志</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试状态变为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 如果当前状态 &gt;= targetState 则直接返回，否则CAS设置当前状态为 targetState</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了安全管理器，则看当前调用 shutdown 命令的线程是否有关闭线程的权限，如果有权限则还要看调用线程是否有中断工作线程的权限，如果没有权限则抛出 SecurityException 或者 NullPointerException 异常。</p>
<h3 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h3><p>设置所有空闲线程的中断标志，这里首先加了全局锁，同时只有一个线程可以调用 shutdown 设置中断标志，然后尝试获取 worker 自己的锁，获取成功则设置中断标识，由于正在执行的任务已经获取了锁，所以正在执行的任务没有被中断。这里中断的是阻塞到 getTask() 方法，企图从队列里面获取任务的线程，也就是空闲线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 如果工作线程没有被中断，并且没有正在运行则设置设置中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shutdownnow方法"><a href="#shutdownnow方法" class="headerlink" title="shutdownnow方法"></a>shutdownnow方法</h2><p>调用 shutdownNow 后，<strong>线程池就不会在接受新的任务了，并且丢弃工作队列里面里面的任务，正在执行的任务会被中断</strong>，该方法是立刻返回的，并不等待激活的任务执行完成再返回。返回值为这时候队列里面被丢弃的任务列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment"> * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment"> * that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment"> * from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment"> * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment"> * do that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment"> * processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment"> * cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment"> * fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态为stop</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有线程（包含空闲线程和正在执行任务的线程）</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 移动队列任务到tasks</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interruptWorkers方法"><a href="#interruptWorkers方法" class="headerlink" title="interruptWorkers方法"></a>interruptWorkers方法</h3><p>中断所有的线程，包含空闲线程和正在执行任务的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts all threads, even if active. Ignores SecurityExceptions</span></span><br><span class="line"><span class="comment"> * (in which case some threads may remain uninterrupted).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// state &gt;=0 才需要中断，而state状态启动之前是-1，启动后是0，运行前加锁修改为1</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="awaitTermination方法"><a href="#awaitTermination方法" class="headerlink" title="awaitTermination方法"></a>awaitTermination方法</h2><p>当线程调用 awaitTermination 方法后，当前线程会被阻塞，知道线程池状态变为了 TERMINATED 才返回，或者等待时间超时才返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述判断当前线程池状态是否至少是 TERMINATED 状态，如果是则直接返回。否则说明当前线程池里面还有线程在执行，则看设置的超时时间 nanos 是否小于 0，小于 0 则说明不需要等待，则直接返回；如果大于0则调用条件变量 termination 的 awaitNanos 方法等待 nanos 时间，期望在这段时间内线程池状态内变为 TERMINATED 状态。</p>
<p>processWorkerExit方法时候提到当线程池状态变为 TERMINATED 后，会调用 termination.signalAll() 用来激活调用条件变量 termination 的 await 系列方法被阻塞的所有线程，所以如果在调用了 awaitTermination 之后调用了 shutdown 方法，并且 shutdown 内部设置线程池状态为 TERMINATED 了，则 termination.awaitNanos 方法会返回。</p>
<h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 激活调用条件变量termination的await系列方法被阻塞的所有线程</span></span><br><span class="line">                    termination.signalAll(); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="创建线程池时候要指定与业务相关的名字，以便于追溯问题"><a href="#创建线程池时候要指定与业务相关的名字，以便于追溯问题" class="headerlink" title="创建线程池时候要指定与业务相关的名字，以便于追溯问题"></a>创建线程池时候要指定与业务相关的名字，以便于追溯问题</h3><p>自定义ThreadFactory，可参考Executors.defaultThreadFactory()，cn.hutool.core.thread.NamedThreadFactory</p>
<h3 id="线程池中使用-ThreadLocal-导致内存泄露"><a href="#线程池中使用-ThreadLocal-导致内存泄露" class="headerlink" title="线程池中使用 ThreadLocal 导致内存泄露"></a>线程池中使用 ThreadLocal 导致内存泄露</h3><p>线程池里面设置了 ThreadLocal 变量一定要记得及时清理，因为线程池里面的核心线程是一直存在的，如果不清理，那么线程池的核心线程的 threadLocals 变量一直会持有 ThreadLocal 变量。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ReentrantLock</title>
    <url>/2020/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantLock/</url>
    <content><![CDATA[<p><strong>ReentrantLock基于AQS的独占模式，默认采用非公平锁，是一种可重入锁。</strong></p>
<p><strong>可以在构造方法中指定是公平锁还是非公平锁</strong></p>
<a id="more"></a>

<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p><code>ArrayBlockingQueue</code>中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁主要体现在获取锁时不判断是否有人在排队，直接cas操作尝试获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不判断队列中是否有线程在等待，直接cas操作尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 把自己设置为占用锁的线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquire是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 为0表示锁没被占用</span></span><br><span class="line">        <span class="comment">// 不判断队列中是否有线程在等待，直接cas操作尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 如果锁被占用，判断是不是自己占用的锁，这体现了重入性</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquire是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 为0表示锁没被占用</span></span><br><span class="line">            <span class="comment">// 判断是否有线程在等待，这体现了公平性</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 如果锁被占用，判断是不是自己占用的锁，这体现了重入性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 获取失败，后面就是执行AQS的排队方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，直接调用CAS方法进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到CLH队列等待唤醒（AQS中已实现）。</p>
<p><strong>非公平锁会有更好的性能</strong>，因为它的吞吐量比较大。当然，<strong>非公平锁</strong>让获取锁的时间变得更加不确定，<strong>可能会导致在阻塞队列中的线程长期处于饥饿状态</strong>。</p>
<h2 id="ReenTrantLock和Synchronized的对比"><a href="#ReenTrantLock和Synchronized的对比" class="headerlink" title="ReenTrantLock和Synchronized的对比"></a>ReenTrantLock和Synchronized的对比</h2><ol>
<li><p><strong>两者都是可重入锁</strong></p>
<p>可重入锁概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
</li>
<li><p><strong>synchronized 依赖于 JVM ， ReenTrantLock 依赖于 API</strong></p>
</li>
<li><p><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>。通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
</li>
<li><p><strong>ReenTrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。</strong>所谓的公平锁就是先等待的线程先获得锁。</p>
</li>
<li><p><strong>ReenTrantLock可实现选择性通知，调度线程更加灵活</strong>。</p>
<p>用ReentrantLock类可以绑定多个Condition实例可以实现选择性通知，而synchronized在使用notify、notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法只会唤醒注册在该Condition实例中的所有等待线程。</p>
</li>
<li><p><strong>synchronized 异常就会释放锁，而 ReenTrantLock 异常需要在 finally 里 unlock</strong></p>
</li>
<li><p><strong>性能已不是选择标准</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>ReentrantLock</tag>
        <tag>重入锁</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ReentrantReadWriteLock</title>
    <url>/2020/08/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantReadWriteLock/</url>
    <content><![CDATA[<p><strong>ReentrantReadWriteLock是读写锁的实现，写锁基于AQS的独占模式，读锁基于AQS的共享模式，读锁和写锁默认采用非公平锁，是一种可重入锁。</strong></p>
<p><strong>可以在构造方法中指定是公平锁还是非公平锁</strong></p>
<a id="more"></a>

<p><strong>ReentrantLock是排他锁，排他锁在同一时刻仅有一个线程可以进行访问</strong>，实际上独占锁是一种相对比较保守的锁策略，独占锁模式下的读/读、读/写、写/写操作都不能同时发生，这在一定程度上降低了吞吐量。然而读操作之间不存在数据竞争问题，如果读/读操作能够以共享锁的方式进行，那会进一步提升性能。</p>
<p>为了解决读写冲突问题，Doug Lea设计了ReadWriteLock接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>; <span class="comment">// 获取读锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>; <span class="comment">// 获取写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享资源的读/写操作分开进行管理，类似于数据库中的S锁(共享锁)和X锁(独占锁)，其遵循如下原则：</p>
<ul>
<li>共享资源只允许加一种锁，或读锁，或写锁，不能同时加；</li>
<li>共享资源可以被多个线程同时加读锁，而写锁只允许加一把；</li>
<li>当共享资源被读锁占用时，写线程只能等待；当共享资源被写锁占用时，读线程只能等待。</li>
</ul>
<p>不同线程读/写、写/写是互斥的，而读/读是互不影响的，大大提升了读操作的效率。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>注意：读写锁都是使用同一个sync对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    <span class="comment">// 读写锁都是使用同一个sync对象</span></span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">    sync = lock.sync;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">    sync = lock.sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Inner class providing readlock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock; <span class="comment">// 读锁</span></span><br><span class="line"><span class="comment">/** Inner class providing writelock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock; <span class="comment">// 写锁</span></span><br><span class="line"><span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line"><span class="keyword">final</span> Sync sync; <span class="comment">// 公平锁或非公平锁</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这块说的就是将 state 一分为二，高 16 位用于共享模式，低16位用于独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 每次增加读锁同步状态，就相当于增加SHARED_UNIT</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">// 读锁或写锁的最大请求数量（包含重入）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 低16位的MASK，用来计算写锁的同步状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 取 c 的高 16 位值，代表读锁的获取次数(包括重入)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">// 返回共享锁数量</span></span><br><span class="line">    <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 取 c 的低 16 位值，代表写锁的重入次数，因为写锁是独占模式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个嵌套类的实例用来记录每个线程持有的读锁数量(即重入次数)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持有的读锁数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 线程 id</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 的子类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合使用上面两个类，用 ThreadLocal 来记录当前线程持有的读锁数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于缓存，记录"最后一个获取读锁的线程"的读锁重入次数，</span></span><br><span class="line">    <span class="comment">// 所以不管哪个线程获取到读锁后，就把这个值占为已用，这样就不用到 ThreadLocal 中查询 map 了</span></span><br><span class="line">    <span class="comment">// 算不上理论的依据：通常读锁的获取很快就会伴随着释放，</span></span><br><span class="line">    <span class="comment">//   显然，在 获取-&gt;释放 读锁这段时间，如果没有其他线程获取读锁的话，此缓存就能帮助提高性能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个获取读锁的线程(并且其未释放读锁)，以及它持有的读锁数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        <span class="comment">// 初始化 readHolds 这个 ThreadLocal 属性</span></span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        <span class="comment">// 为了保证 readHolds 的内存可见性</span></span><br><span class="line">        setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The lock returned by method &#123;<span class="doctag">@link</span> ReentrantReadWriteLock#readLock&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁，基于AQS的共享模式获取资源，中断先记录中断，最后再selfInterrupt()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquireShared是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁，基于AQS的共享模式获取资源，中断则抛出异常（会响应中断）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lock方法"><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h3><p><strong>加读锁</strong>，也是共享锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁，基于AQS的共享模式获取资源，中断先记录中断，最后再selfInterrupt()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// acquireShared是父类AQS中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁，基于AQS的共享模式获取资源，中断则抛出异常（会响应中断）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryAcquireShared方法"><a href="#tryAcquireShared方法" class="headerlink" title="tryAcquireShared方法"></a>tryAcquireShared方法</h3><p><strong>尝试以共享模式获取资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryAcquireShared是Sync中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败（如果持有写锁的是当前线程，是可以继续获取读锁的）</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 总的读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * readerShouldBlock():读锁是否需要等待（公平锁原则）</span></span><br><span class="line"><span class="comment">     * r &lt; MAX_COUNT：总的读锁数量小于最大数（65535），防止溢出</span></span><br><span class="line"><span class="comment">     * compareAndSetState(c, c + SHARED_UNIT)：设置总的读锁数量+1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 总的读锁数量+1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这说明成功获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// r == 0 表示第一个读锁线程，第一个获取读锁firstRead是不会加入到readHolds中</span></span><br><span class="line">            <span class="comment">// 记录 firstReader 为当前线程，及其持有的读锁数量：1</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程，表示第一个读锁线程重入</span></span><br><span class="line">            <span class="comment">// 当前线程持有的读锁数量+1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 总的读锁数量不为0并且不为当前线程</span></span><br><span class="line">            <span class="comment">// 上面说了 cachedHoldCounter 用于缓存最后一个获取读锁的线程</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 如果cachedHoldCounter 缓存的不是当前线程，则设置为缓存当前线程的 HoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// cachedHoldCounter是当前线程，但当前线程持有读锁数量为0，则加入到readHolds中</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 当前线程持有的读锁数量+1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return 大于 0 的数，代表成功获取到了共享锁，即读锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这说明获取读锁需要等待</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="readerShouldBlock方法"><a href="#readerShouldBlock方法" class="headerlink" title="readerShouldBlock方法"></a>readerShouldBlock方法</h3><p><strong>判断读锁是否需要等待</strong></p>
<h4 id="非公平锁实现"><a href="#非公平锁实现" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h4><p>需要判断阻塞队列中 head 的第一个后继节点是否是来获取写锁的，如果是的话让写锁先来，避免写锁饥饿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断阻塞队列中 head 的第一个后继节点是否是来获取写锁的，如果是的话让写锁先来，避免写锁饥饿</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里判断了head 的第一个后继节点是否是来获取写锁，对写锁进行了额外的照顾。</p>
<h4 id="公平锁实现"><a href="#公平锁实现" class="headerlink" title="公平锁实现"></a>公平锁实现</h4><p>判断阻塞队列中有其他元素在等待锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fullTryAcquireShared方法"><a href="#fullTryAcquireShared方法" class="headerlink" title="fullTryAcquireShared方法"></a>fullTryAcquireShared方法</h3><p><strong>全力获取共享锁</strong>。只有当readerShouldBlock() 返回 true，或者compareAndSetState(c, c + SHARED_UNIT) CAS 失败，存在竞争，也可能是读锁数量到达上限。</p>
<ol>
<li>readerShouldBlock() 返回 true<ol>
<li>非公平模式下，head 的第一个后继节点是否是来获取写锁的</li>
<li>公平模式下，阻塞队列中有其他元素在排队</li>
</ol>
</li>
<li>CAS 失败</li>
<li>读锁数量到达上限</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment"> * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">     * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">     * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">     * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果其他线程持有了写锁，直接到阻塞队列排队</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回负数代表获取共享锁失败，获取失败要到阻塞队列排队</span></span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 判断读锁是否需要等待，但也可能是重入</span></span><br><span class="line">            <span class="comment">// 下面这部分代码是处理重入的</span></span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// firstReader是第一个获取读锁的线程，主要是缓存作用，避免频繁查询readHolds</span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter; <span class="comment">// cachedHoldCounter是最后一个获取读锁的线程，主要是缓存作用，避免频繁查询readHolds</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get(); <span class="comment">// 从查询获取HoldCounter</span></span><br><span class="line">                        <span class="comment">// 如果发现 count == 0，也就是说，纯属上一行代码初始化的，那么remove掉，然后到阻塞队列排队</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回负数代表获取共享锁失败，获取失败要到阻塞队列排队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// CAS给读锁数量+1，尝试获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前读锁的总数量为0，则将当前线程设置为第一个获取读锁的线程，设置当前持有的读锁为1</span></span><br><span class="line">                <span class="comment">// 值得注意的是，如果设置了firstReader，就不会放入readHolds中</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 如果第一个获取读锁的线程就是当前线程</span></span><br><span class="line">                firstReaderHoldCount++; <span class="comment">// 设置当前持有的读锁为1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下面这也是先查询缓存</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++; <span class="comment">// 当前线程持有的读锁数量+1</span></span><br><span class="line">                <span class="comment">// 设置最后一个获取读锁的线程为当前线程</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回1表示获取成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果使用<code>firstReader</code>保存了当前线程，就不会再放入<code>readHolds</code>，而<code>cachedHoldCounter</code>保存了当前线程后，还会放入<code>readHolds</code>。</p>
<h3 id="unlock方法"><a href="#unlock方法" class="headerlink" title="unlock方法"></a>unlock方法</h3><p><strong>解锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类AQS中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryReleaseShared方法"><a href="#tryReleaseShared方法" class="headerlink" title="tryReleaseShared方法"></a>tryReleaseShared方法</h3><p><strong>以共享模式释放资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryReleaseShared是Sync中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 如果当前线程是第一个获取读锁的线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 如果当前线程获取的读锁数量是1，则将firstReader置为空，后续成功解锁之后就不再拥有锁了</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果当前线程获取的读锁数量不为1，则将读锁数量-1</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 下面主要是查询缓存，并更新缓存中当前线程持有的读锁数量（读锁数量-1）</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// CAS操作总读锁数量-1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="comment">// 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了</span></span><br><span class="line">            <span class="comment">// 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a>tryLock方法</h3><p><strong>尝试加锁，立即返回是否加锁成功</strong>，虽然也有自旋过程，但不会进入AQS中的同步队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryReadLock方法"><a href="#tryReadLock方法" class="headerlink" title="tryReadLock方法"></a>tryReadLock方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryReadLock是Sync中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败（如果持有写锁的是当前线程，是可以继续获取读锁的）</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// CAS操作将总的读锁数量+1，下面的代码和tryAcquireShared一样</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The lock returned by method &#123;<span class="doctag">@link</span> ReentrantReadWriteLock#writeLock&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁，基于AQS的独占模式获取资源，中断先记录中断，最后再selfInterrupt()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquire是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁，基于AQS的共享模式获取资源，中断则抛出异常（会响应中断）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为持有独占锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前线程持有写锁的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lock方法-1"><a href="#lock方法-1" class="headerlink" title="lock方法"></a>lock方法</h3><p><strong>加写锁</strong>，也是独占锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁，基于AQS的独占模式获取资源，中断先记录中断，最后再selfInterrupt()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// acquire是父类AQS中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p><strong>尝试以独占模式获取资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取独占锁的重入数</span></span><br><span class="line">    <span class="comment">// 当前同步状态state != 0，说明已经有其他线程获取了读锁或写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 1.如果没有线程持有写锁，但又线程持有读锁，那获取写锁失败，需要等读锁释放</span></span><br><span class="line">            <span class="comment">// 2.如果有线程持有写锁，但持有写锁的线程不是自己，需要等写锁释放</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 设置独占锁重入次数+1，因为这里acquires=1</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断写锁是否应该阻塞</span></span><br><span class="line">    <span class="comment">// CAS设置独占锁重入次数+1</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 到这里说明CAS成功，将设置持有写锁的线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回获取成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="writerShouldBlock方法"><a href="#writerShouldBlock方法" class="headerlink" title="writerShouldBlock方法"></a>writerShouldBlock方法</h3><h4 id="非公平锁实现-1"><a href="#非公平锁实现-1" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h4><p>非公平锁不需要判断是否有人排队之类的，这里返回不需要阻塞，直接CAS尝试获取独占锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁实现-1"><a href="#公平锁实现-1" class="headerlink" title="公平锁实现"></a>公平锁实现</h4><p>判断阻塞队列中有其他元素在等待锁（任意锁，因为读锁也可以阻塞写锁）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlock方法-1"><a href="#unlock方法-1" class="headerlink" title="unlock方法"></a>unlock方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类AQS中的方法，释放成功锁后，如果当前节点的waitStatus != 0，则需要唤醒后继节点，忘了的话复习下AQS吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryRelease方法"><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment"> * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment"> * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment"> * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// tryRelease是Sync中的方法</span></span><br><span class="line"><span class="comment">// 因为写锁是独占锁，具有排他性，直接state减1就是了</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// state-1</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">// 如果写锁持有的数量为0，则将当前持有写锁的线程设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>Doug Lea 将持有写锁的线程，去获取读锁的过程称为<strong>锁降级</strong>（Lock downgrading）。这样，此线程就既持有写锁又持有读锁。</p>
<p>但是，锁升级是不可以的。线程持有读锁的话，在没释放的情况下不能去获取写锁，因为会发生<strong>死锁</strong>。</p>
<p>因为获取写锁的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 1.如果没有线程持有写锁，但又线程持有读锁，那获取写锁失败，需要等读锁释放</span></span><br><span class="line">            <span class="comment">// 2.如果有线程持有写锁，但持有写锁的线程不是自己，需要等写锁释放</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程 A 先获取了读锁，然后获取写锁，那么上面的方法会返回false，线程A就到阻塞队列休眠了，自己把自己弄休眠了，而且可能之后就没人去唤醒它了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>ReentrantLock</tag>
        <tag>重入锁</tag>
        <tag>ReentrantReadWriteLock</tag>
        <tag>读锁</tag>
        <tag>写锁</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Semaphore</title>
    <url>/2020/08/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Semaphore/</url>
    <content><![CDATA[<p><strong>Semaphore是基于AQS共享锁来实现，默认采用非公平锁。</strong>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>Semaphore用于限制可以访问某些资源（物理或逻辑的）的线程数目，其维护了一个许可证集合，有多少资源限制就维护多少许可证集合，假如这里有N个资源，那就对应于N个许可证，同一时刻也只能有N个线程访问。一个线程获取许可证就调用acquire方法，用完了释放资源就调用release方法。</p>
<p><strong>可以在构造方法中指定是公平锁还是非公平锁</strong></p>
<a id="more"></a>

<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>下面使用Semaphore进行限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSemaphore</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nCpu = <span class="number">8</span>, queueCapacity = nCpu + <span class="number">1</span>;</span><br><span class="line">    ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(nCpu,</span><br><span class="line">            nCpu,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(queueCapacity),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCpu; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"尝试获取令牌"</span>);</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"成功获取令牌，开始执行业务代码"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"执行业务代码完毕，随后释放令牌"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 休眠1s，确保所有任务都成功提交</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (Boolean.TRUE) &#123;</span><br><span class="line">        <span class="comment">// 判断是否所有线程都执行完毕，执行完毕再推出主线程</span></span><br><span class="line">        <span class="comment">// 因为Junit单元测试 在主线程运行结束后程序就会退出，不会等子线程运行结束</span></span><br><span class="line">        <span class="keyword">if</span> (executorService.isTerminated()) &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">1</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">2</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">2</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">1</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">3</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">5</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">5</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">3</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">4</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">6</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">7</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">8</span>尝试获取令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">2</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">3</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">1</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">5</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">7</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">6</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">4</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">8</span>成功获取令牌，开始执行业务代码</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">7</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">6</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">8</span>执行业务代码完毕，随后释放令牌</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">4</span>执行业务代码完毕，随后释放令牌</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NonFair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits); <span class="comment">// 传入令牌数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquireShared是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写AQS中的TryAcquireShared方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// CAS尝试获取资源acquires，将剩余资源修改为remaining</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁资源，父类Sync中的方法，非公平锁和公平锁释放规则都一样</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquireShared是父类AQS中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果到这，说明队列中有线程在排队，所以当前节点也需要排队</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写AQS中的TryAcquireShared方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 先判断是否有线程在排队，这就体现了公平性</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 没人排队再进行cas操作</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁资源，父类Sync中的方法，非公平锁和公平锁释放规则都一样</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，FairSync的tryAcquireShared方法与Sync的nonfairTryAcquireShared方法相比，只是多了以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Synchronized</title>
    <url>/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/</url>
    <content><![CDATA[<p><strong>Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</strong></p>
<p>Synchronized的作用主要有三个：</p>
<ol>
<li>确保线程互斥的访问同步代码</li>
<li>保证共享变量的修改能够及时可见</li>
<li>有效解决重排序问题</li>
</ol>
<p>从语法上讲，Synchronized总共有三种用法：</p>
<ol>
<li>修饰普通方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p>Synchronized在JDK1.6后的优化，主要包括了<strong>自适应自旋锁、锁消除、锁粗化、轻量级锁和偏向锁</strong></p>
<a id="more"></a>

<h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>当要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。</p>
<p>这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。</p>
<h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><p>我们知道，线程从运行态进入阻塞态这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。</p>
<p>刚才我说线程拿不到锁，就会马上进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历阻塞/唤醒这个花时间的过程了。</p>
<p>然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 — 自旋锁。</p>
<p>自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做空循环，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。</p>
<p>上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。</p>
<p>而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为它再次拿到锁的几率非常大，所以循环的次数会多一些。</p>
<p>而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。</p>
<p>所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为自适应自旋锁。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。</p>
<p>之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。</p>
<p>这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，加锁这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的。为了解决这种动不动就加锁带来的开销，轻量级锁出现了。</p>
<p>轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要做一个标记就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了没有人在执行了。</p>
<p>之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。<br>显然，比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了。</p>
<p>然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。</p>
<p>如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。</p>
<p>所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是错开时间来获取锁的情况。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够轻，然而偏向锁更加省事，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。</p>
<p>偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是单线程，那就没必要加锁了。</p>
<p>不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。</p>
<p>然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。</p>
<p>然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为有人在执行了，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做</p>
<p>你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。</p>
<p>然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着偏向锁已经不适用了，这个时候就会从偏向锁升级为轻量级锁。</p>
<p>所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</p>
<p>Synchronized和ReentrantLock都是可重入锁。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为悲观锁。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点。</p>
<p>而乐观锁却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。</p>
<h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/markword%E7%BB%93%E6%9E%84.png" class="" title="markword结构">

<p><strong>工具：JOL = Java Object Layout</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用效果如下：</p>
 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        System.out.println(student.hashCode());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/markword-hashcode.png" class="" title="markword-hashcode"> 

<p>“0110101 10000001 11000101 11110011”转为十进制就是“897697267”，所以如果不调用对象的hashcode方法，markword中就不会生成hashcode。</p>
<h2 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h2><img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%9D%E6%AD%A5.png" class="" title="锁升级初步"> 

<h3 id="偏向锁未启动-锁升级"><a href="#偏向锁未启动-锁升级" class="headerlink" title="偏向锁未启动-锁升级"></a>偏向锁未启动-锁升级</h3><p><strong>偏向锁未启动</strong>创建对象“lisi”，对象”lisi”出于<strong>无锁</strong>状态。使主线程休眠5s（等偏向锁启动），创建对象“zhangsan”，对象“zhangsan”出于<strong>无锁</strong>状态（准确点是匿名偏向锁，线程ID为0）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSyn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (student)&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadID # "</span> + Thread.currentThread().getId());</span><br><span class="line">                System.out.println(<span class="string">"thread hashcode # "</span> + Thread.currentThread().hashCode());</span><br><span class="line">                System.out.println(<span class="string">"thread hashcode # "</span> + System.identityHashCode(Thread.currentThread()));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (student) &#123;</span><br><span class="line">            System.out.println(<span class="string">"threadID # "</span> + Thread.currentThread().getId());</span><br><span class="line">            System.out.println(<span class="string">"thread hashcode # "</span> + Thread.currentThread().hashCode());</span><br><span class="line">            System.out.println(<span class="string">"thread hashcode # "</span> + System.identityHashCode(Thread.currentThread()));</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" ## "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E9%94%81%E5%8D%87%E7%BA%A7-1.png" class="" title="锁升级-1">  

<p><strong>偏向锁未启动</strong>创建对象，对象处于<strong>无锁</strong>状态，线程1对对象加锁，对象处于<strong>轻量级锁</strong>状态，然后主线程尝试加锁，发生资源竞争，升级为<strong>重量级锁</strong>，最后线程1和主线程都释放了锁，对象处于<strong>无锁</strong>状态。</p>
<h3 id="偏向锁已启动-锁升级"><a href="#偏向锁已启动-锁升级" class="headerlink" title="偏向锁已启动-锁升级"></a>偏向锁已启动-锁升级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        Object student = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (student) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (student)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (student) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E9%94%81%E5%8D%87%E7%BA%A7-2.png" class="" title="锁升级-2">  

<p>主线程休眠5s后<strong>偏向锁已启动</strong>。创建对象后，对象处于<strong>偏向锁</strong>状态（匿名），主线程获取到了锁，对象处于<strong>偏向锁状态</strong>（非匿名）。主线程释放锁后，线程“thread1”获取到锁，对象处于<strong>轻量级锁</strong>状态，然后主线程也要获取锁，此时发生了竞争，则升级为<strong>重量级锁</strong>，最后线程“thread1”和主线程释放锁后，对象处于<strong>无锁</strong>状态。</p>
<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E9%94%81%E5%8D%87%E7%BA%A7-%E6%80%BB%E7%BB%93.png" class="" title="锁升级-总结">  

<p><strong>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程</strong></p>
<p><strong>如果有线程竞争，撤销偏向锁，升级轻量级锁，线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</strong></p>
<p>如果竞争加剧，有线程<strong>超过10次自旋</strong>， -XX:PreBlockSpin， <strong>或者自旋线程数超过CPU核数的一半</strong>， 1.6之后，加入<strong>自适应自旋</strong> （Adapative Self Spinning） ，由 JVM自己控制。</p>
<h3 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h3 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h3 id="偏向锁默认延迟启动"><a href="#偏向锁默认延迟启动" class="headerlink" title="偏向锁默认延迟启动"></a>偏向锁默认延迟启动</h3><p> <strong>默认情况 偏向锁有个时延，默认是4秒</strong></p>
<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0.png" class="" title="偏向锁相关参数"> 

<p>因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDelay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Student lisi = <span class="keyword">new</span> Student(<span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(lisi).toPrintable());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        Student zhangsan = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(zhangsan).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81-%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8.png" class="" title="偏向锁-延迟启动">  

<h3 id="如果计算过对象的hashCode，则对象无法进入偏向状态"><a href="#如果计算过对象的hashCode，则对象无法进入偏向状态" class="headerlink" title="如果计算过对象的hashCode，则对象无法进入偏向状态"></a>如果计算过对象的hashCode，则对象无法进入偏向状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(student.hashCode());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81-3.png" class="" title="偏向锁-3">  

<p>由上图可看出：<strong>如果计算过对象的hashCode，则对象无法进入偏向状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        System.out.println(student.hashCode());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81-4.png" class="" title="偏向锁-4">  

<p>由上图可看出：如果对象处于<strong>匿名偏向锁</strong>状态，计算hashCode后，对象就会处于<strong>无锁</strong>状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (student)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">            System.out.println(student.hashCode());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81-5.png" class="" title="偏向锁-5">  

<p>由上图可看出：如果对象处于<strong>偏向锁（非匿名）</strong>状态，计算hashCode后，对象就会处于<strong>重量级锁</strong>状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (student)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">            System.out.println(student.hashCode());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" # "</span> + ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/%E5%81%8F%E5%90%91%E9%94%81-6.png" class="" title="偏向锁-6">  

<p>由上图可看出：如果对象处于<strong>轻量级锁</strong>状态，计算hashCode后，对象就会处于<strong>重量级锁</strong>状态。</p>
<h3 id="轻量级锁重量级锁的hashCode存在什么地方？"><a href="#轻量级锁重量级锁的hashCode存在什么地方？" class="headerlink" title="轻量级锁重量级锁的hashCode存在什么地方？"></a>轻量级锁重量级锁的hashCode存在什么地方？</h3><p>线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
<h3 id="批量重偏向与批量撤销"><a href="#批量重偏向与批量撤销" class="headerlink" title="批量重偏向与批量撤销"></a>批量重偏向与批量撤销</h3><p>从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<h3 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/26475023" target="_blank" rel="noopener">偏向锁</a></li>
<li><a href="https://www.jianshu.com/p/4758852cbff4" target="_blank" rel="noopener">死磕Synchronized底层实现</a></li>
<li><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">Hotspot JVM锁是否可以降级？</a></li>
<li><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h3><p>下面这个例子介绍了Synchronized的各种不同用法（实际上test1和test2都属于修饰代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        static_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><p>先看下上面的例子去掉synchronized后生成的字节码（删减了一些没必要的内容）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> static_count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field count:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field count:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field count:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #3                  // Field static_count:I</span><br><span class="line">         <span class="number">3</span>: iconst_1</span><br><span class="line">         <span class="number">4</span>: iadd</span><br><span class="line">         5: putstatic     #3                  // Field static_count:I</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是使用synchronized后生成的字节码（删减了一些没必要的内容）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> static_count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2                  // Field count:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit</span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit</span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #3                  // class per/jaceding/myjava/syn/Test</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         <span class="number">5</span>: aload_0</span><br><span class="line">         <span class="number">6</span>: dup</span><br><span class="line">         7: getfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">10</span>: iconst_1</span><br><span class="line">        <span class="number">11</span>: iadd</span><br><span class="line">        12: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">15</span>: aload_1</span><br><span class="line">        <span class="number">16</span>: monitorexit</span><br><span class="line">        <span class="number">17</span>: goto          <span class="number">25</span></span><br><span class="line">        <span class="number">20</span>: astore_2</span><br><span class="line">        <span class="number">21</span>: aload_1</span><br><span class="line">        <span class="number">22</span>: monitorexit</span><br><span class="line">        <span class="number">23</span>: aload_2</span><br><span class="line">        <span class="number">24</span>: athrow</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field count:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field count:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #4                  // Field static_count:I</span><br><span class="line">         <span class="number">3</span>: iconst_1</span><br><span class="line">         <span class="number">4</span>: iadd</span><br><span class="line">         5: putstatic     #4                  // Field static_count:I</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下可以发现，使用synchronized修饰的代码块“test1”、“test2”的字节码中包含有<code>monitorenter</code>、<code>monitorexit</code>指令，而使用synchronized修饰方法“test3”、“test4”的字节码中多了<code>ACC_SYNCHRONIZED</code>标签。</p>
<p>参考JVM规范中关于monitorenter和monitorexit的描述如下图：</p>
<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/monitorenter%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8F%8F%E8%BF%B0.png" class="" title="monitorenter指令的描述">

<p>简单翻译下：</p>
<p>synchronized修饰代码块时，（）中必须是引用类型。</p>
<p>每个对象有一个监视器锁（monitor），当监视器锁被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ol>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权</li>
</ol>
<img src="/2020/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Synchronized/monitorexit%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8F%8F%E8%BF%B0.png" class="" title="monitorexit指令的描述">

<p>简单翻译下：</p>
<p>执行monitorexit的线程必须是与objectref引用的实例关联的monitor的所有者。</p>
<p>指令执行后，monitor的进入数减1，如果进入数为0，那线程就退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
<p>通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<p>而<code>ACC_SYNCHRONIZED</code>标签不同于字节码指令，它是JVM运行时处理的。</p>
<h3 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h3><p>在虚拟机的ObjectMonitor.hpp文件可以monitor监视器源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;</span><br><span class="line">  _count        = <span class="number">0</span>;</span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>;<span class="comment">// 线程重入次数</span></span><br><span class="line">  _object       = NULL;<span class="comment">// 存储Monitor对象</span></span><br><span class="line">  _owner        = NULL;<span class="comment">// 当前持有锁的线程</span></span><br><span class="line">  _WaitSet      = NULL;<span class="comment">// wait状态的线程列表</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ;</span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ;<span class="comment">// 处于等待锁状态block状态的线程列表</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>monitorenter字节码指令对应 InterpreterRuntime:: monitorenter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: <span class="built_in">release</span> stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>inflate方法：是指膨胀为重量级锁</strong></p>
<p>monitorenter字节码指令对应 InterpreterRuntime:: monitorexit</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%note monitor_1</span></span><br><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  elem-&gt;set_obj(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p>而<code>ACC_SYNCHRONIZED</code>标签的处理在bytecodeinterpreter.cpp中的可以找到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lock method if synchronized</span></span><br><span class="line"><span class="keyword">if</span> (METHOD-&gt;is_synchronized()) &#123;</span><br><span class="line">    <span class="comment">// oop rcvr = locals[0].j.r;</span></span><br><span class="line">    oop rcvr;</span><br><span class="line">    <span class="keyword">if</span> (METHOD-&gt;is_static()) &#123;</span><br><span class="line">        rcvr = METHOD-&gt;constants()-&gt;pool_holder()-&gt;java_mirror();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rcvr = LOCALS_OBJECT(<span class="number">0</span>);</span><br><span class="line">        VERIFY_OOP(rcvr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The initial monitor is ours for the taking</span></span><br><span class="line">    BasicObjectLock* mon = &amp;istate-&gt;monitor_base()[<span class="number">-1</span>];</span><br><span class="line">    oop monobj = mon-&gt;obj();</span><br><span class="line">    assert(mon-&gt;obj() == rcvr, <span class="string">"method monitor mis-initialized"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> success = UseBiasedLocking;</span><br><span class="line">    <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">        markOop mark = rcvr-&gt;mark();</span><br><span class="line">        <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">            <span class="comment">// The bias pattern is present in the object's header. Need to check</span></span><br><span class="line">            <span class="comment">// whether the bias owner and the epoch are both still current.</span></span><br><span class="line">            <span class="keyword">intptr_t</span> xx = ((<span class="keyword">intptr_t</span>) THREAD) ^ (<span class="keyword">intptr_t</span>) mark;</span><br><span class="line">            xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;klass()-&gt;prototype_header() ^ xx;</span><br><span class="line">            <span class="keyword">intptr_t</span> yy = (xx &amp; ~((<span class="keyword">int</span>) markOopDesc::age_mask_in_place));</span><br><span class="line">            <span class="keyword">if</span> (yy != <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// At this point we know that the header has the bias pattern and</span></span><br><span class="line">                <span class="comment">// that we are not the bias owner in the current epoch. We need to</span></span><br><span class="line">                <span class="comment">// figure out more details about the state of the header in order to</span></span><br><span class="line">                <span class="comment">// know what operations can be legally performed on the object's</span></span><br><span class="line">                <span class="comment">// header.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the low three bits in the xor result aren't clear, that means</span></span><br><span class="line">                <span class="comment">// the prototype header is no longer biased and we have to revoke</span></span><br><span class="line">                <span class="comment">// the bias on this object.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (yy &amp; markOopDesc::biased_lock_mask_in_place == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="comment">// Biasing is still enabled for this data type. See whether the</span></span><br><span class="line">                    <span class="comment">// epoch of the current bias is still valid, meaning that the epoch</span></span><br><span class="line">                    <span class="comment">// bits of the mark word are equal to the epoch bits of the</span></span><br><span class="line">                    <span class="comment">// prototype header. (Note that the prototype header's epoch bits</span></span><br><span class="line">                    <span class="comment">// only change at a safepoint.) If not, attempt to rebias the object</span></span><br><span class="line">                    <span class="comment">// toward the current thread. Note that we must be absolutely sure</span></span><br><span class="line">                    <span class="comment">// that the current epoch is invalid in order to do this because</span></span><br><span class="line">                    <span class="comment">// otherwise the manipulations it performs on the mark word are</span></span><br><span class="line">                    <span class="comment">// illegal.</span></span><br><span class="line">                    <span class="keyword">if</span> (yy &amp; markOopDesc::epoch_mask_in_place == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// The epoch of the current bias is still valid but we know nothing</span></span><br><span class="line">                        <span class="comment">// about the owner; it might be set or it might be clear. Try to</span></span><br><span class="line">                        <span class="comment">// acquire the bias of the object using an atomic operation. If this</span></span><br><span class="line">                        <span class="comment">// fails we will go in to the runtime to revoke the object's bias.</span></span><br><span class="line">                        <span class="comment">// Note that we first construct the presumed unbiased header so we</span></span><br><span class="line">                        <span class="comment">// don't accidentally blow away another thread's valid bias.</span></span><br><span class="line">                        <span class="keyword">intptr_t</span> unbiased = (<span class="keyword">intptr_t</span>) mark &amp; (markOopDesc::biased_lock_mask_in_place |</span><br><span class="line">                                                               markOopDesc::age_mask_in_place |</span><br><span class="line">                                                               markOopDesc::epoch_mask_in_place);</span><br><span class="line">                        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">intptr_t</span>)THREAD | unbiased, (<span class="keyword">intptr_t</span>*) rcvr-&gt;mark_addr(), unbiased) != unbiased) &#123;</span><br><span class="line">                            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        try_rebias:</span><br><span class="line">                        <span class="comment">// At this point we know the epoch has expired, meaning that the</span></span><br><span class="line">                        <span class="comment">// current "bias owner", if any, is actually invalid. Under these</span></span><br><span class="line">                        <span class="comment">// circumstances _only_, we are allowed to use the current header's</span></span><br><span class="line">                        <span class="comment">// value as the comparison value when doing the cas to acquire the</span></span><br><span class="line">                        <span class="comment">// bias in the current epoch. In other words, we allow transfer of</span></span><br><span class="line">                        <span class="comment">// the bias from one thread to another directly in this situation.</span></span><br><span class="line">                        xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;klass()-&gt;prototype_header() | (<span class="keyword">intptr_t</span>) THREAD;</span><br><span class="line">                        <span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">intptr_t</span>)THREAD | (<span class="keyword">intptr_t</span>) rcvr-&gt;klass()-&gt;prototype_header(),</span><br><span class="line">                                                (<span class="keyword">intptr_t</span>*) rcvr-&gt;mark_addr(),</span><br><span class="line">                                                (<span class="keyword">intptr_t</span>) mark) != (<span class="keyword">intptr_t</span>) mark) &#123;</span><br><span class="line">                            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    try_revoke_bias:</span><br><span class="line">                    <span class="comment">// The prototype mark in the klass doesn't have the bias bit set any</span></span><br><span class="line">                    <span class="comment">// more, indicating that objects of this data type are not supposed</span></span><br><span class="line">                    <span class="comment">// to be biased any more. We are going to try to reset the mark of</span></span><br><span class="line">                    <span class="comment">// this object to the prototype value and fall through to the</span></span><br><span class="line">                    <span class="comment">// CAS-based locking scheme. Note that if our CAS fails, it means</span></span><br><span class="line">                    <span class="comment">// that another thread raced us for the privilege of revoking the</span></span><br><span class="line">                    <span class="comment">// bias of this particular object, so it's okay to continue in the</span></span><br><span class="line">                    <span class="comment">// normal locking code.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    xx = (<span class="keyword">intptr_t</span>) rcvr-&gt;klass()-&gt;prototype_header() | (<span class="keyword">intptr_t</span>) THREAD;</span><br><span class="line">                    <span class="keyword">if</span> (Atomic::cmpxchg_ptr(rcvr-&gt;klass()-&gt;prototype_header(),</span><br><span class="line">                                            (<span class="keyword">intptr_t</span>*) rcvr-&gt;mark_addr(),</span><br><span class="line">                                            mark) == mark) &#123;</span><br><span class="line">                        <span class="comment">// (*counters-&gt;revoked_lock_entry_count_addr())++;</span></span><br><span class="line">                        success = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cas_label:</span><br><span class="line">            success = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        markOop displaced = rcvr-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">        mon-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(mon, rcvr-&gt;mark_addr(), displaced) != displaced) &#123;</span><br><span class="line">            <span class="comment">// Is it simple recursive case?</span></span><br><span class="line">            <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;</span><br><span class="line">                mon-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">THREAD-&gt;clr_do_not_unlock();</span><br></pre></td></tr></table></figure>

<h3 id="汇编层面"><a href="#汇编层面" class="headerlink" title="汇编层面"></a>汇编层面</h3><p>汇编指令</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">lock</span></span> comxchg ...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Synchronized</tag>
        <tag>锁升级</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘IO调度策略</title>
    <url>/2021/03/19/%E7%A3%81%E7%9B%98IO%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Linux 的文件 IO 子系统是 Linux 中最复杂的一个子系统（没有之一）。</p>
<a id="more"></a>

<p><a href="https://www.thomas-krenn.com/de/wikiDE/images/2/2d/Linux-storage-stack-diagram_v4.0.pdf" target="_blank" rel="noopener">下图来源</a></p>
<img src="/2021/03/19/%E7%A3%81%E7%9B%98IO%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/Linux-storage-stack-diagram.png" class="" title="Linux-storage-stack-diagram">

<p>目前Linux系统中的I/O调度策略有4种，分别为（默认为CFQ）：</p>
<ul>
<li><strong>NOOP</strong></li>
<li><strong>CFQ</strong>（默认）</li>
<li><strong>DeadLine</strong></li>
<li><strong>Anticipatory</strong></li>
</ul>
<h2 id="NOOP"><a href="#NOOP" class="headerlink" title="NOOP"></a>NOOP</h2><p>NOOP 全称 No Operation，该算法实现了最简单的 <strong>FIFO</strong> 队列，所有 IO 请求大致按照先来后到的顺序进行操作。之所以说“大致”，原因是 NOOP 在 FIFO 的基础上还做了<strong>相邻 IO 请求的合并</strong>，并不是完全按照先进先出的规则满足I/O请求。</p>
<p>假设有如下的 IO 请求序列：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">500</span> <span class="number">101</span> <span class="number">10</span> <span class="number">56</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>NOOP 将会按照如下顺序满足 IO 请求：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>(<span class="number">101</span>) <span class="number">500</span> <span class="number">10</span> <span class="number">56</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="CFQ"><a href="#CFQ" class="headerlink" title="CFQ"></a>CFQ</h2><p>CFQ 全称 Completely Fair Queuing，该算法的特点是<strong>按照I/O请求的地址进行排序</strong>进行响应。</p>
<p>CFQ 是默认的磁盘调度算法，它试图均匀地分布对 IO 带宽的访问，对于通用服务器来说是最好的选择。</p>
<p>CFQ 为每个进程单独创建一个队列来管理该进程所产生的请求。每个进程一个队列，各队列之间的调度使用时间片进行调度，以此来保证每个进程都能被很好地分配到 IO 带宽。<strong>IO 调度器每次执行一个进程的4次请求</strong>。在传统的SAS盘上，磁盘寻道花去了绝大多数的 IO 响应时间。</p>
<p>CFQ 的出发点是对 IO 地址进行排序，以尽量少的磁盘旋转次数来满足尽可能多的 IO 请求。在 CFQ 算法下，SAS盘的吞吐量大大提高了。相比于 NOOP 的缺点是，先来的 IO 请求并不一定能被满足，<strong>可能会出现“饿死”的情况</strong>。</p>
<p>假设有如下的 IO 请求序列：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">500</span> <span class="number">101</span> <span class="number">10</span> <span class="number">56</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>CFQ 将会按照如下顺序满足：（注意下面只有前4个IO请求进行了排序）</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">101</span> <span class="number">500</span> <span class="number">1000</span> <span class="number">10</span> <span class="number">56</span></span><br></pre></td></tr></table></figure>

<h2 id="DeadLine"><a href="#DeadLine" class="headerlink" title="DeadLine"></a>DeadLine</h2><p>DeadLine 在 CFQ 的基础上，<strong>解决了 IO 请求“饿死”的极端情况</strong>。</p>
<p>除了 CFQ 本身具有的 IO 排序队列，DeadLine 额外分别为读 IO 和写 IO 提供了FIFO队列。读FIFO队列的最大等待时间为500ms，写FIFO队列的最大等待时间为5s。FIFO队列内的 IO 请求优先级要比 CFQ 队列中的高，而读FIFO队列的优先级又比写FIFO队列的优先级高。优先级可以表示如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">FIFO(<span class="name">read</span>) &gt; FIFO(<span class="name">write</span>) &gt; CFQ</span><br></pre></td></tr></table></figure>

<h2 id="Anticipatory"><a href="#Anticipatory" class="headerlink" title="Anticipatory"></a>Anticipatory</h2><p>Anticipatory 在 DeadLine 的基础上，为每个读I/O都设置了6ms的等待时间窗口。如果在6ms内收到了相邻位置的读I/O请求，就可以立即满足。</p>
<p>Anticipatory 算法通过增加等待时间来获得更高的性能，假设一个块设备只有一个物理查找磁头（例如一个单独的SATA硬盘），将多个随机的小写入流合并成一个大写入流（相当于将随机读写变顺序读写），通过这个原理来使用读取/写入的延时换取最大的读取/写入吞吐量。</p>
<p>Anticipatory 算法从Linux 2.6.33版本后被删除了，因为使用 CFQ 通过配置也能达到 Anticipatory 的效果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Linux I/O调度器是 Linux 内核中的一个组成部分，用户可以通过根据不同的存储器来设置 Linux I/O 调度器从而达到优化系统性能。通常来说：</p>
<ul>
<li>NOOP 调度器适用于固态硬盘</li>
<li>CFQ 调度器适用于桌面多任务及媒体应用</li>
<li>DeadLine 调度器适用于写入较多的文件服务器，比如Web服务器，数据库应用</li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看磁盘的IO调度策略，注意：其中sda是硬盘名</span></span><br><span class="line">cat /sys/block/sda/queue/scheduler</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置IO调度策略为 cfq</span></span><br><span class="line">echo cfq &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
        <tag>NOOP</tag>
        <tag>CFQ</tag>
        <tag>DeadLine</tag>
        <tag>Anticipatory</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解volatile</title>
    <url>/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/</url>
    <content><![CDATA[<p>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，<strong>它可以保证线程可见性，防止指令重排序，但不能保证变量状态的“原子性操作”</strong>。</p>
<h3 id="保证线程可见性"><a href="#保证线程可见性" class="headerlink" title="保证线程可见性"></a>保证线程可见性</h3><p>在下面的例子中，如果不加<strong>volatile</strong>关键字修饰flag变量，程序不会输出“end”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h4 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h4><p>在JVM的内存模型中，每个线程有自己的工作内存，实际上JAVA线程借助了底层操作系统线程实现，一个JVM线程对应一个操作系统线程，线程的工作内存其实是cpu寄存器和高速缓存的抽象。</p>
<p>现代处理器的缓存一般分为三级，由每一个核心独享的L1、L2 Cache，以及所有的核心共享L3 Cache组成，具体每个cache，实际上是有很多缓存行组成：</p>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="" title="Java内存模型">

<h4 id="缓存一致性和MESI"><a href="#缓存一致性和MESI" class="headerlink" title="缓存一致性和MESI"></a>缓存一致性和MESI</h4><p><strong>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议（Modified, Exclusive, Shared, Invalid）。</strong></p>
<ul>
<li><strong>独占（Exclusive）</strong>：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li>
<li><strong>共享（Shared）</strong>：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li>
<li><strong>修改（Modified）</strong>：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li>
<li><strong>失效（Invalid）</strong>：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。</li>
</ul>
<p><strong>协议协作如下：</strong></p>
<ol>
<li>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</li>
<li>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</li>
<li>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</li>
<li>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</li>
<li>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</li>
</ol>
<p>关系如下图：</p>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/%E7%BC%93%E5%AD%98%E8%A1%8C%E7%8A%B6%E6%80%81.png" class="" title="缓存行状态">

<p>这个图的含义就是：地址 0x00010000 对应的cacheline在core0上为状态M, 则其它所有的core对应于0x00010000的cacheline都必须为I , 0x00010000 对应的cacheline在core0上为状态S, 则其它所有的core对应于0x00010000的cacheline 可以是S或者I 。</p>
<p><strong>MESI 协议为了提高性能，引入了存储缓存/写缓存器（Store Buffer/Write Buffer）和失效队列（Invalidate Queues），但还是有可能会引起缓存不一致，还会再引入内存屏障来确保一致性。</strong></p>
<p><strong>解释一下这里为什么还可能引起缓存不一致</strong>：</p>
<ol>
<li><p>是编译器的优化带来的问题。我们都知道，从寄存器里面取一个数要比从内存中取快的多，所以有时候编译器为了编译出优化度更高的程序，就会把一些常用变量放到寄存器中，下次使用该变量的时候就直接从寄存器中取，而不再访问内存，就有会出现问题。</p>
</li>
<li><p>write buffer和invalidate queue带来的问题，下面会介绍。</p>
</li>
</ol>
<h4 id="写缓存器、失效队列"><a href="#写缓存器、失效队列" class="headerlink" title="写缓存器、失效队列"></a>写缓存器、失效队列</h4><p>MESI 协议解决了缓存一致性问题， 但是其自身也存在一个性能弱点——处理器执行写内存操作时，必须等待其他所有处理器将其高速缓存中的相应副本数据删除并接收到这些处理器所回复的 Invalidate Acknowledge/Read Response消息之后才能将数据写入高速缓存。无论a之前的值为何，在该条指令执行后都会被覆盖，因此这段等待的开销是完全没有必要的。</p>
<p>写缓冲器和无效化队列的引入又会带来一些新的问题——内存重排序和可见性问题。</p>
<p><strong>存储缓存/写缓存器（Store Buffer/Write Buffer）</strong></p>
<p>也就是常说的写缓存器，当处理器修改缓存时，把新值放到存储缓存中，处理器就可以去干别的事了，把剩下的事交给存储缓存（因为对变量a进行写操作时，无论a之前的值为何，在该条指令执行后都会被覆盖，因此这段等待的开销是完全没有必要的）。但这么做会有两个风险：</p>
<ol>
<li><p>由于store buffer的存在，在CPU中同一个变量可能存在两份拷贝(当缓存行到达CPU时，缓存和store buffer中存在同一个变量的两份拷贝)，这无疑破坏了缓存的一致性，若CPU在store buffer写入缓存之前load数据，就会拿到旧的数据。（为了解决这个问题，CPU设计者又加入了<strong>store forwarding</strong>机制，简单的讲就是CPU会优先从store buffer中取变量，保证同一时刻一个变量在单个CPU中的一致性。）</p>
</li>
<li><p>保存什么时候会完成，这个并没有任何保证。这样可能会导致内存重排序：</p>
<p>在下面这个程序中，假设CPU A执行”exeToCPUA“方法，CPU B执行”exeToCPUB“方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value = <span class="number">3</span>；</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeToCPUA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  value = <span class="number">10</span>;</span><br><span class="line">  isFinsh = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeToCPUB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isFinsh)&#123;</span><br><span class="line">    <span class="comment">//value一定等于10？！</span></span><br><span class="line">    <span class="keyword">assert</span> value == <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一下开始执行前，CPU A保存着finished在E(独享)状态，而value并没有保存在它的缓存中（例如Invalid）。在这种情况下，value会比finished更迟地抛弃存储缓存。完全有可能CPU B读取finished的值为true，而value的值不等于10。</p>
<p><strong>即isFinsh的赋值在value赋值之前。</strong>这种在可识别的行为中发生的变化称为内存重排序（reordings）。<strong>注意：这里和发生在编译器中的指令重排序不一样。</strong></p>
<p>从上面的例子可以看出，一致性问题的出现来源于数据之间的隐式依赖，也就是说必须保证某个操作在另外一个操作之前完成。但是<strong>CPU是无法探测到这种隐式相关性的，必须由程序员自己来进行控制。因此CPU提供了内存屏障指令，该指令使得屏障之前的写操作都在屏障之后的写操作之前完成</strong>。</p>
</li>
</ol>
<p><strong>失效队列（Invalidate Queues）</strong></p>
<p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。为了解决上面两个问题，引进了失效队列（invalidate queue）。处理失效的工作如下：</p>
<ul>
<li>收到失效消息时，放到失效队列中去。</li>
<li>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。</li>
<li>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</li>
</ul>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>“由于编译器的优化和缓存的使用，导致对内存的写入操作不能及时的反应出来，也就是说当完成对内存的写入操作之后，读取出来的可能是旧的内容” ——《独辟蹊径品内核》</p>
<p>硬件层的内存屏障分为两种：<strong>Load Barrier（读屏障） 和 Store Barrier（写屏障）</strong>。写屏障保证屏障之前的写操作对其他CPU都是可见的；读屏障保证屏障之后的读操作读到的都是最新的数据。内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
<p>在JSR规范中定义了4种内存屏障：</p>
<ul>
<li><strong>LoadLoad屏障</strong>：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>LoadStore屏障</strong>：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreStore屏障</strong>：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><strong>StoreLoad屏障</strong>：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。<strong>在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</strong></li>
</ul>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" class="" title="内存屏障">

<p>从上图可以看出：</p>
<ol>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ol>
<p>对于volatile关键字，按照规范会有下面的操作：</p>
<ul>
<li>在每个volatile写入之前，插入一个StoreStore，写入之后，插入一个StoreLoad</li>
<li>在每个volatile读取之前，插入LoadLoad，之后插入LoadStore</li>
</ul>
<h4 id="缓存行对齐"><a href="#缓存行对齐" class="headerlink" title="缓存行对齐"></a>缓存行对齐</h4><p>缓存行（通常是64个字节）是CPU同步的基本单位，<strong>缓存行隔离会比伪共享（False Sharing）效率要高</strong>。</p>
<h5 id="伪共享（False-Sharing）"><a href="#伪共享（False-Sharing）" class="headerlink" title="伪共享（False Sharing）"></a>伪共享（False Sharing）</h5><p>如果多个核的线程在操作同一个缓存行中的不同变量数据，那么就会出现频繁的缓存失效，即使在代码层面看这两个线程操作的数据之间完全没有关系。</p>
<p>这种不合理的资源竞争情况学名伪共享（False Sharing），会严重影响机器的并发执行效率。</p>
<p>下面这个程序中，T继承Padding类程序的执行时间是不继承Padding类程序的执行时间的3~4倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 8中引入了一个更加简单的解决方案：<strong><code>@Contended</code>注解</strong>，比如ConcurrentHashMap中的CounterCell类就用到了这个注解。</p>
<h4 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h4><ol>
<li><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">Disruptor消息队列</a></li>
<li><a href="https://www.jianshu.com/p/a149730f0aec" target="_blank" rel="noopener">写缓冲器与无效化</a></li>
<li><a href="https://www.toutiao.com/a6674518482819744270/?timestamp=1589209556&app=news_article&group_id=6674518482819744270&req_id=20200511230556010020047017014AB751" target="_blank" rel="noopener">CPU缓存一致性协议MESI，memory barrier和java volatile</a>（这篇不错）</li>
<li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li>
<li><a href="https://www.jianshu.com/p/8a58d8335270" target="_blank" rel="noopener">JMM和底层实现原理</a></li>
</ol>
<h3 id="防止指令重排序"><a href="#防止指令重排序" class="headerlink" title="防止指令重排序"></a>防止指令重排序</h3><p><strong>这里解释一下为什么通常只是说volatile可以防止指令重排序</strong>（指的是编译器优化导致的重排序），而不提指令级的重排序和内存层级的重排序。<strong>那是因为volatile是jmm对底层的封装，而指令级的重排序和内存层级的重排序由CPU指令级和缓存一致性协议实现方式决定</strong>，或者说缓存一致性协议不仅有MESI，换到其他协议可能就没有类似问题。</p>
<h4 id="重排序类型"><a href="#重排序类型" class="headerlink" title="重排序类型"></a>重排序类型</h4><img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/%E9%87%8D%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B.png" class="" title="重排序类型">

<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了<strong>指令级并行技术（Instruction-LevelParallelism，ILP）</strong>来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<h4 id="证明指令重排序存在"><a href="#证明指令重排序存在" class="headerlink" title="证明指令重排序存在"></a>证明指令重排序存在</h4><p>在下面的例子中，x, y, a, b初始值为0。线程“one”执行 a = 1, x = b,线程“other”执行 b = 1,  y = a。理论上来说，不可能会发生x = 0, y = 0的情况，除非线程“one”在执行 a = 1 前先执行了 x = b，并且线程“other”在执行 b = 1 前先执行了 y = a。如果发生了 x = 0, y = 0 的情况，就可以证明指令重排序确实存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.png" class="" title="指令重排序">

<h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<h4 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h4><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>
<p><a href="https://www.jianshu.com/p/9464bf340234" target="_blank" rel="noopener">深入理解happens-before规则</a></p>
<h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p>由于volatile的mesi缓存一致性协议需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值。</p>
<p><strong>解决办法：</strong>部分volatile和cas使用synchronized</p>
<h4 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h4><p>需要，正确的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看创建对象的字节码指令（这里简单的以new Object为例）：</p>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" class="" title="对象创建过程">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1 new #2 &lt;java/lang/Object&gt; // 分配对象内存空间</span><br><span class="line"><span class="number">2</span> dup <span class="comment">// 复制操作数堆栈上的最高值，然后将重复的值压入操作数堆栈</span></span><br><span class="line">3 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt; // 初始化对象</span><br><span class="line"><span class="number">4</span> astore_1 <span class="comment">// 设置instance指向刚刚分配的内存地址, 此时instance != null (重点)</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>因为3、4没有依赖关系，在单线程的情况下，无论3、4哪个先执行，都不会影响最终的结果。但是, CPU和编译器在指令重排时, 并不会关心是否影响多线程的执行结果。在不加volatile关键字时, 如果有多个线程访问getInstance方法, 此时正好发生了指令重排, 那么可能出现如下情况:</p>
<p>当第一个线程拿到锁并且进入到第二个if方法后, 先分配对象内存空间, 然后再instance指向刚刚分配的内存地址, instance 已经不等于null, 但此时instance还没有初始化完成。如果这个时候又有一个线程来调用getInstance方法, 在第一个if的判断结果就为false, 于是直接返回还没有初始化完成的instance, 那么就很有可能产生异常。</p>
<h3 id="不能保证原子性"><a href="#不能保证原子性" class="headerlink" title="不能保证原子性"></a>不能保证原子性</h3><p>volatile不能保证变量状态的“原子性操作”。</p>
<p>值得一提的是，<strong>volatile还能够用来保证对long/double型变量的写操作具有原子性</strong>。在Java语言中，对long类型和double类型以外的任何类型的变量的写操作都是原子操作（在某些32位Java虚拟机上，对long/double类型变量的写操作可能不具备原子性）。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h4><p>用volatile关键字修饰变量：<code>valatile boolean flag = false;</code></p>
<h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><p>变量多了一个ACC_VOLATILE标签，运行时处理。</p>
<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/volatile%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E7%8E%B0-1.png" class="" title="volatile字节码实现-1">

<img src="/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/volatile%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E7%8E%B0-2.png" class="" title="volatile字节码实现-2">

<h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4><p><strong>bytecodeinterpreter.cpp</strong>中的一个片段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Now store the result on the stack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TosState tos_type = cache-&gt;flag_state();</span><br><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line"><span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">    VERIFY_OOP(obj-&gt;obj_field_acquire(field_offset));</span><br><span class="line">    SET_STACK_OBJECT(obj-&gt;obj_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">  <span class="comment">//。。。other code</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到第三行有一个判断<strong>is_volatile()</strong>，就是在查看变量是否加了 volatile 修饰。接着后面就有一个调用<strong>OrderAccess::fence()</strong>。这里的 fence 就是屏障的意思。</p>
<p>当然不同的系统和硬件会有不同实现的方式，我们以 Linux 系统为例，在<strong>orderAccess_linux_x86.inline.hpp</strong>文件中可以找到 fence()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，屏障的实现就是依赖于这样一条汇编指令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span>; addl</span><br></pre></td></tr></table></figure>

<h4 id="汇编码层面"><a href="#汇编码层面" class="headerlink" title="汇编码层面"></a>汇编码层面</h4><p>汇编指令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span>; addl</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>内存屏障</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ThreadLocal</title>
    <url>/2020/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/</url>
    <content><![CDATA[<p><code>ThreadLocal</code> 的作用是<strong>提供线程内的局部变量</strong>，这种变量只在线程的生命周期内起作用。</p>
<p><code>ThreadLocal</code> 可以用来减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，但是如果滥用就可能会导致内存泄漏。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。</p>
<p>常规的思路如下：使用一个线程共享的 <code>Map</code>，Map中的 key 为线程对象，value 即为需要存储的值。通过<code>map.get(Thread.currentThread())</code> 就可获取本线程中该变量的值。</p>
<p>虽然这可以实现需求，但这种方式<strong>需要同步，效率低</strong>。</p>
<p>由于这个map对象需要被所有线程共享，因此需要加锁来保证线程安全性。当然我们可以使用<code>ConcurrentHashMap</code> 提高并发效率，但这种方法只能降低锁的粒度，不能从根本上避免同步锁。而<code>ThreadLocal</code>就能很好地解决这一问题。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>ThreadLocal</code> 的内部结构如下图所示：</p>
<img src="/2020/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/ThreadLocal%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="ThreadLocal结构图">

<p><code>ThreadLocal</code>并不维护 <code>ThreadLocalMap</code>，它只是提供了操作该容器的方法。而<code>ThreadLocal</code>的静态内部类 <code>ThreadLocalMap</code> 才是存储数据的容器，并且该容器由 <code>Thread</code> 维护。</p>
<p>每一个<code>Thread</code>对象均含有一个<code>ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，它存储本线程中所有ThreadLocal对象及其对应的值。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t); <span class="comment">// 获取线程关联的ThreadLocalMap哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">// 获取entry</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment">     * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue(); <span class="comment">// 这里其实是返回null</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t); <span class="comment">// 获取线程关联的ThreadLocalMap哈希表</span></span><br><span class="line">        <span class="comment">// 如果ThreadLocalMap存在，则直接插入；不存在，则新建ThreadLocalMap</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value); <span class="comment">// 如果 ThreadLocalMap 为空则创建</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment">     * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment">     * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment">     * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment">     * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>); <span class="comment">// 移除</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 Thread 中获取 threadLocals</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">// Entry的key是ThreadLocal对象，并且是一个弱引用</span></span><br><span class="line">        <span class="comment">// 当没指向key的强引用后，该key就会被垃圾收集器回收</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">// 计算索引下标</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ThreadLocal作为key</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY); <span class="comment">// 设置扩容阈值为 容量的 * 2/3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">        <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>); <span class="comment">// 计算数组下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// key为空，则代表该Entry不再需要，设置 Entry的value指针和Entry指针为null，帮助GC</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="comment">// 如果没有清除entry并且容量到达扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将staleSlot位置的脏Entry替换为新Entry(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        Entry e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">        <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">        <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">        <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">        <span class="comment">// 向前环形遍历找到第一个key为null的Entry, staleEntry 翻译过来就是 脏Entry</span></span><br><span class="line">        <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = prevIndex(i, len))</span><br><span class="line">            <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">        <span class="comment">// occurs first</span></span><br><span class="line">        <span class="comment">// 从staleSlot开始向后环形遍历tab直到tab[i]为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">            <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">            <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">            <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">            <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                <span class="comment">// 如果在向后环形查找过程中发现key相同的Entry就和脏Entry进行交换</span></span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">                tab[i] = tab[staleSlot];</span><br><span class="line">                tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                <span class="comment">// 如果在查找过程中还未发现脏Entry，也就是开始向前环形遍历时没有发现脏Entry</span></span><br><span class="line">                <span class="comment">// 那么就以当前位置作为cleanSomeSlots的起点</span></span><br><span class="line">                <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">                <span class="comment">// 搜索脏Entry并进行清理</span></span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">            <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">            <span class="comment">// first still present in the run.</span></span><br><span class="line">            <span class="comment">// 如果向后环形遍历时发现脏Entry，并且之前向前环形遍历时未发现脏Entry,</span></span><br><span class="line">            <span class="comment">// 后面就以此时这个位置作为起点执行cleanSomeSlots</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        <span class="comment">//如果在查找过程中没有找到可以覆盖的Entry，则将新的entry插入在脏Entry</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            <span class="comment">// 从slotToExpunge位置开始清理脏Entry</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历时发现脏Entry，会调用该方法清除脏Entry，expunge翻译过来就是清除的意思</span></span><br><span class="line">    <span class="comment">// 从 staleSlot 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        <span class="comment">// 清除掉当前的脏Entry(也就是遍历时发现的脏Entry)，帮助GC</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--; <span class="comment">// tab的容量 - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//往后环形遍历直到遇到tab[i]为空</span></span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到脏Entry，将其清理掉</span></span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理rehash的情况</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                    <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数组下标i+1开始清除一些key为null的entry</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">// n &gt;&gt;&gt;= 1 相当于 log2(n)次</span></span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 Entry</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从i出找出的元素为空或者与key不相等(可能发生hash冲突)，</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 采用线性探测法解决hash冲突</span></span><br><span class="line">                <span class="comment">// i = ((i + 1 &lt; len) ? i + 1 : 0)</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                e.clear();</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>使用类 <code>InheritableThreadLocal</code> 可使子线程继承父线程的值，通俗点说就是可以在子线程中获取父线程中设置的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InheritableThreadLocal</code> 源码很简单，只是重写了 <code>ThreadLocal</code> 的三个方法，将存储数据的容器换成<code>Thread</code>对象中 <code>inheritableThreadLocals</code>。</p>
<p>既然其他方法没有改变，那它是如何继承父线程中的数据的呢？<strong>其实是 <code>Thread</code> 构造方法中的 init() 方法实现的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread with the current AccessControlContext.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment"> *        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment"> *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment"> *            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// inheritThreadLocals 默认为 true，如果 父线程中的inheritableThreadLocals不为空</span></span><br><span class="line">    <span class="comment">// 就将其拷贝到子线程中的inheritableThreadLocals</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果父线程中的 <code>inheritableThreadLocal</code> 重新执行了 set 方法，那么子线程执行 get 方法是获取不到父线程中 set 的数据，因为它们是两个不同的引用，和深拷贝浅拷贝无关。</p>
<h2 id="内存泄漏分析"><a href="#内存泄漏分析" class="headerlink" title="内存泄漏分析"></a>内存泄漏分析</h2><img src="/2020/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/ThreadLocal%E7%BB%93%E6%9E%84%E5%9B%BE2.png" class="" title="ThreadLocal结构图">

<p><code>ThreadLocalMap</code>使用 <code>ThreadLocal</code> 的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有强引用指向它， GC 的时候就会被回收，这样 <code>ThreadLocalMap</code> 中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>。</p>
<p>不过，从源码中可以看出，ThreadLocal 的设计者已经考虑到了这种情况，并且在 <code>ThreadLocal</code> 的<code>get()</code>，<code>set()</code>，<code>remove()</code>的时候都会清除线程 <code>ThreadLocalMap</code> 里所有<code>key</code>为 <code>null</code> 的 <code>value</code> 。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p><strong>内存泄漏的根源并非在于使用了弱引用。</strong></p>
<p>分情况讨论：</p>
<ul>
<li><strong>key 使用强引用</strong>：引用的 <code>ThreadLocal</code> 的对象被回收了，但是 <code>ThreadLocalMap</code> 还持有 <code>ThreadLocal</code> 的强引用，如果没有手动删除，<code>ThreadLocal</code> 不会被回收，导致整个 <code>Entry</code> 内存泄漏。</li>
<li><strong>key 使用弱引用</strong>：引用的 <code>ThreadLocal</code> 的对象被回收了，由于 <code>ThreadLocalMap</code> 持有 <code>ThreadLocal</code> 的弱引用，即使没有手动删除，<code>ThreadLocal</code> 也会被回收，但 <code>value</code> 会内存泄漏。不过最终 <code>value</code> 会在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>为什么 value 不使用弱引用呢？</p>
<p>不设置为弱引用，是因为不清楚这个<code>value</code> 除了 <code>ThreadLocalMap</code> 的引用还是否还存在其他引用，如果不存在其他引用，当<code>GC</code>的时候 <code>value</code> 干掉了，而此时我们的 <code>ThreadLocal</code> 还处于使用期间，就会造成 <code>value</code> 为null的错误，所以将其设置为强引用。</p>
<p><code>WeakHashMap</code> 则是将 整个 Entry（key 和 value）都设置成了弱引用，不过它们被设计出来的作用不一样。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>ThreadLocal</code> 变量一般都会采用 <code>static</code> 修饰，这样做既有好处，也有坏处。</p>
<p>将 <code>ThreadLocal</code> 声明为某个类的实例变量，那么每创建一个该类的实例就会导致一个新的 <code>ThreadLocal</code> 实例被创建，可能会导致浪费。</p>
<p>将 <code>ThreadLocal</code> 声明为某个类的静态变量，那么就有了强引用，即使发生 GC 也不会回收threadLocalMap中的key。分以下情况讨论：</p>
<ul>
<li>如果是新建线程，线程消亡时，threadLocalMap整个都会被回收。</li>
<li>如果是使用线程池，下一次使用时则会覆盖 value。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>内存泄漏的根源在于 <code>ThreadLocalMap</code> 的生命周期跟<code>Thread</code>一样长，不管使用弱引用还是强引用都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用 <code>ThreadLocal</code>不会内存泄漏，对应的 <code>value</code> 在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>,<code>remove</code>的时候会被清除</strong>。</p>
<p>要想避免内存泄漏：每次使用完 <code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</p>
<h2 id="应用场景分析"><a href="#应用场景分析" class="headerlink" title="应用场景分析"></a>应用场景分析</h2><ol>
<li>数据库连接</li>
<li>数据库 session 管理</li>
<li>Spring 的声明式事务</li>
<li>Spring 的 RequestContextHolder</li>
<li>web 项目的日志切面</li>
<li>web 项目的用户信息</li>
<li>避免一些复杂的参数传递</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>InheritableThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解强引用、软引用、弱引用、虚引用</title>
    <url>/2020/11/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>Java 包含四种引用类型（引用强度从上到下依次逐渐减弱）：</p>
<ul>
<li><strong>强引用（StrongReference）</strong>：只要对象存在强引用，就不会被GC。</li>
<li><strong>软引用（SoftReference）</strong>：垃圾回收器会在内存不足时回收弱引用指向的对象。</li>
<li><strong>弱引用（WeakReference）</strong>：垃圾回收器在GC时会回收此对象</li>
<li><strong>虚引用（PhantomReference）</strong>：对象是否有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知。</li>
</ul>
<a id="more"></a>

<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是使用最普遍的引用。通过反射、new Object() 等方式创建的都是强引用。</p>
<p><strong>强引用的对象只要引用还存在，GC就不会回收这个对象。即使在内存不足的情况下，JVM 宁愿抛出OutOfMemory 错误也不会回收这种对象。</strong></p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用用来描述一些还有用，但非必需的对象。Java 提供了 <code>java.lang.ref.SoftReference</code> 类来实现软引用。</p>
<p><strong>只有在内存不足，发生内存溢出异常之前 JVM 才会回收该对象。</strong>如果回收了软引用的对象还是没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用的特性比较适合用来实现缓存：比如网页缓存、图片缓存等，不过缺点是会造成大量的<strong>内存浪费</strong>。</p>
<p><strong>软引用可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果软引用所引用的对象被 JVM 回收，这个软引用就会被加入到与之关联的引用队列中。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>对于弱引用的对象来说，<strong>只要垃圾回收机制一运行，不管 JVM 的内存空间是否够，都会回收该对象的占用内存。</strong>Java 提供了 <code>java.lang.ref.WeakReference</code> 类来实现软引用。</p>
<p>弱引用的也比较适合用来实现缓存，JDK 中的 <code>WeakHashMap</code>、<code>ThreadLocal</code> 也使用了弱引用。</p>
<p><strong>弱引用也可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果弱引用所引用的对象被 JVM 回收，这个弱引用就会被加入到与之关联的引用队列中。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p><strong>对象是否有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知。</strong>Java 提供了 <code>java.lang.ref.PhantomReference</code> 类来实现软引用。</p>
<p><strong>虚引用必须和引用队列（ReferenceQueue）关联使用。</strong></p>
<h2 id="ReferenceQueue使用示例"><a href="#ReferenceQueue使用示例" class="headerlink" title="ReferenceQueue使用示例"></a>ReferenceQueue使用示例</h2><h3 id="WeakReference-使用示例"><a href="#WeakReference-使用示例" class="headerlink" title="WeakReference 使用示例"></a>WeakReference 使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 实现一个弱引用，将强引用类型hello和是实例化的rq放到弱引用实现里面</span></span><br><span class="line">        WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), referenceQueue);</span><br><span class="line">        <span class="comment">// 通过弱引用get方法获取强引用中创建的内存空间hello值</span></span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 通知JVM的gc进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"weakReference.get() :"</span> + weakReference.get());</span><br><span class="line">            Reference&lt;? extends String&gt; reference = referenceQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (reference == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"reference :"</span> + <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"reference == weakReference:"</span> + (reference == weakReference));</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">weakReference.<span class="keyword">get</span>() :<span class="literal">null</span></span><br><span class="line"><span class="built_in">ref</span>erence == weakReference:<span class="literal">true</span></span><br><span class="line">weakReference.<span class="keyword">get</span>() :<span class="literal">null</span></span><br><span class="line"><span class="built_in">ref</span>erence :<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference-使用示例"><a href="#PhantomReference-使用示例" class="headerlink" title="PhantomReference 使用示例"></a>PhantomReference 使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), rq);</span><br><span class="line">        System.out.println(pr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="引用类型和可达性"><a href="#引用类型和可达性" class="headerlink" title="引用类型和可达性"></a>引用类型和可达性</h2><p>对象的可达性与引用类型密切相关。Java 有 5 中类型的可达性：</p>
<ul>
<li><strong>强可达（Strongly Reachable）</strong>：如果线程能通过强引用访问到对象，那么这个对象就是强可达的。</li>
<li><strong>软可达（Soft Reachable）</strong>：如果一个对象不是强可达的，但是可以通过软引用访问到，那么这个对象就是软可达的</li>
<li><strong>弱可达（Weak Reachable）</strong>：如果一个对象不是强可达或者软可达的，但是可以通过弱引用访问到，那么这个对象就是弱可达的。</li>
<li><strong>虚可达（Phantom Reachable）</strong>：如果一个对象不是强可达，软可达或者弱可达，并且这个对象已经finalize过了，并且有虚引用指向该对象，那么这个对象就是虚可达的。</li>
<li><strong>不可达（Unreachable）</strong>：如果对象不能通过上述的几种方式访问到，则对象是不可达的，可以被回收。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><img src="/2020/11/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/Reference%E7%B1%BB%E5%9B%BE.png" class="" title="Reference类图">

<p>Reference及其子类有两大功能：</p>
<ol>
<li><p>实现特定的引用类型</p>
<p>JVM 垃圾回收器硬编码识别 <code>SoftReference</code>，<code>WeakReference</code>，<code>PhantomReference</code> 等这些具体的类，对其reference变量进行特殊处理，才有了不同的引用类型的效果。</p>
</li>
<li><p>用户可以对象被回收后得到通知</p>
<p>将被回收的对象的 <code>Reference</code> 添加到一个队列中，用户后续自己去从队列中获取并使用。这里没有采用回调的机制，可能是担心回调执行阻塞。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 引用的对象</span></span><br><span class="line">    <span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">    <span class="comment">// 自定义的引用队列，如果引用的对象被回收，这可以从该队列中获取相应的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">    <span class="comment">// 如果处于Active状态：next = null</span></span><br><span class="line">    <span class="comment">// 如果处于Pending状态：next = this</span></span><br><span class="line">    <span class="comment">// 如果处于Enqueued状态：next = ReferenceQueue中的下一个元素</span></span><br><span class="line">    <span class="comment">// 如果处于Inactive转改：next = this</span></span><br><span class="line">    <span class="keyword">volatile</span> Reference next;</span><br><span class="line">    <span class="comment">// pending 引用链表的指针，指向下一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line">    <span class="comment">// 用于控制垃圾收集器操作是否与Pending状态的Reference enqueue操作不冲突的全局锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="comment">// pending 引用链表的头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用状态"><a href="#引用状态" class="headerlink" title="引用状态"></a>引用状态</h3><p>Reference 对象是有状态的。一共有4中状态：</p>
<ul>
<li><strong>Active：</strong>新创建的 Reference 的状态。垃圾回收器会根据其可达性状态将它切换为 Pending 或 Inactive 状态。</li>
<li><strong>Pending：</strong>在 pending 引用链表中的 Reference 的状态，这些 Reference 等待被加入 ReferenceQueue 中。</li>
<li><strong>Enqueued：</strong>在 ReferenceQueue 队列中的 Reference 的状态，如果 Reference从队列中移除，会进入Inactive 状态。</li>
<li><strong>Inactive：</strong>Reference的最终状态。</li>
</ul>
<h3 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h3><img src="/2020/11/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/Reference%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E5%9B%BE.jpg" class="" title="Reference状态转化图">

<h3 id="pending-引用链表"><a href="#pending-引用链表" class="headerlink" title="pending 引用链表"></a>pending 引用链表</h3><p>Reference 引用的对象被回收后，Reference 实例会被添加到 ReferenceQueue 中，这不是垃圾回收器来完成的，如果垃圾回收器还需要执行这个操作，会降低其效率。从另外一方面想，Reference 实例会被添加到ReferenceQueue中的实效性要求不高，所以也没必要在回收时立马加入 ReferenceQueue。</p>
<p>所以垃圾回收器做的是一个更轻量级的操作：把 Reference 添加到 pending 引用链表中。Reference 对象中有一个 pending 成员变量，它就是这个pending 引用链表的头结点，还有一个 discovered 成员变量，它指向下一个节点。</p>
<h3 id="ReferenceHandler线程"><a href="#ReferenceHandler线程" class="headerlink" title="ReferenceHandler线程"></a>ReferenceHandler线程</h3><p>回收 Reference 引用的对象后，垃圾回收器只是将 Reference 添加到 pending 引用链表中。加入 ReferenceQueue 无法在垃圾回收线程中执行，而是由 ReferenceHandler 线程负责。</p>
<p>Reference  中定义了 ReferenceHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">        <span class="comment">// so that we don't get into trouble later in the run loop if there's</span></span><br><span class="line">        <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">        ensureClassInitialized(InterruptedException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直将pending 引用链表中的Reference放入ReferenceQueue中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tryHandlePending(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁，避免同时垃圾回收器操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span><br><span class="line">                <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span><br><span class="line">                <span class="comment">// 判断引用是否为 Cleaner</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">        <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">        <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span><br><span class="line">        <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path for cleaners</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c.clean(); <span class="comment">// 如果Reference 为Cleaner，则调用其clean方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="comment">// 将 Rference 放入 RerenceQueue</span></span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">         * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY); <span class="comment">// 设置线程优先级为最高</span></span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>); <span class="comment">// 守护线程</span></span><br><span class="line">    handler.start(); <span class="comment">// 启动线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>如果 Reference 所引用的对象被 JVM 回收，这个 Reference 就会被加入到与之关联的 ReferenceQueue 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点，说明ReferenceQueue基于链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 用于保证线程安全</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只能被Reference类调用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 加锁保证线程安全</span></span><br><span class="line">            <span class="comment">// 判断是否需要加入ReferenceQueue</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head; <span class="comment">// 这里的next可以看下上面的注释</span></span><br><span class="line">            head = r; <span class="comment">// 头插法</span></span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个使用 Reference + ReferenceQueue 的完整流程如下：</p>
<img src="/2020/11/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/Reference%E6%B5%81%E7%A8%8B.jpg" class="" title="Reference流程图">

<h2 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h2><p>Cleaner 继承自 PhantomReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 这个属性用不到，ReferenceHandler 中也不会将元素放入该队列中</span></span><br><span class="line">    <span class="comment">// 因为 PhantomReference 的构造方法必须要传ReferenceQueue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="comment">// 链表的表头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cleaner first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="keyword">private</span> Cleaner next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Cleaner prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 用户自定义的需要执行的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line">    <span class="comment">// 采用头插法插入双向链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Cleaner <span class="title">add</span><span class="params">(Cleaner var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var0.next = first;</span><br><span class="line">            first.prev = var0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first = var0;</span><br><span class="line">        <span class="keyword">return</span> var0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从双向链表中移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Cleaner var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (var0.next == var0) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == var0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var0.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    first = var0.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    first = var0.prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var0.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var0.next.prev = var0.prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var0.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var0.prev.next = var0.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var0.next = var0;</span><br><span class="line">            var0.prev = var0;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cleaner</span><span class="params">(Object var1, Runnable var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1, dummyQueue);</span><br><span class="line">        <span class="keyword">this</span>.thunk = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : add(<span class="keyword">new</span> Cleaner(var0, var1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法会由ReferenceHandler线程调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.thunk.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            (<span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DirectByteBuffer-内存回收策略"><a href="#DirectByteBuffer-内存回收策略" class="headerlink" title="DirectByteBuffer 内存回收策略"></a>DirectByteBuffer 内存回收策略</h3><p>DirectByteBuffer 初始化时通过 Unsafe 的本地方法 allocateMemory() 进行内存分配，底层调用的是操作系统的 malloc() 函数，除此之外，初始化时还会创建一个 Deallocator 线程，并通过 Cleaner 机制来调用 freeMemory() 方法来对直接内存进行回收操作，freeMemory() 底层调用的是操作系统的 free() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>DirectByteBuffer 创建一个Cleaner，并把代表清理动作的Deallocator类绑定。</li>
<li>DirectBuffer 如果没有强引用，JVM 就会将 Cleaner 放到 pending 引用链表里。</li>
<li>ReferenceHandler线程会循环获取 pending 引用链表中的元素，如果是 Cleaner，则会执行其 clean 方法，进而执行 Deallocator 中的run方法调用 freeMemory() 释放内存。</li>
</ol>
<h2 id="FinalReference"><a href="#FinalReference" class="headerlink" title="FinalReference"></a>FinalReference</h2><p>FinalReference 继承自 Reference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Final references, used to implement finalization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FinalReference 类仅仅是继承了 Reference 类而已，真正的逻辑位于 FinalReference 的唯一子类：<code>java.lang.ref.Finalizer</code> 中。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>finalize() 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 finalize() 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。</p>
<p>finalize() 只会在对象内存回收前被调用一次，但 finalize() 的调用具有不确定性，只保证方法会调用，但不保证方法里的任务会被执行完。</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> <span class="keyword">extends</span> <span class="title">FinalReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 链表表头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Finalizer unfinalized = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="keyword">private</span> Finalizer next = <span class="keyword">null</span>, prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(finalizee, queue);</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Invoked by VM */</span></span><br><span class="line">    <span class="comment">// register方法仅会被虚拟机所调用，并且只有重写了java.lang.Object的finalize方法的类</span></span><br><span class="line">    <span class="comment">// 才会被作为参数调用Finalizer#register方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Finalizer(finalizee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.next = unfinalized;</span><br><span class="line">                unfinalized.prev = <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unfinalized = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FinalizerThread"><a href="#FinalizerThread" class="headerlink" title="FinalizerThread"></a>FinalizerThread</h3><p>Finalizer 中定义了 FinalizerThread：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span><br><span class="line">    FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, <span class="string">"Finalizer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// in case of recursive call to run()</span></span><br><span class="line">        <span class="keyword">if</span> (running)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finalizer thread starts before System.initializeSystemClass</span></span><br><span class="line">        <span class="comment">// is called.  Wait until JavaLangAccess is available</span></span><br><span class="line">        <span class="keyword">while</span> (!VM.isBooted()) &#123;</span><br><span class="line">            <span class="comment">// delay until VM completes initialization</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                VM.awaitBooted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="comment">// ignore and continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 循环取出队首元素并执行runFinalizer方法</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Finalizer f = (Finalizer)queue.remove();</span><br><span class="line">                f.runFinalizer(jla);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="comment">// ignore and continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread finalizer = <span class="keyword">new</span> FinalizerThread(tg);</span><br><span class="line">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>); <span class="comment">// 优先级不是最高</span></span><br><span class="line">    finalizer.setDaemon(<span class="keyword">true</span>); <span class="comment">// 守护线程</span></span><br><span class="line">    finalizer.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// hasBeenFinalized的作用就是保证finalize方法只会被调用一次</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>; </span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里和其他 Reference 不同</span></span><br><span class="line">        <span class="comment">// 其他 Reference 在进入 pending 前 referent 属性为空（因为GC）</span></span><br><span class="line">        Object finalizee = <span class="keyword">this</span>.get(); </span><br><span class="line">        <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">            jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span><br><span class="line"><span class="comment">                   the chances of false retention with a conservative GC */</span></span><br><span class="line">            finalizee = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">    <span class="keyword">super</span>.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeFinalize</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    var1.finalize(); <span class="comment">// 调用finalize()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里和之前有些不同，Finalizer的 referent 属性在加入 pending 引用链表前不会被GC。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>强引用</tag>
        <tag>软引用</tag>
        <tag>弱引用</tag>
        <tag>虚引用</tag>
        <tag>StrongReference</tag>
        <tag>SoftReference</tag>
        <tag>WeakReference</tag>
        <tag>PhantomReference</tag>
        <tag>ReferenceQueue</tag>
        <tag>Cleaner</tag>
        <tag>FinalReference</tag>
        <tag>Finalizer</tag>
      </tags>
  </entry>
</search>
